(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const a of document.querySelectorAll('link[rel="modulepreload"]')) n(a);
    new MutationObserver(a => {
        for (const i of a)
            if (i.type === "childList")
                for (const s of i.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && n(s)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function r(a) {
        const i = {};
        return a.integrity && (i.integrity = a.integrity), a.referrerPolicy && (i.referrerPolicy = a.referrerPolicy), a.crossOrigin === "use-credentials" ? i.credentials = "include" : a.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i
    }

    function n(a) {
        if (a.ep) return;
        a.ep = !0;
        const i = r(a);
        fetch(a.href, i)
    }
})();
/**
 * @vue/shared v3.4.23
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/*! #__NO_SIDE_EFFECTS__ */
function yi(e, t) {
    const r = new Set(e.split(","));
    return t ? n => r.has(n.toLowerCase()) : n => r.has(n)
}
const Ve = {},
    Rr = [],
    _t = () => {},
    hu = () => !1,
    aa = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
    bi = e => e.startsWith("onUpdate:"),
    rt = Object.assign,
    wi = (e, t) => {
        const r = e.indexOf(t);
        r > -1 && e.splice(r, 1)
    },
    mu = Object.prototype.hasOwnProperty,
    xe = (e, t) => mu.call(e, t),
    ie = Array.isArray,
    Ur = e => ia(e) === "[object Map]",
    yo = e => ia(e) === "[object Set]",
    oe = e => typeof e == "function",
    Ze = e => typeof e == "string",
    Er = e => typeof e == "symbol",
    Re = e => e !== null && typeof e == "object",
    bo = e => (Re(e) || oe(e)) && oe(e.then) && oe(e.catch),
    wo = Object.prototype.toString,
    ia = e => wo.call(e),
    vu = e => ia(e).slice(8, -1),
    _o = e => ia(e) === "[object Object]",
    _i = e => Ze(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e,
    sn = yi(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    sa = e => {
        const t = Object.create(null);
        return r => t[r] || (t[r] = e(r))
    },
    pu = /-(\w)/g,
    Rt = sa(e => e.replace(pu, (t, r) => r ? r.toUpperCase() : "")),
    gu = /\B([A-Z])/g,
    Br = sa(e => e.replace(gu, "-$1").toLowerCase()),
    oa = sa(e => e.charAt(0).toUpperCase() + e.slice(1)),
    Ma = sa(e => e ? `on${oa(e)}` : ""),
    sr = (e, t) => !Object.is(e, t),
    Ln = (e, t) => {
        for (let r = 0; r < e.length; r++) e[r](t)
    },
    xo = (e, t, r) => {
        Object.defineProperty(e, t, {
            configurable: !0,
            enumerable: !1,
            value: r
        })
    },
    za = e => {
        const t = parseFloat(e);
        return isNaN(t) ? e : t
    };
let ts;
const ko = () => ts || (ts = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function zr(e) {
    if (ie(e)) {
        const t = {};
        for (let r = 0; r < e.length; r++) {
            const n = e[r],
                a = Ze(n) ? _u(n) : zr(n);
            if (a)
                for (const i in a) t[i] = a[i]
        }
        return t
    } else if (Ze(e) || Re(e)) return e
}
const yu = /;(?![^(]*\))/g,
    bu = /:([^]+)/,
    wu = /\/\*[^]*?\*\//g;

function _u(e) {
    const t = {};
    return e.replace(wu, "").split(yu).forEach(r => {
        if (r) {
            const n = r.split(bu);
            n.length > 1 && (t[n[0].trim()] = n[1].trim())
        }
    }), t
}

function or(e) {
    let t = "";
    if (Ze(e)) t = e;
    else if (ie(e))
        for (let r = 0; r < e.length; r++) {
            const n = or(e[r]);
            n && (t += n + " ")
        } else if (Re(e))
            for (const r in e) e[r] && (t += r + " ");
    return t.trim()
}
const xu = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    ku = yi(xu);

function Oo(e) {
    return !!e || e === ""
}
const ve = e => Ze(e) ? e : e == null ? "" : ie(e) || Re(e) && (e.toString === wo || !oe(e.toString)) ? JSON.stringify(e, To, 2) : String(e),
    To = (e, t) => t && t.__v_isRef ? To(e, t.value) : Ur(t) ? {
        [`Map(${t.size})`]: [...t.entries()].reduce((r, [n, a], i) => (r[Ea(n, i) + " =>"] = a, r), {})
    } : yo(t) ? {
        [`Set(${t.size})`]: [...t.values()].map(r => Ea(r))
    } : Er(t) ? Ea(t) : Re(t) && !ie(t) && !_o(t) ? String(t) : t,
    Ea = (e, t = "") => {
        var r;
        return Er(e) ? `Symbol(${(r = e.description) != null ? r : t})` : e
    };
/**
 * @vue/reactivity v3.4.23
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let Ct;
class Ou {
    constructor(t = !1) {
        this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Ct, !t && Ct && (this.index = (Ct.scopes || (Ct.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(t) {
        if (this._active) {
            const r = Ct;
            try {
                return Ct = this, t()
            } finally {
                Ct = r
            }
        }
    }
    on() {
        Ct = this
    }
    off() {
        Ct = this.parent
    }
    stop(t) {
        if (this._active) {
            let r, n;
            for (r = 0, n = this.effects.length; r < n; r++) this.effects[r].stop();
            for (r = 0, n = this.cleanups.length; r < n; r++) this.cleanups[r]();
            if (this.scopes)
                for (r = 0, n = this.scopes.length; r < n; r++) this.scopes[r].stop(!0);
            if (!this.detached && this.parent && !t) {
                const a = this.parent.scopes.pop();
                a && a !== this && (this.parent.scopes[this.index] = a, a.index = this.index)
            }
            this.parent = void 0, this._active = !1
        }
    }
}

function Tu(e, t = Ct) {
    t && t.active && t.effects.push(e)
}

function Cu() {
    return Ct
}
let _r;
class xi {
    constructor(t, r, n, a) {
        this.fn = t, this.trigger = r, this.scheduler = n, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, Tu(this, a)
    }
    get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
            this._dirtyLevel = 1, ur();
            for (let t = 0; t < this._depsLength; t++) {
                const r = this.deps[t];
                if (r.computed && (Du(r.computed), this._dirtyLevel >= 4)) break
            }
            this._dirtyLevel === 1 && (this._dirtyLevel = 0), cr()
        }
        return this._dirtyLevel >= 4
    }
    set dirty(t) {
        this._dirtyLevel = t ? 4 : 0
    }
    run() {
        if (this._dirtyLevel = 0, !this.active) return this.fn();
        let t = nr,
            r = _r;
        try {
            return nr = !0, _r = this, this._runnings++, rs(this), this.fn()
        } finally {
            ns(this), this._runnings--, _r = r, nr = t
        }
    }
    stop() {
        var t;
        this.active && (rs(this), ns(this), (t = this.onStop) == null || t.call(this), this.active = !1)
    }
}

function Du(e) {
    return e.value
}

function rs(e) {
    e._trackId++, e._depsLength = 0
}

function ns(e) {
    if (e.deps.length > e._depsLength) {
        for (let t = e._depsLength; t < e.deps.length; t++) Co(e.deps[t], e);
        e.deps.length = e._depsLength
    }
}

function Co(e, t) {
    const r = e.get(t);
    r !== void 0 && t._trackId !== r && (e.delete(t), e.size === 0 && e.cleanup())
}
let nr = !0,
    Za = 0;
const Do = [];

function ur() {
    Do.push(nr), nr = !1
}

function cr() {
    const e = Do.pop();
    nr = e === void 0 ? !0 : e
}

function ki() {
    Za++
}

function Oi() {
    for (Za--; !Za && Ga.length;) Ga.shift()()
}

function So(e, t, r) {
    if (t.get(e) !== e._trackId) {
        t.set(e, e._trackId);
        const n = e.deps[e._depsLength];
        n !== t ? (n && Co(n, e), e.deps[e._depsLength++] = t) : e._depsLength++
    }
}
const Ga = [];

function Mo(e, t, r) {
    ki();
    for (const n of e.keys()) {
        let a;
        n._dirtyLevel < t && (a ?? (a = e.get(n) === n._trackId)) && (n._shouldSchedule || (n._shouldSchedule = n._dirtyLevel === 0), n._dirtyLevel = t), n._shouldSchedule && (a ?? (a = e.get(n) === n._trackId)) && (n.trigger(), (!n._runnings || n.allowRecurse) && n._dirtyLevel !== 2 && (n._shouldSchedule = !1, n.scheduler && Ga.push(n.scheduler)))
    }
    Oi()
}
const Eo = (e, t) => {
        const r = new Map;
        return r.cleanup = e, r.computed = t, r
    },
    Rn = new WeakMap,
    xr = Symbol(""),
    Qa = Symbol("");

function vt(e, t, r) {
    if (nr && _r) {
        let n = Rn.get(e);
        n || Rn.set(e, n = new Map);
        let a = n.get(r);
        a || n.set(r, a = Eo(() => n.delete(r))), So(_r, a)
    }
}

function Wt(e, t, r, n, a, i) {
    const s = Rn.get(e);
    if (!s) return;
    let o = [];
    if (t === "clear") o = [...s.values()];
    else if (r === "length" && ie(e)) {
        const l = Number(n);
        s.forEach((u, c) => {
            (c === "length" || !Er(c) && c >= l) && o.push(u)
        })
    } else switch (r !== void 0 && o.push(s.get(r)), t) {
        case "add":
            ie(e) ? _i(r) && o.push(s.get("length")) : (o.push(s.get(xr)), Ur(e) && o.push(s.get(Qa)));
            break;
        case "delete":
            ie(e) || (o.push(s.get(xr)), Ur(e) && o.push(s.get(Qa)));
            break;
        case "set":
            Ur(e) && o.push(s.get(xr));
            break
    }
    ki();
    for (const l of o) l && Mo(l, 4);
    Oi()
}

function Su(e, t) {
    var r;
    return (r = Rn.get(e)) == null ? void 0 : r.get(t)
}
const Mu = yi("__proto__,__v_isRef,__isVue"),
    Po = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Er)),
    as = Eu();

function Eu() {
    const e = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(t => {
        e[t] = function(...r) {
            const n = Te(this);
            for (let i = 0, s = this.length; i < s; i++) vt(n, "get", i + "");
            const a = n[t](...r);
            return a === -1 || a === !1 ? n[t](...r.map(Te)) : a
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => {
        e[t] = function(...r) {
            ur(), ki();
            const n = Te(this)[t].apply(this, r);
            return Oi(), cr(), n
        }
    }), e
}

function Pu(e) {
    Er(e) || (e = String(e));
    const t = Te(this);
    return vt(t, "has", e), t.hasOwnProperty(e)
}
class $o {
    constructor(t = !1, r = !1) {
        this._isReadonly = t, this._isShallow = r
    }
    get(t, r, n) {
        const a = this._isReadonly,
            i = this._isShallow;
        if (r === "__v_isReactive") return !a;
        if (r === "__v_isReadonly") return a;
        if (r === "__v_isShallow") return i;
        if (r === "__v_raw") return n === (a ? i ? Wu : No : i ? Ao : Lo).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(n) ? t : void 0;
        const s = ie(t);
        if (!a) {
            if (s && xe(as, r)) return Reflect.get(as, r, n);
            if (r === "hasOwnProperty") return Pu
        }
        const o = Reflect.get(t, r, n);
        return (Er(r) ? Po.has(r) : Mu(r)) || (a || vt(t, "get", r), i) ? o : Ge(o) ? s && _i(r) ? o : o.value : Re(o) ? a ? Di(o) : Tr(o) : o
    }
}
class Fo extends $o {
    constructor(t = !1) {
        super(!1, t)
    }
    set(t, r, n, a) {
        let i = t[r];
        if (!this._isShallow) {
            const l = fn(i);
            if (!Un(n) && !fn(n) && (i = Te(i), n = Te(n)), !ie(t) && Ge(i) && !Ge(n)) return l ? !1 : (i.value = n, !0)
        }
        const s = ie(t) && _i(r) ? Number(r) < t.length : xe(t, r),
            o = Reflect.set(t, r, n, a);
        return t === Te(a) && (s ? sr(n, i) && Wt(t, "set", r, n) : Wt(t, "add", r, n)), o
    }
    deleteProperty(t, r) {
        const n = xe(t, r);
        t[r];
        const a = Reflect.deleteProperty(t, r);
        return a && n && Wt(t, "delete", r, void 0), a
    }
    has(t, r) {
        const n = Reflect.has(t, r);
        return (!Er(r) || !Po.has(r)) && vt(t, "has", r), n
    }
    ownKeys(t) {
        return vt(t, "iterate", ie(t) ? "length" : xr), Reflect.ownKeys(t)
    }
}
class $u extends $o {
    constructor(t = !1) {
        super(!0, t)
    }
    set(t, r) {
        return !0
    }
    deleteProperty(t, r) {
        return !0
    }
}
const Fu = new Fo,
    Lu = new $u,
    Au = new Fo(!0),
    Ti = e => e,
    la = e => Reflect.getPrototypeOf(e);

function kn(e, t, r = !1, n = !1) {
    e = e.__v_raw;
    const a = Te(e),
        i = Te(t);
    r || (sr(t, i) && vt(a, "get", t), vt(a, "get", i));
    const {
        has: s
    } = la(a), o = n ? Ti : r ? Mi : hn;
    if (s.call(a, t)) return o(e.get(t));
    if (s.call(a, i)) return o(e.get(i));
    e !== a && e.get(t)
}

function On(e, t = !1) {
    const r = this.__v_raw,
        n = Te(r),
        a = Te(e);
    return t || (sr(e, a) && vt(n, "has", e), vt(n, "has", a)), e === a ? r.has(e) : r.has(e) || r.has(a)
}

function Tn(e, t = !1) {
    return e = e.__v_raw, !t && vt(Te(e), "iterate", xr), Reflect.get(e, "size", e)
}

function is(e) {
    e = Te(e);
    const t = Te(this);
    return la(t).has.call(t, e) || (t.add(e), Wt(t, "add", e, e)), this
}

function ss(e, t) {
    t = Te(t);
    const r = Te(this),
        {
            has: n,
            get: a
        } = la(r);
    let i = n.call(r, e);
    i || (e = Te(e), i = n.call(r, e));
    const s = a.call(r, e);
    return r.set(e, t), i ? sr(t, s) && Wt(r, "set", e, t) : Wt(r, "add", e, t), this
}

function os(e) {
    const t = Te(this),
        {
            has: r,
            get: n
        } = la(t);
    let a = r.call(t, e);
    a || (e = Te(e), a = r.call(t, e)), n && n.call(t, e);
    const i = t.delete(e);
    return a && Wt(t, "delete", e, void 0), i
}

function ls() {
    const e = Te(this),
        t = e.size !== 0,
        r = e.clear();
    return t && Wt(e, "clear", void 0, void 0), r
}

function Cn(e, t) {
    return function(n, a) {
        const i = this,
            s = i.__v_raw,
            o = Te(s),
            l = t ? Ti : e ? Mi : hn;
        return !e && vt(o, "iterate", xr), s.forEach((u, c) => n.call(a, l(u), l(c), i))
    }
}

function Dn(e, t, r) {
    return function(...n) {
        const a = this.__v_raw,
            i = Te(a),
            s = Ur(i),
            o = e === "entries" || e === Symbol.iterator && s,
            l = e === "keys" && s,
            u = a[e](...n),
            c = r ? Ti : t ? Mi : hn;
        return !t && vt(i, "iterate", l ? Qa : xr), {
            next() {
                const {
                    value: d,
                    done: h
                } = u.next();
                return h ? {
                    value: d,
                    done: h
                } : {
                    value: o ? [c(d[0]), c(d[1])] : c(d),
                    done: h
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function Gt(e) {
    return function(...t) {
        return e === "delete" ? !1 : e === "clear" ? void 0 : this
    }
}

function Nu() {
    const e = {
            get(i) {
                return kn(this, i)
            },
            get size() {
                return Tn(this)
            },
            has: On,
            add: is,
            set: ss,
            delete: os,
            clear: ls,
            forEach: Cn(!1, !1)
        },
        t = {
            get(i) {
                return kn(this, i, !1, !0)
            },
            get size() {
                return Tn(this)
            },
            has: On,
            add: is,
            set: ss,
            delete: os,
            clear: ls,
            forEach: Cn(!1, !0)
        },
        r = {
            get(i) {
                return kn(this, i, !0)
            },
            get size() {
                return Tn(this, !0)
            },
            has(i) {
                return On.call(this, i, !0)
            },
            add: Gt("add"),
            set: Gt("set"),
            delete: Gt("delete"),
            clear: Gt("clear"),
            forEach: Cn(!0, !1)
        },
        n = {
            get(i) {
                return kn(this, i, !0, !0)
            },
            get size() {
                return Tn(this, !0)
            },
            has(i) {
                return On.call(this, i, !0)
            },
            add: Gt("add"),
            set: Gt("set"),
            delete: Gt("delete"),
            clear: Gt("clear"),
            forEach: Cn(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(i => {
        e[i] = Dn(i, !1, !1), r[i] = Dn(i, !0, !1), t[i] = Dn(i, !1, !0), n[i] = Dn(i, !0, !0)
    }), [e, r, t, n]
}
const [ju, Iu, Vu, Ru] = Nu();

function Ci(e, t) {
    const r = t ? e ? Ru : Vu : e ? Iu : ju;
    return (n, a, i) => a === "__v_isReactive" ? !e : a === "__v_isReadonly" ? e : a === "__v_raw" ? n : Reflect.get(xe(r, a) && a in n ? r : n, a, i)
}
const Uu = {
        get: Ci(!1, !1)
    },
    Yu = {
        get: Ci(!1, !0)
    },
    qu = {
        get: Ci(!0, !1)
    },
    Lo = new WeakMap,
    Ao = new WeakMap,
    No = new WeakMap,
    Wu = new WeakMap;

function Hu(e) {
    switch (e) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function Bu(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : Hu(vu(e))
}

function Tr(e) {
    return fn(e) ? e : Si(e, !1, Fu, Uu, Lo)
}

function zu(e) {
    return Si(e, !1, Au, Yu, Ao)
}

function Di(e) {
    return Si(e, !0, Lu, qu, No)
}

function Si(e, t, r, n, a) {
    if (!Re(e) || e.__v_raw && !(t && e.__v_isReactive)) return e;
    const i = a.get(e);
    if (i) return i;
    const s = Bu(e);
    if (s === 0) return e;
    const o = new Proxy(e, s === 2 ? n : r);
    return a.set(e, o), o
}

function on(e) {
    return fn(e) ? on(e.__v_raw) : !!(e && e.__v_isReactive)
}

function fn(e) {
    return !!(e && e.__v_isReadonly)
}

function Un(e) {
    return !!(e && e.__v_isShallow)
}

function jo(e) {
    return e ? !!e.__v_raw : !1
}

function Te(e) {
    const t = e && e.__v_raw;
    return t ? Te(t) : e
}

function Zu(e) {
    return Object.isExtensible(e) && xo(e, "__v_skip", !0), e
}
const hn = e => Re(e) ? Tr(e) : e,
    Mi = e => Re(e) ? Di(e) : e;
class Io {
    constructor(t, r, n, a) {
        this.getter = t, this._setter = r, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new xi(() => t(this._value), () => An(this, this.effect._dirtyLevel === 2 ? 2 : 3)), this.effect.computed = this, this.effect.active = this._cacheable = !a, this.__v_isReadonly = n
    }
    get value() {
        const t = Te(this);
        return (!t._cacheable || t.effect.dirty) && sr(t._value, t._value = t.effect.run()) && An(t, 4), Vo(t), t.effect._dirtyLevel >= 2 && An(t, 2), t._value
    }
    set value(t) {
        this._setter(t)
    }
    get _dirty() {
        return this.effect.dirty
    }
    set _dirty(t) {
        this.effect.dirty = t
    }
}

function Gu(e, t, r = !1) {
    let n, a;
    const i = oe(e);
    return i ? (n = e, a = _t) : (n = e.get, a = e.set), new Io(n, a, i || !a, r)
}

function Vo(e) {
    var t;
    nr && _r && (e = Te(e), So(_r, (t = e.dep) != null ? t : e.dep = Eo(() => e.dep = void 0, e instanceof Io ? e : void 0)))
}

function An(e, t = 4, r) {
    e = Te(e);
    const n = e.dep;
    n && Mo(n, t)
}

function Ge(e) {
    return !!(e && e.__v_isRef === !0)
}

function re(e) {
    return Ro(e, !1)
}

function Qu(e) {
    return Ro(e, !0)
}

function Ro(e, t) {
    return Ge(e) ? e : new Ku(e, t)
}
class Ku {
    constructor(t, r) {
        this.__v_isShallow = r, this.dep = void 0, this.__v_isRef = !0, this._rawValue = r ? t : Te(t), this._value = r ? t : hn(t)
    }
    get value() {
        return Vo(this), this._value
    }
    set value(t) {
        const r = this.__v_isShallow || Un(t) || fn(t);
        t = r ? t : Te(t), sr(t, this._rawValue) && (this._rawValue = t, this._value = r ? t : hn(t), An(this, 4))
    }
}

function q(e) {
    return Ge(e) ? e.value : e
}

function De(e) {
    return oe(e) ? e() : q(e)
}
const Xu = {
    get: (e, t, r) => q(Reflect.get(e, t, r)),
    set: (e, t, r, n) => {
        const a = e[t];
        return Ge(a) && !Ge(r) ? (a.value = r, !0) : Reflect.set(e, t, r, n)
    }
};

function Uo(e) {
    return on(e) ? e : new Proxy(e, Xu)
}
class Ju {
    constructor(t, r, n) {
        this._object = t, this._key = r, this._defaultValue = n, this.__v_isRef = !0
    }
    get value() {
        const t = this._object[this._key];
        return t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
    get dep() {
        return Su(Te(this._object), this._key)
    }
}
class ec {
    constructor(t) {
        this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}

function vr(e, t, r) {
    return Ge(e) ? e : oe(e) ? new ec(e) : Re(e) && arguments.length > 1 ? tc(e, t, r) : re(e)
}

function tc(e, t, r) {
    const n = e[t];
    return Ge(n) ? n : new Ju(e, t, r)
}
/**
 * @vue/runtime-core v3.4.23
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function ar(e, t, r, n) {
    try {
        return n ? e(...n) : e()
    } catch (a) {
        ua(a, t, r)
    }
}

function Mt(e, t, r, n) {
    if (oe(e)) {
        const a = ar(e, t, r, n);
        return a && bo(a) && a.catch(i => {
            ua(i, t, r)
        }), a
    }
    if (ie(e)) {
        const a = [];
        for (let i = 0; i < e.length; i++) a.push(Mt(e[i], t, r, n));
        return a
    }
}

function ua(e, t, r, n = !0) {
    const a = t ? t.vnode : null;
    if (t) {
        let i = t.parent;
        const s = t.proxy,
            o = `https://vuejs.org/error-reference/#runtime-${r}`;
        for (; i;) {
            const u = i.ec;
            if (u) {
                for (let c = 0; c < u.length; c++)
                    if (u[c](e, s, o) === !1) return
            }
            i = i.parent
        }
        const l = t.appContext.config.errorHandler;
        if (l) {
            ur(), ar(l, null, 10, [e, s, o]), cr();
            return
        }
    }
    rc(e, r, a, n)
}

function rc(e, t, r, n = !0) {
    console.error(e)
}
let mn = !1,
    Ka = !1;
const st = [];
let jt = 0;
const Yr = [];
let Jt = null,
    pr = 0;
const Yo = Promise.resolve();
let Ei = null;

function pt(e) {
    const t = Ei || Yo;
    return e ? t.then(this ? e.bind(this) : e) : t
}

function nc(e) {
    let t = jt + 1,
        r = st.length;
    for (; t < r;) {
        const n = t + r >>> 1,
            a = st[n],
            i = vn(a);
        i < e || i === e && a.pre ? t = n + 1 : r = n
    }
    return t
}

function Pi(e) {
    (!st.length || !st.includes(e, mn && e.allowRecurse ? jt + 1 : jt)) && (e.id == null ? st.push(e) : st.splice(nc(e.id), 0, e), qo())
}

function qo() {
    !mn && !Ka && (Ka = !0, Ei = Yo.then(Ho))
}

function ac(e) {
    const t = st.indexOf(e);
    t > jt && st.splice(t, 1)
}

function ic(e) {
    ie(e) ? Yr.push(...e) : (!Jt || !Jt.includes(e, e.allowRecurse ? pr + 1 : pr)) && Yr.push(e), qo()
}

function us(e, t, r = mn ? jt + 1 : 0) {
    for (; r < st.length; r++) {
        const n = st[r];
        if (n && n.pre) {
            if (e && n.id !== e.uid) continue;
            st.splice(r, 1), r--, n()
        }
    }
}

function Wo(e) {
    if (Yr.length) {
        const t = [...new Set(Yr)].sort((r, n) => vn(r) - vn(n));
        if (Yr.length = 0, Jt) {
            Jt.push(...t);
            return
        }
        for (Jt = t, pr = 0; pr < Jt.length; pr++) Jt[pr]();
        Jt = null, pr = 0
    }
}
const vn = e => e.id == null ? 1 / 0 : e.id,
    sc = (e, t) => {
        const r = vn(e) - vn(t);
        if (r === 0) {
            if (e.pre && !t.pre) return -1;
            if (t.pre && !e.pre) return 1
        }
        return r
    };

function Ho(e) {
    Ka = !1, mn = !0, st.sort(sc);
    try {
        for (jt = 0; jt < st.length; jt++) {
            const t = st[jt];
            t && t.active !== !1 && ar(t, null, 14)
        }
    } finally {
        jt = 0, st.length = 0, Wo(), mn = !1, Ei = null, (st.length || Yr.length) && Ho()
    }
}

function oc(e, t, ...r) {
    if (e.isUnmounted) return;
    const n = e.vnode.props || Ve;
    let a = r;
    const i = t.startsWith("update:"),
        s = i && t.slice(7);
    if (s && s in n) {
        const c = `${s === "modelValue" ? "model" : s}Modifiers`,
            {
                number: d,
                trim: h
            } = n[c] || Ve;
        h && (a = r.map(g => Ze(g) ? g.trim() : g)), d && (a = r.map(za))
    }
    let o, l = n[o = Ma(t)] || n[o = Ma(Rt(t))];
    !l && i && (l = n[o = Ma(Br(t))]), l && Mt(l, e, 6, a);
    const u = n[o + "Once"];
    if (u) {
        if (!e.emitted) e.emitted = {};
        else if (e.emitted[o]) return;
        e.emitted[o] = !0, Mt(u, e, 6, a)
    }
}

function Bo(e, t, r = !1) {
    const n = t.emitsCache,
        a = n.get(e);
    if (a !== void 0) return a;
    const i = e.emits;
    let s = {},
        o = !1;
    if (!oe(e)) {
        const l = u => {
            const c = Bo(u, t, !0);
            c && (o = !0, rt(s, c))
        };
        !r && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l)
    }
    return !i && !o ? (Re(e) && n.set(e, null), null) : (ie(i) ? i.forEach(l => s[l] = null) : rt(s, i), Re(e) && n.set(e, s), s)
}

function ca(e, t) {
    return !e || !aa(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), xe(e, t[0].toLowerCase() + t.slice(1)) || xe(e, Br(t)) || xe(e, t))
}
let Xe = null,
    da = null;

function Yn(e) {
    const t = Xe;
    return Xe = e, da = e && e.type.__scopeId || null, t
}

function zo(e) {
    da = e
}

function Zo() {
    da = null
}

function Ut(e, t = Xe, r) {
    if (!t || e._n) return e;
    const n = (...a) => {
        n._d && ws(-1);
        const i = Yn(t);
        let s;
        try {
            s = e(...a)
        } finally {
            Yn(i), n._d && ws(1)
        }
        return s
    };
    return n._n = !0, n._c = !0, n._d = !0, n
}

function Pa(e) {
    const {
        type: t,
        vnode: r,
        proxy: n,
        withProxy: a,
        props: i,
        propsOptions: [s],
        slots: o,
        attrs: l,
        emit: u,
        render: c,
        renderCache: d,
        data: h,
        setupState: g,
        ctx: y,
        inheritAttrs: k
    } = e;
    let O, U;
    const N = Yn(e);
    try {
        if (r.shapeFlag & 4) {
            const P = a || n,
                E = P;
            O = Nt(c.call(E, P, d, i, g, h, y)), U = l
        } else {
            const P = t;
            O = Nt(P.length > 1 ? P(i, {
                attrs: l,
                slots: o,
                emit: u
            }) : P(i, null)), U = t.props ? l : lc(l)
        }
    } catch (P) {
        dn.length = 0, ua(P, e, 1), O = ue(lr)
    }
    let L = O;
    if (U && k !== !1) {
        const P = Object.keys(U),
            {
                shapeFlag: E
            } = L;
        P.length && E & 7 && (s && P.some(bi) && (U = uc(U, s)), L = Wr(L, U))
    }
    return r.dirs && (L = Wr(L), L.dirs = L.dirs ? L.dirs.concat(r.dirs) : r.dirs), r.transition && (L.transition = r.transition), O = L, Yn(N), O
}
const lc = e => {
        let t;
        for (const r in e)(r === "class" || r === "style" || aa(r)) && ((t || (t = {}))[r] = e[r]);
        return t
    },
    uc = (e, t) => {
        const r = {};
        for (const n in e)(!bi(n) || !(n.slice(9) in t)) && (r[n] = e[n]);
        return r
    };

function cc(e, t, r) {
    const {
        props: n,
        children: a,
        component: i
    } = e, {
        props: s,
        children: o,
        patchFlag: l
    } = t, u = i.emitsOptions;
    if (t.dirs || t.transition) return !0;
    if (r && l >= 0) {
        if (l & 1024) return !0;
        if (l & 16) return n ? cs(n, s, u) : !!s;
        if (l & 8) {
            const c = t.dynamicProps;
            for (let d = 0; d < c.length; d++) {
                const h = c[d];
                if (s[h] !== n[h] && !ca(u, h)) return !0
            }
        }
    } else return (a || o) && (!o || !o.$stable) ? !0 : n === s ? !1 : n ? s ? cs(n, s, u) : !0 : !!s;
    return !1
}

function cs(e, t, r) {
    const n = Object.keys(t);
    if (n.length !== Object.keys(e).length) return !0;
    for (let a = 0; a < n.length; a++) {
        const i = n[a];
        if (t[i] !== e[i] && !ca(r, i)) return !0
    }
    return !1
}

function dc({
    vnode: e,
    parent: t
}, r) {
    for (; t;) {
        const n = t.subTree;
        if (n.suspense && n.suspense.activeBranch === e && (n.el = e.el), n === e)(e = t.vnode).el = r, t = t.parent;
        else break
    }
}
const $i = "components";

function rr(e, t) {
    return Qo($i, e, !0, t) || e
}
const Go = Symbol.for("v-ndc");

function fa(e) {
    return Ze(e) ? Qo($i, e, !1) || e : e || Go
}

function Qo(e, t, r = !0, n = !1) {
    const a = Xe || tt;
    if (a) {
        const i = a.type;
        if (e === $i) {
            const o = td(i, !1);
            if (o && (o === t || o === Rt(t) || o === oa(Rt(t)))) return i
        }
        const s = ds(a[e] || i[e], t) || ds(a.appContext[e], t);
        return !s && n ? i : s
    }
}

function ds(e, t) {
    return e && (e[t] || e[Rt(t)] || e[oa(Rt(t))])
}
const fc = e => e.__isSuspense;

function hc(e, t) {
    t && t.pendingBranch ? ie(e) ? t.effects.push(...e) : t.effects.push(e) : ic(e)
}
const mc = Symbol.for("v-scx"),
    vc = () => qr(mc);

function Nn(e, t) {
    return Fi(e, null, t)
}
const Sn = {};

function xt(e, t, r) {
    return Fi(e, t, r)
}

function Fi(e, t, {
    immediate: r,
    deep: n,
    flush: a,
    once: i,
    onTrack: s,
    onTrigger: o
} = Ve) {
    if (t && i) {
        const w = t;
        t = (...G) => {
            w(...G), E()
        }
    }
    const l = tt,
        u = w => n === !0 ? w : yr(w, n === !1 ? 1 : void 0);
    let c, d = !1,
        h = !1;
    if (Ge(e) ? (c = () => e.value, d = Un(e)) : on(e) ? (c = () => u(e), d = !0) : ie(e) ? (h = !0, d = e.some(w => on(w) || Un(w)), c = () => e.map(w => {
            if (Ge(w)) return w.value;
            if (on(w)) return u(w);
            if (oe(w)) return ar(w, l, 2)
        })) : oe(e) ? t ? c = () => ar(e, l, 2) : c = () => (g && g(), Mt(e, l, 3, [y])) : c = _t, t && n) {
        const w = c;
        c = () => yr(w())
    }
    let g, y = w => {
            g = L.onStop = () => {
                ar(w, l, 4), g = L.onStop = void 0
            }
        },
        k;
    if (ga)
        if (y = _t, t ? r && Mt(t, l, 3, [c(), h ? [] : void 0, y]) : c(), a === "sync") {
            const w = vc();
            k = w.__watcherHandles || (w.__watcherHandles = [])
        } else return _t;
    let O = h ? new Array(e.length).fill(Sn) : Sn;
    const U = () => {
        if (!(!L.active || !L.dirty))
            if (t) {
                const w = L.run();
                (n || d || (h ? w.some((G, se) => sr(G, O[se])) : sr(w, O))) && (g && g(), Mt(t, l, 3, [w, O === Sn ? void 0 : h && O[0] === Sn ? [] : O, y]), O = w)
            } else L.run()
    };
    U.allowRecurse = !!t;
    let N;
    a === "sync" ? N = U : a === "post" ? N = () => ft(U, l && l.suspense) : (U.pre = !0, l && (U.id = l.uid), N = () => Pi(U));
    const L = new xi(c, _t, N),
        P = Cu(),
        E = () => {
            L.stop(), P && wi(P.effects, L)
        };
    return t ? r ? U() : O = L.run() : a === "post" ? ft(L.run.bind(L), l && l.suspense) : L.run(), k && k.push(E), E
}

function pc(e, t, r) {
    const n = this.proxy,
        a = Ze(e) ? e.includes(".") ? Ko(n, e) : () => n[e] : e.bind(n, n);
    let i;
    oe(t) ? i = t : (i = t.handler, r = t);
    const s = _n(this),
        o = Fi(a, i.bind(n), r);
    return s(), o
}

function Ko(e, t) {
    const r = t.split(".");
    return () => {
        let n = e;
        for (let a = 0; a < r.length && n; a++) n = n[r[a]];
        return n
    }
}

function yr(e, t, r = 0, n) {
    if (!Re(e) || e.__v_skip) return e;
    if (t && t > 0) {
        if (r >= t) return e;
        r++
    }
    if (n = n || new Set, n.has(e)) return e;
    if (n.add(e), Ge(e)) yr(e.value, t, r, n);
    else if (ie(e))
        for (let a = 0; a < e.length; a++) yr(e[a], t, r, n);
    else if (yo(e) || Ur(e)) e.forEach(a => {
        yr(a, t, r, n)
    });
    else if (_o(e))
        for (const a in e) yr(e[a], t, r, n);
    return e
}

function At(e, t) {
    if (Xe === null) return e;
    const r = ya(Xe) || Xe.proxy,
        n = e.dirs || (e.dirs = []);
    for (let a = 0; a < t.length; a++) {
        let [i, s, o, l = Ve] = t[a];
        i && (oe(i) && (i = {
            mounted: i,
            updated: i
        }), i.deep && yr(s), n.push({
            dir: i,
            instance: r,
            value: s,
            oldValue: void 0,
            arg: o,
            modifiers: l
        }))
    }
    return e
}

function dr(e, t, r, n) {
    const a = e.dirs,
        i = t && t.dirs;
    for (let s = 0; s < a.length; s++) {
        const o = a[s];
        i && (o.oldValue = i[s].value);
        let l = o.dir[n];
        l && (ur(), Mt(l, r, 8, [e.el, o, e, t]), cr())
    }
} /*! #__NO_SIDE_EFFECTS__ */
function Ht(e, t) {
    return oe(e) ? rt({
        name: e.name
    }, t, {
        setup: e
    }) : e
}
const ln = e => !!e.type.__asyncLoader,
    Xo = e => e.type.__isKeepAlive;

function gc(e, t) {
    Jo(e, "a", t)
}

function yc(e, t) {
    Jo(e, "da", t)
}

function Jo(e, t, r = tt) {
    const n = e.__wdc || (e.__wdc = () => {
        let a = r;
        for (; a;) {
            if (a.isDeactivated) return;
            a = a.parent
        }
        return e()
    });
    if (ha(t, n, r), r) {
        let a = r.parent;
        for (; a && a.parent;) Xo(a.parent.vnode) && bc(n, t, r, a), a = a.parent
    }
}

function bc(e, t, r, n) {
    const a = ha(t, e, n, !0);
    Li(() => {
        wi(n[t], a)
    }, r)
}

function ha(e, t, r = tt, n = !1) {
    if (r) {
        const a = r[e] || (r[e] = []),
            i = t.__weh || (t.__weh = (...s) => {
                if (r.isUnmounted) return;
                ur();
                const o = _n(r),
                    l = Mt(t, r, e, s);
                return o(), cr(), l
            });
        return n ? a.unshift(i) : a.push(i), i
    }
}
const Bt = e => (t, r = tt) => (!ga || e === "sp") && ha(e, (...n) => t(...n), r),
    wc = Bt("bm"),
    ma = Bt("m"),
    _c = Bt("bu"),
    xc = Bt("u"),
    el = Bt("bum"),
    Li = Bt("um"),
    kc = Bt("sp"),
    Oc = Bt("rtg"),
    Tc = Bt("rtc");

function Cc(e, t = tt) {
    ha("ec", e, t)
}

function Cr(e, t, r, n) {
    let a;
    const i = r && r[n];
    if (ie(e) || Ze(e)) {
        a = new Array(e.length);
        for (let s = 0, o = e.length; s < o; s++) a[s] = t(e[s], s, void 0, i && i[s])
    } else if (typeof e == "number") {
        a = new Array(e);
        for (let s = 0; s < e; s++) a[s] = t(s + 1, s, void 0, i && i[s])
    } else if (Re(e))
        if (e[Symbol.iterator]) a = Array.from(e, (s, o) => t(s, o, void 0, i && i[o]));
        else {
            const s = Object.keys(e);
            a = new Array(s.length);
            for (let o = 0, l = s.length; o < l; o++) {
                const u = s[o];
                a[o] = t(e[u], u, o, i && i[o])
            }
        }
    else a = [];
    return r && (r[n] = a), a
}

function jr(e, t, r = {}, n, a) {
    if (Xe.isCE || Xe.parent && ln(Xe.parent) && Xe.parent.isCE) return t !== "default" && (r.name = t), ue("slot", r, n && n());
    let i = e[t];
    i && i._c && (i._d = !1), Y();
    const s = i && tl(i(r)),
        o = it(Ue, {
            key: r.key || s && s.key || `_${t}`
        }, s || (n ? n() : []), s && e._ === 1 ? 64 : -2);
    return !a && o.scopeId && (o.slotScopeIds = [o.scopeId + "-s"]), i && i._c && (i._d = !0), o
}

function tl(e) {
    return e.some(t => Wn(t) ? !(t.type === lr || t.type === Ue && !tl(t.children)) : !0) ? e : null
}
const Xa = e => e ? pl(e) ? ya(e) || e.proxy : Xa(e.parent) : null,
    un = rt(Object.create(null), {
        $: e => e,
        $el: e => e.vnode.el,
        $data: e => e.data,
        $props: e => e.props,
        $attrs: e => e.attrs,
        $slots: e => e.slots,
        $refs: e => e.refs,
        $parent: e => Xa(e.parent),
        $root: e => Xa(e.root),
        $emit: e => e.emit,
        $options: e => Ai(e),
        $forceUpdate: e => e.f || (e.f = () => {
            e.effect.dirty = !0, Pi(e.update)
        }),
        $nextTick: e => e.n || (e.n = pt.bind(e.proxy)),
        $watch: e => pc.bind(e)
    }),
    $a = (e, t) => e !== Ve && !e.__isScriptSetup && xe(e, t),
    Dc = {
        get({
            _: e
        }, t) {
            if (t === "__v_skip") return !0;
            const {
                ctx: r,
                setupState: n,
                data: a,
                props: i,
                accessCache: s,
                type: o,
                appContext: l
            } = e;
            let u;
            if (t[0] !== "$") {
                const g = s[t];
                if (g !== void 0) switch (g) {
                    case 1:
                        return n[t];
                    case 2:
                        return a[t];
                    case 4:
                        return r[t];
                    case 3:
                        return i[t]
                } else {
                    if ($a(n, t)) return s[t] = 1, n[t];
                    if (a !== Ve && xe(a, t)) return s[t] = 2, a[t];
                    if ((u = e.propsOptions[0]) && xe(u, t)) return s[t] = 3, i[t];
                    if (r !== Ve && xe(r, t)) return s[t] = 4, r[t];
                    Ja && (s[t] = 0)
                }
            }
            const c = un[t];
            let d, h;
            if (c) return t === "$attrs" && vt(e.attrs, "get", ""), c(e);
            if ((d = o.__cssModules) && (d = d[t])) return d;
            if (r !== Ve && xe(r, t)) return s[t] = 4, r[t];
            if (h = l.config.globalProperties, xe(h, t)) return h[t]
        },
        set({
            _: e
        }, t, r) {
            const {
                data: n,
                setupState: a,
                ctx: i
            } = e;
            return $a(a, t) ? (a[t] = r, !0) : n !== Ve && xe(n, t) ? (n[t] = r, !0) : xe(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (i[t] = r, !0)
        },
        has({
            _: {
                data: e,
                setupState: t,
                accessCache: r,
                ctx: n,
                appContext: a,
                propsOptions: i
            }
        }, s) {
            let o;
            return !!r[s] || e !== Ve && xe(e, s) || $a(t, s) || (o = i[0]) && xe(o, s) || xe(n, s) || xe(un, s) || xe(a.config.globalProperties, s)
        },
        defineProperty(e, t, r) {
            return r.get != null ? e._.accessCache[t] = 0 : xe(r, "value") && this.set(e, t, r.value, null), Reflect.defineProperty(e, t, r)
        }
    };

function fs(e) {
    return ie(e) ? e.reduce((t, r) => (t[r] = null, t), {}) : e
}
let Ja = !0;

function Sc(e) {
    const t = Ai(e),
        r = e.proxy,
        n = e.ctx;
    Ja = !1, t.beforeCreate && hs(t.beforeCreate, e, "bc");
    const {
        data: a,
        computed: i,
        methods: s,
        watch: o,
        provide: l,
        inject: u,
        created: c,
        beforeMount: d,
        mounted: h,
        beforeUpdate: g,
        updated: y,
        activated: k,
        deactivated: O,
        beforeDestroy: U,
        beforeUnmount: N,
        destroyed: L,
        unmounted: P,
        render: E,
        renderTracked: w,
        renderTriggered: G,
        errorCaptured: se,
        serverPrefetch: he,
        expose: de,
        inheritAttrs: le,
        components: Le,
        directives: Ne,
        filters: je
    } = t;
    if (u && Mc(u, n, null), s)
        for (const ne in s) {
            const ce = s[ne];
            oe(ce) && (n[ne] = ce.bind(r))
        }
    if (a) {
        const ne = a.call(r, r);
        Re(ne) && (e.data = Tr(ne))
    }
    if (Ja = !0, i)
        for (const ne in i) {
            const ce = i[ne],
                Qe = oe(ce) ? ce.bind(r, r) : oe(ce.get) ? ce.get.bind(r, r) : _t,
                bt = !oe(ce) && oe(ce.set) ? ce.set.bind(r) : _t,
                nt = z({
                    get: Qe,
                    set: bt
                });
            Object.defineProperty(n, ne, {
                enumerable: !0,
                configurable: !0,
                get: () => nt.value,
                set: Ke => nt.value = Ke
            })
        }
    if (o)
        for (const ne in o) rl(o[ne], n, r, ne);
    if (l) {
        const ne = oe(l) ? l.call(r) : l;
        Reflect.ownKeys(ne).forEach(ce => {
            Ni(ce, ne[ce])
        })
    }
    c && hs(c, e, "c");

    function V(ne, ce) {
        ie(ce) ? ce.forEach(Qe => ne(Qe.bind(r))) : ce && ne(ce.bind(r))
    }
    if (V(wc, d), V(ma, h), V(_c, g), V(xc, y), V(gc, k), V(yc, O), V(Cc, se), V(Tc, w), V(Oc, G), V(el, N), V(Li, P), V(kc, he), ie(de))
        if (de.length) {
            const ne = e.exposed || (e.exposed = {});
            de.forEach(ce => {
                Object.defineProperty(ne, ce, {
                    get: () => r[ce],
                    set: Qe => r[ce] = Qe
                })
            })
        } else e.exposed || (e.exposed = {});
    E && e.render === _t && (e.render = E), le != null && (e.inheritAttrs = le), Le && (e.components = Le), Ne && (e.directives = Ne)
}

function Mc(e, t, r = _t) {
    ie(e) && (e = ei(e));
    for (const n in e) {
        const a = e[n];
        let i;
        Re(a) ? "default" in a ? i = qr(a.from || n, a.default, !0) : i = qr(a.from || n) : i = qr(a), Ge(i) ? Object.defineProperty(t, n, {
            enumerable: !0,
            configurable: !0,
            get: () => i.value,
            set: s => i.value = s
        }) : t[n] = i
    }
}

function hs(e, t, r) {
    Mt(ie(e) ? e.map(n => n.bind(t.proxy)) : e.bind(t.proxy), t, r)
}

function rl(e, t, r, n) {
    const a = n.includes(".") ? Ko(r, n) : () => r[n];
    if (Ze(e)) {
        const i = t[e];
        oe(i) && xt(a, i)
    } else if (oe(e)) xt(a, e.bind(r));
    else if (Re(e))
        if (ie(e)) e.forEach(i => rl(i, t, r, n));
        else {
            const i = oe(e.handler) ? e.handler.bind(r) : t[e.handler];
            oe(i) && xt(a, i, e)
        }
}

function Ai(e) {
    const t = e.type,
        {
            mixins: r,
            extends: n
        } = t,
        {
            mixins: a,
            optionsCache: i,
            config: {
                optionMergeStrategies: s
            }
        } = e.appContext,
        o = i.get(t);
    let l;
    return o ? l = o : !a.length && !r && !n ? l = t : (l = {}, a.length && a.forEach(u => qn(l, u, s, !0)), qn(l, t, s)), Re(t) && i.set(t, l), l
}

function qn(e, t, r, n = !1) {
    const {
        mixins: a,
        extends: i
    } = t;
    i && qn(e, i, r, !0), a && a.forEach(s => qn(e, s, r, !0));
    for (const s in t)
        if (!(n && s === "expose")) {
            const o = Ec[s] || r && r[s];
            e[s] = o ? o(e[s], t[s]) : t[s]
        } return e
}
const Ec = {
    data: ms,
    props: vs,
    emits: vs,
    methods: nn,
    computed: nn,
    beforeCreate: lt,
    created: lt,
    beforeMount: lt,
    mounted: lt,
    beforeUpdate: lt,
    updated: lt,
    beforeDestroy: lt,
    beforeUnmount: lt,
    destroyed: lt,
    unmounted: lt,
    activated: lt,
    deactivated: lt,
    errorCaptured: lt,
    serverPrefetch: lt,
    components: nn,
    directives: nn,
    watch: $c,
    provide: ms,
    inject: Pc
};

function ms(e, t) {
    return t ? e ? function() {
        return rt(oe(e) ? e.call(this, this) : e, oe(t) ? t.call(this, this) : t)
    } : t : e
}

function Pc(e, t) {
    return nn(ei(e), ei(t))
}

function ei(e) {
    if (ie(e)) {
        const t = {};
        for (let r = 0; r < e.length; r++) t[e[r]] = e[r];
        return t
    }
    return e
}

function lt(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}

function nn(e, t) {
    return e ? rt(Object.create(null), e, t) : t
}

function vs(e, t) {
    return e ? ie(e) && ie(t) ? [...new Set([...e, ...t])] : rt(Object.create(null), fs(e), fs(t ?? {})) : t
}

function $c(e, t) {
    if (!e) return t;
    if (!t) return e;
    const r = rt(Object.create(null), e);
    for (const n in t) r[n] = lt(e[n], t[n]);
    return r
}

function nl() {
    return {
        app: null,
        config: {
            isNativeTag: hu,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let Fc = 0;

function Lc(e, t) {
    return function(n, a = null) {
        oe(n) || (n = rt({}, n)), a != null && !Re(a) && (a = null);
        const i = nl(),
            s = new WeakSet;
        let o = !1;
        const l = i.app = {
            _uid: Fc++,
            _component: n,
            _props: a,
            _container: null,
            _context: i,
            _instance: null,
            version: nd,
            get config() {
                return i.config
            },
            set config(u) {},
            use(u, ...c) {
                return s.has(u) || (u && oe(u.install) ? (s.add(u), u.install(l, ...c)) : oe(u) && (s.add(u), u(l, ...c))), l
            },
            mixin(u) {
                return i.mixins.includes(u) || i.mixins.push(u), l
            },
            component(u, c) {
                return c ? (i.components[u] = c, l) : i.components[u]
            },
            directive(u, c) {
                return c ? (i.directives[u] = c, l) : i.directives[u]
            },
            mount(u, c, d) {
                if (!o) {
                    const h = ue(n, a);
                    return h.appContext = i, d === !0 ? d = "svg" : d === !1 && (d = void 0), c && t ? t(h, u) : e(h, u, d), o = !0, l._container = u, u.__vue_app__ = l, ya(h.component) || h.component.proxy
                }
            },
            unmount() {
                o && (e(null, l._container), delete l._container.__vue_app__)
            },
            provide(u, c) {
                return i.provides[u] = c, l
            },
            runWithContext(u) {
                const c = cn;
                cn = l;
                try {
                    return u()
                } finally {
                    cn = c
                }
            }
        };
        return l
    }
}
let cn = null;

function Ni(e, t) {
    if (tt) {
        let r = tt.provides;
        const n = tt.parent && tt.parent.provides;
        n === r && (r = tt.provides = Object.create(n)), r[e] = t
    }
}

function qr(e, t, r = !1) {
    const n = tt || Xe;
    if (n || cn) {
        const a = n ? n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : cn._context.provides;
        if (a && e in a) return a[e];
        if (arguments.length > 1) return r && oe(t) ? t.call(n && n.proxy) : t
    }
}
const al = Object.create(null),
    ti = () => Object.create(al),
    il = e => Object.getPrototypeOf(e) === al;

function Ac(e, t, r, n = !1) {
    const a = {},
        i = ti();
    e.propsDefaults = Object.create(null), sl(e, t, a, i);
    for (const s in e.propsOptions[0]) s in a || (a[s] = void 0);
    r ? e.props = n ? a : zu(a) : e.type.props ? e.props = a : e.props = i, e.attrs = i
}

function Nc(e, t, r, n) {
    const {
        props: a,
        attrs: i,
        vnode: {
            patchFlag: s
        }
    } = e, o = Te(a), [l] = e.propsOptions;
    let u = !1;
    if ((n || s > 0) && !(s & 16)) {
        if (s & 8) {
            const c = e.vnode.dynamicProps;
            for (let d = 0; d < c.length; d++) {
                let h = c[d];
                if (ca(e.emitsOptions, h)) continue;
                const g = t[h];
                if (l)
                    if (xe(i, h)) g !== i[h] && (i[h] = g, u = !0);
                    else {
                        const y = Rt(h);
                        a[y] = ri(l, o, y, g, e, !1)
                    }
                else g !== i[h] && (i[h] = g, u = !0)
            }
        }
    } else {
        sl(e, t, a, i) && (u = !0);
        let c;
        for (const d in o)(!t || !xe(t, d) && ((c = Br(d)) === d || !xe(t, c))) && (l ? r && (r[d] !== void 0 || r[c] !== void 0) && (a[d] = ri(l, o, d, void 0, e, !0)) : delete a[d]);
        if (i !== o)
            for (const d in i)(!t || !xe(t, d)) && (delete i[d], u = !0)
    }
    u && Wt(e.attrs, "set", "")
}

function sl(e, t, r, n) {
    const [a, i] = e.propsOptions;
    let s = !1,
        o;
    if (t)
        for (let l in t) {
            if (sn(l)) continue;
            const u = t[l];
            let c;
            a && xe(a, c = Rt(l)) ? !i || !i.includes(c) ? r[c] = u : (o || (o = {}))[c] = u : ca(e.emitsOptions, l) || (!(l in n) || u !== n[l]) && (n[l] = u, s = !0)
        }
    if (i) {
        const l = Te(r),
            u = o || Ve;
        for (let c = 0; c < i.length; c++) {
            const d = i[c];
            r[d] = ri(a, l, d, u[d], e, !xe(u, d))
        }
    }
    return s
}

function ri(e, t, r, n, a, i) {
    const s = e[r];
    if (s != null) {
        const o = xe(s, "default");
        if (o && n === void 0) {
            const l = s.default;
            if (s.type !== Function && !s.skipFactory && oe(l)) {
                const {
                    propsDefaults: u
                } = a;
                if (r in u) n = u[r];
                else {
                    const c = _n(a);
                    n = u[r] = l.call(null, t), c()
                }
            } else n = l
        }
        s[0] && (i && !o ? n = !1 : s[1] && (n === "" || n === Br(r)) && (n = !0))
    }
    return n
}

function ol(e, t, r = !1) {
    const n = t.propsCache,
        a = n.get(e);
    if (a) return a;
    const i = e.props,
        s = {},
        o = [];
    let l = !1;
    if (!oe(e)) {
        const c = d => {
            l = !0;
            const [h, g] = ol(d, t, !0);
            rt(s, h), g && o.push(...g)
        };
        !r && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c)
    }
    if (!i && !l) return Re(e) && n.set(e, Rr), Rr;
    if (ie(i))
        for (let c = 0; c < i.length; c++) {
            const d = Rt(i[c]);
            ps(d) && (s[d] = Ve)
        } else if (i)
            for (const c in i) {
                const d = Rt(c);
                if (ps(d)) {
                    const h = i[c],
                        g = s[d] = ie(h) || oe(h) ? {
                            type: h
                        } : rt({}, h);
                    if (g) {
                        const y = bs(Boolean, g.type),
                            k = bs(String, g.type);
                        g[0] = y > -1, g[1] = k < 0 || y < k, (y > -1 || xe(g, "default")) && o.push(d)
                    }
                }
            }
    const u = [s, o];
    return Re(e) && n.set(e, u), u
}

function ps(e) {
    return e[0] !== "$" && !sn(e)
}

function gs(e) {
    return e === null ? "null" : typeof e == "function" ? e.name || "" : typeof e == "object" && e.constructor && e.constructor.name || ""
}

function ys(e, t) {
    return gs(e) === gs(t)
}

function bs(e, t) {
    return ie(t) ? t.findIndex(r => ys(r, e)) : oe(t) && ys(t, e) ? 0 : -1
}
const ll = e => e[0] === "_" || e === "$stable",
    ji = e => ie(e) ? e.map(Nt) : [Nt(e)],
    jc = (e, t, r) => {
        if (t._n) return t;
        const n = Ut((...a) => ji(t(...a)), r);
        return n._c = !1, n
    },
    ul = (e, t, r) => {
        const n = e._ctx;
        for (const a in e) {
            if (ll(a)) continue;
            const i = e[a];
            if (oe(i)) t[a] = jc(a, i, n);
            else if (i != null) {
                const s = ji(i);
                t[a] = () => s
            }
        }
    },
    cl = (e, t) => {
        const r = ji(t);
        e.slots.default = () => r
    },
    Ic = (e, t) => {
        if (e.vnode.shapeFlag & 32) {
            const r = t._;
            r ? (e.slots = Te(t), xo(e.slots, "_", r)) : ul(t, e.slots = ti())
        } else e.slots = ti(), t && cl(e, t)
    },
    Vc = (e, t, r) => {
        const {
            vnode: n,
            slots: a
        } = e;
        let i = !0,
            s = Ve;
        if (n.shapeFlag & 32) {
            const o = t._;
            o ? r && o === 1 ? i = !1 : (rt(a, t), !r && o === 1 && delete a._) : (i = !t.$stable, ul(t, a)), s = t
        } else t && (cl(e, t), s = {
            default: 1
        });
        if (i)
            for (const o in a) !ll(o) && s[o] == null && delete a[o]
    };

function ni(e, t, r, n, a = !1) {
    if (ie(e)) {
        e.forEach((h, g) => ni(h, t && (ie(t) ? t[g] : t), r, n, a));
        return
    }
    if (ln(n) && !a) return;
    const i = n.shapeFlag & 4 ? ya(n.component) || n.component.proxy : n.el,
        s = a ? null : i,
        {
            i: o,
            r: l
        } = e,
        u = t && t.r,
        c = o.refs === Ve ? o.refs = {} : o.refs,
        d = o.setupState;
    if (u != null && u !== l && (Ze(u) ? (c[u] = null, xe(d, u) && (d[u] = null)) : Ge(u) && (u.value = null)), oe(l)) ar(l, o, 12, [s, c]);
    else {
        const h = Ze(l),
            g = Ge(l);
        if (h || g) {
            const y = () => {
                if (e.f) {
                    const k = h ? xe(d, l) ? d[l] : c[l] : l.value;
                    a ? ie(k) && wi(k, i) : ie(k) ? k.includes(i) || k.push(i) : h ? (c[l] = [i], xe(d, l) && (d[l] = c[l])) : (l.value = [i], e.k && (c[e.k] = l.value))
                } else h ? (c[l] = s, xe(d, l) && (d[l] = s)) : g && (l.value = s, e.k && (c[e.k] = s))
            };
            s ? (y.id = -1, ft(y, r)) : y()
        }
    }
}
const ft = hc;

function Rc(e) {
    return Uc(e)
}

function Uc(e, t) {
    const r = ko();
    r.__VUE__ = !0;
    const {
        insert: n,
        remove: a,
        patchProp: i,
        createElement: s,
        createText: o,
        createComment: l,
        setText: u,
        setElementText: c,
        parentNode: d,
        nextSibling: h,
        setScopeId: g = _t,
        insertStaticContent: y
    } = e, k = (f, m, b, T = null, C = null, S = null, $ = void 0, M = null, F = !!m.dynamicChildren) => {
        if (f === m) return;
        f && !Kr(f, m) && (T = pe(f), Ke(f, C, S, !0), f = null), m.patchFlag === -2 && (F = !1, m.dynamicChildren = null);
        const {
            type: D,
            ref: I,
            shapeFlag: K
        } = m;
        switch (D) {
            case va:
                O(f, m, b, T);
                break;
            case lr:
                U(f, m, b, T);
                break;
            case La:
                f == null && N(m, b, T, $);
                break;
            case Ue:
                Le(f, m, b, T, C, S, $, M, F);
                break;
            default:
                K & 1 ? E(f, m, b, T, C, S, $, M, F) : K & 6 ? Ne(f, m, b, T, C, S, $, M, F) : (K & 64 || K & 128) && D.process(f, m, b, T, C, S, $, M, F, Me)
        }
        I != null && C && ni(I, f && f.ref, S, m || f, !m)
    }, O = (f, m, b, T) => {
        if (f == null) n(m.el = o(m.children), b, T);
        else {
            const C = m.el = f.el;
            m.children !== f.children && u(C, m.children)
        }
    }, U = (f, m, b, T) => {
        f == null ? n(m.el = l(m.children || ""), b, T) : m.el = f.el
    }, N = (f, m, b, T) => {
        [f.el, f.anchor] = y(f.children, m, b, T, f.el, f.anchor)
    }, L = ({
        el: f,
        anchor: m
    }, b, T) => {
        let C;
        for (; f && f !== m;) C = h(f), n(f, b, T), f = C;
        n(m, b, T)
    }, P = ({
        el: f,
        anchor: m
    }) => {
        let b;
        for (; f && f !== m;) b = h(f), a(f), f = b;
        a(m)
    }, E = (f, m, b, T, C, S, $, M, F) => {
        m.type === "svg" ? $ = "svg" : m.type === "math" && ($ = "mathml"), f == null ? w(m, b, T, C, S, $, M, F) : he(f, m, C, S, $, M, F)
    }, w = (f, m, b, T, C, S, $, M) => {
        let F, D;
        const {
            props: I,
            shapeFlag: K,
            transition: B,
            dirs: ae
        } = f;
        if (F = f.el = s(f.type, S, I && I.is, I), K & 8 ? c(F, f.children) : K & 16 && se(f.children, F, null, T, C, Fa(f, S), $, M), ae && dr(f, null, T, "created"), G(F, f, f.scopeId, $, T), I) {
            for (const Ee in I) Ee !== "value" && !sn(Ee) && i(F, Ee, null, I[Ee], S, f.children, T, C, X);
            "value" in I && i(F, "value", null, I.value, S), (D = I.onVnodeBeforeMount) && Ft(D, T, f)
        }
        ae && dr(f, null, T, "beforeMount");
        const me = Yc(C, B);
        me && B.beforeEnter(F), n(F, m, b), ((D = I && I.onVnodeMounted) || me || ae) && ft(() => {
            D && Ft(D, T, f), me && B.enter(F), ae && dr(f, null, T, "mounted")
        }, C)
    }, G = (f, m, b, T, C) => {
        if (b && g(f, b), T)
            for (let S = 0; S < T.length; S++) g(f, T[S]);
        if (C) {
            let S = C.subTree;
            if (m === S) {
                const $ = C.vnode;
                G(f, $, $.scopeId, $.slotScopeIds, C.parent)
            }
        }
    }, se = (f, m, b, T, C, S, $, M, F = 0) => {
        for (let D = F; D < f.length; D++) {
            const I = f[D] = M ? er(f[D]) : Nt(f[D]);
            k(null, I, m, b, T, C, S, $, M)
        }
    }, he = (f, m, b, T, C, S, $) => {
        const M = m.el = f.el;
        let {
            patchFlag: F,
            dynamicChildren: D,
            dirs: I
        } = m;
        F |= f.patchFlag & 16;
        const K = f.props || Ve,
            B = m.props || Ve;
        let ae;
        if (b && fr(b, !1), (ae = B.onVnodeBeforeUpdate) && Ft(ae, b, m, f), I && dr(m, f, b, "beforeUpdate"), b && fr(b, !0), D ? de(f.dynamicChildren, D, M, b, T, Fa(m, C), S) : $ || ce(f, m, M, null, b, T, Fa(m, C), S, !1), F > 0) {
            if (F & 16) le(M, m, K, B, b, T, C);
            else if (F & 2 && K.class !== B.class && i(M, "class", null, B.class, C), F & 4 && i(M, "style", K.style, B.style, C), F & 8) {
                const me = m.dynamicProps;
                for (let Ee = 0; Ee < me.length; Ee++) {
                    const v = me[Ee],
                        p = K[v],
                        x = B[v];
                    (x !== p || v === "value") && i(M, v, p, x, C, f.children, b, T, X)
                }
            }
            F & 1 && f.children !== m.children && c(M, m.children)
        } else !$ && D == null && le(M, m, K, B, b, T, C);
        ((ae = B.onVnodeUpdated) || I) && ft(() => {
            ae && Ft(ae, b, m, f), I && dr(m, f, b, "updated")
        }, T)
    }, de = (f, m, b, T, C, S, $) => {
        for (let M = 0; M < m.length; M++) {
            const F = f[M],
                D = m[M],
                I = F.el && (F.type === Ue || !Kr(F, D) || F.shapeFlag & 70) ? d(F.el) : b;
            k(F, D, I, null, T, C, S, $, !0)
        }
    }, le = (f, m, b, T, C, S, $) => {
        if (b !== T) {
            if (b !== Ve)
                for (const M in b) !sn(M) && !(M in T) && i(f, M, b[M], null, $, m.children, C, S, X);
            for (const M in T) {
                if (sn(M)) continue;
                const F = T[M],
                    D = b[M];
                F !== D && M !== "value" && i(f, M, D, F, $, m.children, C, S, X)
            }
            "value" in T && i(f, "value", b.value, T.value, $)
        }
    }, Le = (f, m, b, T, C, S, $, M, F) => {
        const D = m.el = f ? f.el : o(""),
            I = m.anchor = f ? f.anchor : o("");
        let {
            patchFlag: K,
            dynamicChildren: B,
            slotScopeIds: ae
        } = m;
        ae && (M = M ? M.concat(ae) : ae), f == null ? (n(D, b, T), n(I, b, T), se(m.children || [], b, I, C, S, $, M, F)) : K > 0 && K & 64 && B && f.dynamicChildren ? (de(f.dynamicChildren, B, b, C, S, $, M), (m.key != null || C && m === C.subTree) && dl(f, m, !0)) : ce(f, m, b, I, C, S, $, M, F)
    }, Ne = (f, m, b, T, C, S, $, M, F) => {
        m.slotScopeIds = M, f == null ? m.shapeFlag & 512 ? C.ctx.activate(m, b, T, $, F) : je(m, b, T, C, S, $, F) : we(f, m, F)
    }, je = (f, m, b, T, C, S, $) => {
        const M = f.component = Qc(f, T, C);
        if (Xo(f) && (M.ctx.renderer = Me), Kc(M), M.asyncDep) {
            if (C && C.registerDep(M, V), !f.el) {
                const F = M.subTree = ue(lr);
                U(null, F, m, b)
            }
        } else V(M, f, m, b, C, S, $)
    }, we = (f, m, b) => {
        const T = m.component = f.component;
        if (cc(f, m, b))
            if (T.asyncDep && !T.asyncResolved) {
                ne(T, m, b);
                return
            } else T.next = m, ac(T.update), T.effect.dirty = !0, T.update();
        else m.el = f.el, T.vnode = m
    }, V = (f, m, b, T, C, S, $) => {
        const M = () => {
                if (f.isMounted) {
                    let {
                        next: I,
                        bu: K,
                        u: B,
                        parent: ae,
                        vnode: me
                    } = f;
                    {
                        const A = fl(f);
                        if (A) {
                            I && (I.el = me.el, ne(f, I, $)), A.asyncDep.then(() => {
                                f.isUnmounted || M()
                            });
                            return
                        }
                    }
                    let Ee = I,
                        v;
                    fr(f, !1), I ? (I.el = me.el, ne(f, I, $)) : I = me, K && Ln(K), (v = I.props && I.props.onVnodeBeforeUpdate) && Ft(v, ae, I, me), fr(f, !0);
                    const p = Pa(f),
                        x = f.subTree;
                    f.subTree = p, k(x, p, d(x.el), pe(x), f, C, S), I.el = p.el, Ee === null && dc(f, p.el), B && ft(B, C), (v = I.props && I.props.onVnodeUpdated) && ft(() => Ft(v, ae, I, me), C)
                } else {
                    let I;
                    const {
                        el: K,
                        props: B
                    } = m, {
                        bm: ae,
                        m: me,
                        parent: Ee
                    } = f, v = ln(m);
                    if (fr(f, !1), ae && Ln(ae), !v && (I = B && B.onVnodeBeforeMount) && Ft(I, Ee, m), fr(f, !0), K && Zt) {
                        const p = () => {
                            f.subTree = Pa(f), Zt(K, f.subTree, f, C, null)
                        };
                        v ? m.type.__asyncLoader().then(() => !f.isUnmounted && p()) : p()
                    } else {
                        const p = f.subTree = Pa(f);
                        k(null, p, b, T, f, C, S), m.el = p.el
                    }
                    if (me && ft(me, C), !v && (I = B && B.onVnodeMounted)) {
                        const p = m;
                        ft(() => Ft(I, Ee, p), C)
                    }(m.shapeFlag & 256 || Ee && ln(Ee.vnode) && Ee.vnode.shapeFlag & 256) && f.a && ft(f.a, C), f.isMounted = !0, m = b = T = null
                }
            },
            F = f.effect = new xi(M, _t, () => Pi(D), f.scope),
            D = f.update = () => {
                F.dirty && F.run()
            };
        D.id = f.uid, fr(f, !0), D()
    }, ne = (f, m, b) => {
        m.component = f;
        const T = f.vnode.props;
        f.vnode = m, f.next = null, Nc(f, m.props, T, b), Vc(f, m.children, b), ur(), us(f), cr()
    }, ce = (f, m, b, T, C, S, $, M, F = !1) => {
        const D = f && f.children,
            I = f ? f.shapeFlag : 0,
            K = m.children,
            {
                patchFlag: B,
                shapeFlag: ae
            } = m;
        if (B > 0) {
            if (B & 128) {
                bt(D, K, b, T, C, S, $, M, F);
                return
            } else if (B & 256) {
                Qe(D, K, b, T, C, S, $, M, F);
                return
            }
        }
        ae & 8 ? (I & 16 && X(D, C, S), K !== D && c(b, K)) : I & 16 ? ae & 16 ? bt(D, K, b, T, C, S, $, M, F) : X(D, C, S, !0) : (I & 8 && c(b, ""), ae & 16 && se(K, b, T, C, S, $, M, F))
    }, Qe = (f, m, b, T, C, S, $, M, F) => {
        f = f || Rr, m = m || Rr;
        const D = f.length,
            I = m.length,
            K = Math.min(D, I);
        let B;
        for (B = 0; B < K; B++) {
            const ae = m[B] = F ? er(m[B]) : Nt(m[B]);
            k(f[B], ae, b, null, C, S, $, M, F)
        }
        D > I ? X(f, C, S, !0, !1, K) : se(m, b, T, C, S, $, M, F, K)
    }, bt = (f, m, b, T, C, S, $, M, F) => {
        let D = 0;
        const I = m.length;
        let K = f.length - 1,
            B = I - 1;
        for (; D <= K && D <= B;) {
            const ae = f[D],
                me = m[D] = F ? er(m[D]) : Nt(m[D]);
            if (Kr(ae, me)) k(ae, me, b, null, C, S, $, M, F);
            else break;
            D++
        }
        for (; D <= K && D <= B;) {
            const ae = f[K],
                me = m[B] = F ? er(m[B]) : Nt(m[B]);
            if (Kr(ae, me)) k(ae, me, b, null, C, S, $, M, F);
            else break;
            K--, B--
        }
        if (D > K) {
            if (D <= B) {
                const ae = B + 1,
                    me = ae < I ? m[ae].el : T;
                for (; D <= B;) k(null, m[D] = F ? er(m[D]) : Nt(m[D]), b, me, C, S, $, M, F), D++
            }
        } else if (D > B)
            for (; D <= K;) Ke(f[D], C, S, !0), D++;
        else {
            const ae = D,
                me = D,
                Ee = new Map;
            for (D = me; D <= B; D++) {
                const _e = m[D] = F ? er(m[D]) : Nt(m[D]);
                _e.key != null && Ee.set(_e.key, D)
            }
            let v, p = 0;
            const x = B - me + 1;
            let A = !1,
                J = 0;
            const H = new Array(x);
            for (D = 0; D < x; D++) H[D] = 0;
            for (D = ae; D <= K; D++) {
                const _e = f[D];
                if (p >= x) {
                    Ke(_e, C, S, !0);
                    continue
                }
                let Ce;
                if (_e.key != null) Ce = Ee.get(_e.key);
                else
                    for (v = me; v <= B; v++)
                        if (H[v - me] === 0 && Kr(_e, m[v])) {
                            Ce = v;
                            break
                        } Ce === void 0 ? Ke(_e, C, S, !0) : (H[Ce - me] = D + 1, Ce >= J ? J = Ce : A = !0, k(_e, m[Ce], b, null, C, S, $, M, F), p++)
            }
            const ge = A ? qc(H) : Rr;
            for (v = ge.length - 1, D = x - 1; D >= 0; D--) {
                const _e = me + D,
                    Ce = m[_e],
                    Je = _e + 1 < I ? m[_e + 1].el : T;
                H[D] === 0 ? k(null, Ce, b, Je, C, S, $, M, F) : A && (v < 0 || D !== ge[v] ? nt(Ce, b, Je, 2) : v--)
            }
        }
    }, nt = (f, m, b, T, C = null) => {
        const {
            el: S,
            type: $,
            transition: M,
            children: F,
            shapeFlag: D
        } = f;
        if (D & 6) {
            nt(f.component.subTree, m, b, T);
            return
        }
        if (D & 128) {
            f.suspense.move(m, b, T);
            return
        }
        if (D & 64) {
            $.move(f, m, b, Me);
            return
        }
        if ($ === Ue) {
            n(S, m, b);
            for (let K = 0; K < F.length; K++) nt(F[K], m, b, T);
            n(f.anchor, m, b);
            return
        }
        if ($ === La) {
            L(f, m, b);
            return
        }
        if (T !== 2 && D & 1 && M)
            if (T === 0) M.beforeEnter(S), n(S, m, b), ft(() => M.enter(S), C);
            else {
                const {
                    leave: K,
                    delayLeave: B,
                    afterLeave: ae
                } = M, me = () => n(S, m, b), Ee = () => {
                    K(S, () => {
                        me(), ae && ae()
                    })
                };
                B ? B(S, me, Ee) : Ee()
            }
        else n(S, m, b)
    }, Ke = (f, m, b, T = !1, C = !1) => {
        const {
            type: S,
            props: $,
            ref: M,
            children: F,
            dynamicChildren: D,
            shapeFlag: I,
            patchFlag: K,
            dirs: B
        } = f;
        if (M != null && ni(M, null, b, f, !0), I & 256) {
            m.ctx.deactivate(f);
            return
        }
        const ae = I & 1 && B,
            me = !ln(f);
        let Ee;
        if (me && (Ee = $ && $.onVnodeBeforeUnmount) && Ft(Ee, m, f), I & 6) W(f.component, b, T);
        else {
            if (I & 128) {
                f.suspense.unmount(b, T);
                return
            }
            ae && dr(f, null, m, "beforeUnmount"), I & 64 ? f.type.remove(f, m, b, C, Me, T) : D && (S !== Ue || K > 0 && K & 64) ? X(D, m, b, !1, !0) : (S === Ue && K & 384 || !C && I & 16) && X(F, m, b), T && We(f)
        }(me && (Ee = $ && $.onVnodeUnmounted) || ae) && ft(() => {
            Ee && Ft(Ee, m, f), ae && dr(f, null, m, "unmounted")
        }, b)
    }, We = f => {
        const {
            type: m,
            el: b,
            anchor: T,
            transition: C
        } = f;
        if (m === Ue) {
            $t(b, T);
            return
        }
        if (m === La) {
            P(f);
            return
        }
        const S = () => {
            a(b), C && !C.persisted && C.afterLeave && C.afterLeave()
        };
        if (f.shapeFlag & 1 && C && !C.persisted) {
            const {
                leave: $,
                delayLeave: M
            } = C, F = () => $(b, S);
            M ? M(f.el, S, F) : F()
        } else S()
    }, $t = (f, m) => {
        let b;
        for (; f !== m;) b = h(f), a(f), f = b;
        a(m)
    }, W = (f, m, b) => {
        const {
            bum: T,
            scope: C,
            update: S,
            subTree: $,
            um: M
        } = f;
        T && Ln(T), C.stop(), S && (S.active = !1, Ke($, f, m, b)), M && ft(M, m), ft(() => {
            f.isUnmounted = !0
        }, m), m && m.pendingBranch && !m.isUnmounted && f.asyncDep && !f.asyncResolved && f.suspenseId === m.pendingId && (m.deps--, m.deps === 0 && m.resolve())
    }, X = (f, m, b, T = !1, C = !1, S = 0) => {
        for (let $ = S; $ < f.length; $++) Ke(f[$], m, b, T, C)
    }, pe = f => f.shapeFlag & 6 ? pe(f.component.subTree) : f.shapeFlag & 128 ? f.suspense.next() : h(f.anchor || f.el);
    let ee = !1;
    const fe = (f, m, b) => {
            f == null ? m._vnode && Ke(m._vnode, null, null, !0) : k(m._vnode || null, f, m, null, null, null, b), ee || (ee = !0, us(), Wo(), ee = !1), m._vnode = f
        },
        Me = {
            p: k,
            um: Ke,
            m: nt,
            r: We,
            mt: je,
            mc: se,
            pc: ce,
            pbc: de,
            n: pe,
            o: e
        };
    let He, Zt;
    return t && ([He, Zt] = t(Me)), {
        render: fe,
        hydrate: He,
        createApp: Lc(fe, He)
    }
}

function Fa({
    type: e,
    props: t
}, r) {
    return r === "svg" && e === "foreignObject" || r === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : r
}

function fr({
    effect: e,
    update: t
}, r) {
    e.allowRecurse = t.allowRecurse = r
}

function Yc(e, t) {
    return (!e || e && !e.pendingBranch) && t && !t.persisted
}

function dl(e, t, r = !1) {
    const n = e.children,
        a = t.children;
    if (ie(n) && ie(a))
        for (let i = 0; i < n.length; i++) {
            const s = n[i];
            let o = a[i];
            o.shapeFlag & 1 && !o.dynamicChildren && ((o.patchFlag <= 0 || o.patchFlag === 32) && (o = a[i] = er(a[i]), o.el = s.el), r || dl(s, o)), o.type === va && (o.el = s.el)
        }
}

function qc(e) {
    const t = e.slice(),
        r = [0];
    let n, a, i, s, o;
    const l = e.length;
    for (n = 0; n < l; n++) {
        const u = e[n];
        if (u !== 0) {
            if (a = r[r.length - 1], e[a] < u) {
                t[n] = a, r.push(n);
                continue
            }
            for (i = 0, s = r.length - 1; i < s;) o = i + s >> 1, e[r[o]] < u ? i = o + 1 : s = o;
            u < e[r[i]] && (i > 0 && (t[n] = r[i - 1]), r[i] = n)
        }
    }
    for (i = r.length, s = r[i - 1]; i-- > 0;) r[i] = s, s = t[s];
    return r
}

function fl(e) {
    const t = e.subTree.component;
    if (t) return t.asyncDep && !t.asyncResolved ? t : fl(t)
}
const Wc = e => e.__isTeleport,
    Ue = Symbol.for("v-fgt"),
    va = Symbol.for("v-txt"),
    lr = Symbol.for("v-cmt"),
    La = Symbol.for("v-stc"),
    dn = [];
let Dt = null;

function Y(e = !1) {
    dn.push(Dt = e ? null : [])
}

function Hc() {
    dn.pop(), Dt = dn[dn.length - 1] || null
}
let pn = 1;

function ws(e) {
    pn += e
}

function hl(e) {
    return e.dynamicChildren = pn > 0 ? Dt || Rr : null, Hc(), pn > 0 && Dt && Dt.push(e), e
}

function te(e, t, r, n, a, i) {
    return hl(_(e, t, r, n, a, i, !0))
}

function it(e, t, r, n, a) {
    return hl(ue(e, t, r, n, a, !0))
}

function Wn(e) {
    return e ? e.__v_isVNode === !0 : !1
}

function Kr(e, t) {
    return e.type === t.type && e.key === t.key
}
const ml = ({
        key: e
    }) => e ?? null,
    jn = ({
        ref: e,
        ref_key: t,
        ref_for: r
    }) => (typeof e == "number" && (e = "" + e), e != null ? Ze(e) || Ge(e) || oe(e) ? {
        i: Xe,
        r: e,
        k: t,
        f: !!r
    } : e : null);

function _(e, t = null, r = null, n = 0, a = null, i = e === Ue ? 0 : 1, s = !1, o = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && ml(t),
        ref: t && jn(t),
        scopeId: da,
        slotScopeIds: null,
        children: r,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: i,
        patchFlag: n,
        dynamicProps: a,
        dynamicChildren: null,
        appContext: null,
        ctx: Xe
    };
    return o ? (Ii(l, r), i & 128 && e.normalize(l)) : r && (l.shapeFlag |= Ze(r) ? 8 : 16), pn > 0 && !s && Dt && (l.patchFlag > 0 || i & 6) && l.patchFlag !== 32 && Dt.push(l), l
}
const ue = Bc;

function Bc(e, t = null, r = null, n = 0, a = null, i = !1) {
    if ((!e || e === Go) && (e = lr), Wn(e)) {
        const o = Wr(e, t, !0);
        return r && Ii(o, r), pn > 0 && !i && Dt && (o.shapeFlag & 6 ? Dt[Dt.indexOf(e)] = o : Dt.push(o)), o.patchFlag |= -2, o
    }
    if (rd(e) && (e = e.__vccOpts), t) {
        t = zc(t);
        let {
            class: o,
            style: l
        } = t;
        o && !Ze(o) && (t.class = or(o)), Re(l) && (jo(l) && !ie(l) && (l = rt({}, l)), t.style = zr(l))
    }
    const s = Ze(e) ? 1 : fc(e) ? 128 : Wc(e) ? 64 : Re(e) ? 4 : oe(e) ? 2 : 0;
    return _(e, t, r, n, a, s, i, !0)
}

function zc(e) {
    return e ? jo(e) || il(e) ? rt({}, e) : e : null
}

function Wr(e, t, r = !1) {
    const {
        props: n,
        ref: a,
        patchFlag: i,
        children: s
    } = e, o = t ? vl(n || {}, t) : n;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: o,
        key: o && ml(o),
        ref: t && t.ref ? r && a ? ie(a) ? a.concat(jn(t)) : [a, jn(t)] : jn(t) : a,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: s,
        target: e.target,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== Ue ? i === -1 ? 16 : i | 16 : i,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: e.transition,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && Wr(e.ssContent),
        ssFallback: e.ssFallback && Wr(e.ssFallback),
        el: e.el,
        anchor: e.anchor,
        ctx: e.ctx,
        ce: e.ce
    }
}

function Pr(e = " ", t = 0) {
    return ue(va, null, e, t)
}

function et(e = "", t = !1) {
    return t ? (Y(), it(lr, null, e)) : ue(lr, null, e)
}

function Nt(e) {
    return e == null || typeof e == "boolean" ? ue(lr) : ie(e) ? ue(Ue, null, e.slice()) : typeof e == "object" ? er(e) : ue(va, null, String(e))
}

function er(e) {
    return e.el === null && e.patchFlag !== -1 || e.memo ? e : Wr(e)
}

function Ii(e, t) {
    let r = 0;
    const {
        shapeFlag: n
    } = e;
    if (t == null) t = null;
    else if (ie(t)) r = 16;
    else if (typeof t == "object")
        if (n & 65) {
            const a = t.default;
            a && (a._c && (a._d = !1), Ii(e, a()), a._c && (a._d = !0));
            return
        } else {
            r = 32;
            const a = t._;
            !a && !il(t) ? t._ctx = Xe : a === 3 && Xe && (Xe.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024))
        }
    else oe(t) ? (t = {
        default: t,
        _ctx: Xe
    }, r = 32) : (t = String(t), n & 64 ? (r = 16, t = [Pr(t)]) : r = 8);
    e.children = t, e.shapeFlag |= r
}

function vl(...e) {
    const t = {};
    for (let r = 0; r < e.length; r++) {
        const n = e[r];
        for (const a in n)
            if (a === "class") t.class !== n.class && (t.class = or([t.class, n.class]));
            else if (a === "style") t.style = zr([t.style, n.style]);
        else if (aa(a)) {
            const i = t[a],
                s = n[a];
            s && i !== s && !(ie(i) && i.includes(s)) && (t[a] = i ? [].concat(i, s) : s)
        } else a !== "" && (t[a] = n[a])
    }
    return t
}

function Ft(e, t, r, n = null) {
    Mt(e, t, 7, [r, n])
}
const Zc = nl();
let Gc = 0;

function Qc(e, t, r) {
    const n = e.type,
        a = (t ? t.appContext : e.appContext) || Zc,
        i = {
            uid: Gc++,
            vnode: e,
            type: n,
            parent: t,
            appContext: a,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new Ou(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: t ? t.provides : Object.create(a.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: ol(n, a),
            emitsOptions: Bo(n, a),
            emit: null,
            emitted: null,
            propsDefaults: Ve,
            inheritAttrs: n.inheritAttrs,
            ctx: Ve,
            data: Ve,
            props: Ve,
            attrs: Ve,
            slots: Ve,
            refs: Ve,
            setupState: Ve,
            setupContext: null,
            attrsProxy: null,
            slotsProxy: null,
            suspense: r,
            suspenseId: r ? r.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return i.ctx = {
        _: i
    }, i.root = t ? t.root : i, i.emit = oc.bind(null, i), e.ce && e.ce(i), i
}
let tt = null;
const pa = () => tt || Xe;
let Hn, ai;
{
    const e = ko(),
        t = (r, n) => {
            let a;
            return (a = e[r]) || (a = e[r] = []), a.push(n), i => {
                a.length > 1 ? a.forEach(s => s(i)) : a[0](i)
            }
        };
    Hn = t("__VUE_INSTANCE_SETTERS__", r => tt = r), ai = t("__VUE_SSR_SETTERS__", r => ga = r)
}
const _n = e => {
        const t = tt;
        return Hn(e), e.scope.on(), () => {
            e.scope.off(), Hn(t)
        }
    },
    _s = () => {
        tt && tt.scope.off(), Hn(null)
    };

function pl(e) {
    return e.vnode.shapeFlag & 4
}
let ga = !1;

function Kc(e, t = !1) {
    t && ai(t);
    const {
        props: r,
        children: n
    } = e.vnode, a = pl(e);
    Ac(e, r, a, t), Ic(e, n);
    const i = a ? Xc(e, t) : void 0;
    return t && ai(!1), i
}

function Xc(e, t) {
    const r = e.type;
    e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Dc);
    const {
        setup: n
    } = r;
    if (n) {
        const a = e.setupContext = n.length > 1 ? ed(e) : null,
            i = _n(e);
        ur();
        const s = ar(n, e, 0, [e.props, a]);
        if (cr(), i(), bo(s)) {
            if (s.then(_s, _s), t) return s.then(o => {
                xs(e, o, t)
            }).catch(o => {
                ua(o, e, 0)
            });
            e.asyncDep = s
        } else xs(e, s, t)
    } else gl(e, t)
}

function xs(e, t, r) {
    oe(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : Re(t) && (e.setupState = Uo(t)), gl(e, r)
}
let ks;

function gl(e, t, r) {
    const n = e.type;
    if (!e.render) {
        if (!t && ks && !n.render) {
            const a = n.template || Ai(e).template;
            if (a) {
                const {
                    isCustomElement: i,
                    compilerOptions: s
                } = e.appContext.config, {
                    delimiters: o,
                    compilerOptions: l
                } = n, u = rt(rt({
                    isCustomElement: i,
                    delimiters: o
                }, s), l);
                n.render = ks(a, u)
            }
        }
        e.render = n.render || _t
    } {
        const a = _n(e);
        ur();
        try {
            Sc(e)
        } finally {
            cr(), a()
        }
    }
}
const Jc = {
    get(e, t) {
        return vt(e, "get", ""), e[t]
    }
};

function ed(e) {
    const t = r => {
        e.exposed = r || {}
    };
    return {
        attrs: new Proxy(e.attrs, Jc),
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}

function ya(e) {
    if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(Uo(Zu(e.exposed)), {
        get(t, r) {
            if (r in t) return t[r];
            if (r in un) return un[r](e)
        },
        has(t, r) {
            return r in t || r in un
        }
    }))
}

function td(e, t = !0) {
    return oe(e) ? e.displayName || e.name : e.name || t && e.__name
}

function rd(e) {
    return oe(e) && "__vccOpts" in e
}
const z = (e, t) => Gu(e, t, ga);

function Bn(e, t, r) {
    const n = arguments.length;
    return n === 2 ? Re(t) && !ie(t) ? Wn(t) ? ue(e, null, [t]) : ue(e, t) : ue(e, null, t) : (n > 3 ? r = Array.prototype.slice.call(arguments, 2) : n === 3 && Wn(r) && (r = [r]), ue(e, t, r))
}
const nd = "3.4.23";
/**
 * @vue/runtime-dom v3.4.23
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const ad = "http://www.w3.org/2000/svg",
    id = "http://www.w3.org/1998/Math/MathML",
    tr = typeof document < "u" ? document : null,
    Os = tr && tr.createElement("template"),
    sd = {
        insert: (e, t, r) => {
            t.insertBefore(e, r || null)
        },
        remove: e => {
            const t = e.parentNode;
            t && t.removeChild(e)
        },
        createElement: (e, t, r, n) => {
            const a = t === "svg" ? tr.createElementNS(ad, e) : t === "mathml" ? tr.createElementNS(id, e) : tr.createElement(e, r ? {
                is: r
            } : void 0);
            return e === "select" && n && n.multiple != null && a.setAttribute("multiple", n.multiple), a
        },
        createText: e => tr.createTextNode(e),
        createComment: e => tr.createComment(e),
        setText: (e, t) => {
            e.nodeValue = t
        },
        setElementText: (e, t) => {
            e.textContent = t
        },
        parentNode: e => e.parentNode,
        nextSibling: e => e.nextSibling,
        querySelector: e => tr.querySelector(e),
        setScopeId(e, t) {
            e.setAttribute(t, "")
        },
        insertStaticContent(e, t, r, n, a, i) {
            const s = r ? r.previousSibling : t.lastChild;
            if (a && (a === i || a.nextSibling))
                for (; t.insertBefore(a.cloneNode(!0), r), !(a === i || !(a = a.nextSibling)););
            else {
                Os.innerHTML = n === "svg" ? `<svg>${e}</svg>` : n === "mathml" ? `<math>${e}</math>` : e;
                const o = Os.content;
                if (n === "svg" || n === "mathml") {
                    const l = o.firstChild;
                    for (; l.firstChild;) o.appendChild(l.firstChild);
                    o.removeChild(l)
                }
                t.insertBefore(o, r)
            }
            return [s ? s.nextSibling : t.firstChild, r ? r.previousSibling : t.lastChild]
        }
    },
    od = Symbol("_vtc");

function ld(e, t, r) {
    const n = e[od];
    n && (t = (t ? [t, ...n] : [...n]).join(" ")), t == null ? e.removeAttribute("class") : r ? e.setAttribute("class", t) : e.className = t
}
const zn = Symbol("_vod"),
    yl = Symbol("_vsh"),
    qt = {
        beforeMount(e, {
            value: t
        }, {
            transition: r
        }) {
            e[zn] = e.style.display === "none" ? "" : e.style.display, r && t ? r.beforeEnter(e) : Xr(e, t)
        },
        mounted(e, {
            value: t
        }, {
            transition: r
        }) {
            r && t && r.enter(e)
        },
        updated(e, {
            value: t,
            oldValue: r
        }, {
            transition: n
        }) {
            !t != !r && (n ? t ? (n.beforeEnter(e), Xr(e, !0), n.enter(e)) : n.leave(e, () => {
                Xr(e, !1)
            }) : Xr(e, t))
        },
        beforeUnmount(e, {
            value: t
        }) {
            Xr(e, t)
        }
    };

function Xr(e, t) {
    e.style.display = t ? e[zn] : "none", e[yl] = !t
}
const ud = Symbol(""),
    cd = /(^|;)\s*display\s*:/;

function dd(e, t, r) {
    const n = e.style,
        a = Ze(r);
    let i = !1;
    if (r && !a) {
        if (t)
            if (Ze(t))
                for (const s of t.split(";")) {
                    const o = s.slice(0, s.indexOf(":")).trim();
                    r[o] == null && In(n, o, "")
                } else
                    for (const s in t) r[s] == null && In(n, s, "");
        for (const s in r) s === "display" && (i = !0), In(n, s, r[s])
    } else if (a) {
        if (t !== r) {
            const s = n[ud];
            s && (r += ";" + s), n.cssText = r, i = cd.test(r)
        }
    } else t && e.removeAttribute("style");
    zn in e && (e[zn] = i ? n.display : "", e[yl] && (n.display = "none"))
}
const Ts = /\s*!important$/;

function In(e, t, r) {
    if (ie(r)) r.forEach(n => In(e, t, n));
    else if (r == null && (r = ""), t.startsWith("--")) e.setProperty(t, r);
    else {
        const n = fd(e, t);
        Ts.test(r) ? e.setProperty(Br(n), r.replace(Ts, ""), "important") : e[n] = r
    }
}
const Cs = ["Webkit", "Moz", "ms"],
    Aa = {};

function fd(e, t) {
    const r = Aa[t];
    if (r) return r;
    let n = Rt(t);
    if (n !== "filter" && n in e) return Aa[t] = n;
    n = oa(n);
    for (let a = 0; a < Cs.length; a++) {
        const i = Cs[a] + n;
        if (i in e) return Aa[t] = i
    }
    return t
}
const Ds = "http://www.w3.org/1999/xlink";

function hd(e, t, r, n, a) {
    if (n && t.startsWith("xlink:")) r == null ? e.removeAttributeNS(Ds, t.slice(6, t.length)) : e.setAttributeNS(Ds, t, r);
    else {
        const i = ku(t);
        r == null || i && !Oo(r) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : r)
    }
}

function md(e, t, r, n, a, i, s) {
    if (t === "innerHTML" || t === "textContent") {
        n && s(n, a, i), e[t] = r ?? "";
        return
    }
    const o = e.tagName;
    if (t === "value" && o !== "PROGRESS" && !o.includes("-")) {
        const u = o === "OPTION" ? e.getAttribute("value") || "" : e.value,
            c = r ?? "";
        (u !== c || !("_value" in e)) && (e.value = c), r == null && e.removeAttribute(t), e._value = r;
        return
    }
    let l = !1;
    if (r === "" || r == null) {
        const u = typeof e[t];
        u === "boolean" ? r = Oo(r) : r == null && u === "string" ? (r = "", l = !0) : u === "number" && (r = 0, l = !0)
    }
    try {
        e[t] = r
    } catch {}
    l && e.removeAttribute(t)
}

function Ir(e, t, r, n) {
    e.addEventListener(t, r, n)
}

function vd(e, t, r, n) {
    e.removeEventListener(t, r, n)
}
const Ss = Symbol("_vei");

function pd(e, t, r, n, a = null) {
    const i = e[Ss] || (e[Ss] = {}),
        s = i[t];
    if (n && s) s.value = n;
    else {
        const [o, l] = gd(t);
        if (n) {
            const u = i[t] = wd(n, a);
            Ir(e, o, u, l)
        } else s && (vd(e, o, s, l), i[t] = void 0)
    }
}
const Ms = /(?:Once|Passive|Capture)$/;

function gd(e) {
    let t;
    if (Ms.test(e)) {
        t = {};
        let n;
        for (; n = e.match(Ms);) e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0
    }
    return [e[2] === ":" ? e.slice(3) : Br(e.slice(2)), t]
}
let Na = 0;
const yd = Promise.resolve(),
    bd = () => Na || (yd.then(() => Na = 0), Na = Date.now());

function wd(e, t) {
    const r = n => {
        if (!n._vts) n._vts = Date.now();
        else if (n._vts <= r.attached) return;
        Mt(_d(n, r.value), t, 5, [n])
    };
    return r.value = e, r.attached = bd(), r
}

function _d(e, t) {
    if (ie(t)) {
        const r = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = () => {
            r.call(e), e._stopped = !0
        }, t.map(n => a => !a._stopped && n && n(a))
    } else return t
}
const Es = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123,
    xd = (e, t, r, n, a, i, s, o, l) => {
        const u = a === "svg";
        t === "class" ? ld(e, n, u) : t === "style" ? dd(e, r, n) : aa(t) ? bi(t) || pd(e, t, r, n, s) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : kd(e, t, n, u)) ? md(e, t, n, i, s, o, l) : (t === "true-value" ? e._trueValue = n : t === "false-value" && (e._falseValue = n), hd(e, t, n, u))
    };

function kd(e, t, r, n) {
    if (n) return !!(t === "innerHTML" || t === "textContent" || t in e && Es(t) && oe(r));
    if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1;
    if (t === "width" || t === "height") {
        const a = e.tagName;
        if (a === "IMG" || a === "VIDEO" || a === "CANVAS" || a === "SOURCE") return !1
    }
    return Es(t) && Ze(r) ? !1 : t in e
}
const Ps = e => {
    const t = e.props["onUpdate:modelValue"] || !1;
    return ie(t) ? r => Ln(t, r) : t
};

function Od(e) {
    e.target.composing = !0
}

function $s(e) {
    const t = e.target;
    t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")))
}
const ja = Symbol("_assign"),
    Td = {
        created(e, {
            modifiers: {
                lazy: t,
                trim: r,
                number: n
            }
        }, a) {
            e[ja] = Ps(a);
            const i = n || a.props && a.props.type === "number";
            Ir(e, t ? "change" : "input", s => {
                if (s.target.composing) return;
                let o = e.value;
                r && (o = o.trim()), i && (o = za(o)), e[ja](o)
            }), r && Ir(e, "change", () => {
                e.value = e.value.trim()
            }), t || (Ir(e, "compositionstart", Od), Ir(e, "compositionend", $s), Ir(e, "change", $s))
        },
        mounted(e, {
            value: t
        }) {
            e.value = t ?? ""
        },
        beforeUpdate(e, {
            value: t,
            modifiers: {
                lazy: r,
                trim: n,
                number: a
            }
        }, i) {
            if (e[ja] = Ps(i), e.composing) return;
            const s = (a || e.type === "number") && !/^0\d/.test(e.value) ? za(e.value) : e.value,
                o = t ?? "";
            s !== o && (document.activeElement === e && e.type !== "range" && (r || n && e.value.trim() === o) || (e.value = o))
        }
    },
    Cd = ["ctrl", "shift", "alt", "meta"],
    Dd = {
        stop: e => e.stopPropagation(),
        prevent: e => e.preventDefault(),
        self: e => e.target !== e.currentTarget,
        ctrl: e => !e.ctrlKey,
        shift: e => !e.shiftKey,
        alt: e => !e.altKey,
        meta: e => !e.metaKey,
        left: e => "button" in e && e.button !== 0,
        middle: e => "button" in e && e.button !== 1,
        right: e => "button" in e && e.button !== 2,
        exact: (e, t) => Cd.some(r => e[`${r}Key`] && !t.includes(r))
    },
    gr = (e, t) => {
        const r = e._withMods || (e._withMods = {}),
            n = t.join(".");
        return r[n] || (r[n] = (a, ...i) => {
            for (let s = 0; s < t.length; s++) {
                const o = Dd[t[s]];
                if (o && o(a, t)) return
            }
            return e(a, ...i)
        })
    },
    Sd = rt({
        patchProp: xd
    }, sd);
let Fs;

function Md() {
    return Fs || (Fs = Rc(Sd))
}
const Ed = (...e) => {
    const t = Md().createApp(...e),
        {
            mount: r
        } = t;
    return t.mount = n => {
        const a = $d(n);
        if (!a) return;
        const i = t._component;
        !oe(i) && !i.render && !i.template && (i.template = a.innerHTML), a.innerHTML = "";
        const s = r(a, !1, Pd(a));
        return a instanceof Element && (a.removeAttribute("v-cloak"), a.setAttribute("data-v-app", "")), s
    }, t
};

function Pd(e) {
    if (e instanceof SVGElement) return "svg";
    if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml"
}

function $d(e) {
    return Ze(e) ? document.querySelector(e) : e
}
const bl = "" + new URL("../logo.png", import.meta.url).href,
    Zr = (e, t) => {
        const r = e.__vccOpts || e;
        for (const [n, a] of t) r[n] = a;
        return r
    },
    Fd = {},
    Ld = {
        class: "flex items-center justify-center min-h-screen bg-black opacity-90"
    },
    Ad = _("img", {
        src: bl,
        alt: "Logo",
        class: "w-64 animate__animated animate__tada animate__infinite"
    }, null, -1),
    Nd = [Ad];

function jd(e, t) {
    return Y(), te("div", Ld, Nd)
}
const Id = Zr(Fd, [
    ["render", jd]
]);

function Vd(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        "fill-rule": "evenodd",
        d: "M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Zm-4.28 9.22a.75.75 0 0 0 0 1.06l3 3a.75.75 0 1 0 1.06-1.06l-1.72-1.72h5.69a.75.75 0 0 0 0-1.5h-5.69l1.72-1.72a.75.75 0 0 0-1.06-1.06l-3 3Z",
        "clip-rule": "evenodd"
    })])
}

function Rd(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        "fill-rule": "evenodd",
        d: "M6.97 2.47a.75.75 0 0 1 1.06 0l4.5 4.5a.75.75 0 0 1-1.06 1.06L8.25 4.81V16.5a.75.75 0 0 1-1.5 0V4.81L3.53 8.03a.75.75 0 0 1-1.06-1.06l4.5-4.5Zm9.53 4.28a.75.75 0 0 1 .75.75v11.69l3.22-3.22a.75.75 0 1 1 1.06 1.06l-4.5 4.5a.75.75 0 0 1-1.06 0l-4.5-4.5a.75.75 0 1 1 1.06-1.06l3.22 3.22V7.5a.75.75 0 0 1 .75-.75Z",
        "clip-rule": "evenodd"
    })])
}

function wl(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        d: "M12.75 12.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM7.5 15.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5ZM8.25 17.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM9.75 15.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5ZM10.5 17.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM12 15.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5ZM12.75 17.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM14.25 15.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5ZM15 17.25a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM16.5 15.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5ZM15 12.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM16.5 13.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z"
    }), _("path", {
        "fill-rule": "evenodd",
        d: "M6.75 2.25A.75.75 0 0 1 7.5 3v1.5h9V3A.75.75 0 0 1 18 3v1.5h.75a3 3 0 0 1 3 3v11.25a3 3 0 0 1-3 3H5.25a3 3 0 0 1-3-3V7.5a3 3 0 0 1 3-3H6V3a.75.75 0 0 1 .75-.75Zm13.5 9a1.5 1.5 0 0 0-1.5-1.5H5.25a1.5 1.5 0 0 0-1.5 1.5v7.5a1.5 1.5 0 0 0 1.5 1.5h13.5a1.5 1.5 0 0 0 1.5-1.5v-7.5Z",
        "clip-rule": "evenodd"
    })])
}

function Ud(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        "fill-rule": "evenodd",
        d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12Zm13.36-1.814a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z",
        "clip-rule": "evenodd"
    })])
}

function Yd(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        "fill-rule": "evenodd",
        d: "M10.72 11.47a.75.75 0 0 0 0 1.06l7.5 7.5a.75.75 0 1 0 1.06-1.06L12.31 12l6.97-6.97a.75.75 0 0 0-1.06-1.06l-7.5 7.5Z",
        "clip-rule": "evenodd"
    }), _("path", {
        "fill-rule": "evenodd",
        d: "M4.72 11.47a.75.75 0 0 0 0 1.06l7.5 7.5a.75.75 0 1 0 1.06-1.06L6.31 12l6.97-6.97a.75.75 0 0 0-1.06-1.06l-7.5 7.5Z",
        "clip-rule": "evenodd"
    })])
}

function qd(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        "fill-rule": "evenodd",
        d: "M13.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L11.69 12 4.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z",
        "clip-rule": "evenodd"
    }), _("path", {
        "fill-rule": "evenodd",
        d: "M19.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 1 1-1.06-1.06L17.69 12l-6.97-6.97a.75.75 0 0 1 1.06-1.06l7.5 7.5Z",
        "clip-rule": "evenodd"
    })])
}

function Wd(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        d: "M4.5 3.75a3 3 0 0 0-3 3v.75h21v-.75a3 3 0 0 0-3-3h-15Z"
    }), _("path", {
        "fill-rule": "evenodd",
        d: "M22.5 9.75h-21v7.5a3 3 0 0 0 3 3h15a3 3 0 0 0 3-3v-7.5Zm-18 3.75a.75.75 0 0 1 .75-.75h6a.75.75 0 0 1 0 1.5h-6a.75.75 0 0 1-.75-.75Zm.75 2.25a.75.75 0 0 0 0 1.5h3a.75.75 0 0 0 0-1.5h-3Z",
        "clip-rule": "evenodd"
    })])
}

function Hd(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        d: "M10.464 8.746c.227-.18.497-.311.786-.394v2.795a2.252 2.252 0 0 1-.786-.393c-.394-.313-.546-.681-.546-1.004 0-.323.152-.691.546-1.004ZM12.75 15.662v-2.824c.347.085.664.228.921.421.427.32.579.686.579.991 0 .305-.152.671-.579.991a2.534 2.534 0 0 1-.921.42Z"
    }), _("path", {
        "fill-rule": "evenodd",
        d: "M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25ZM12.75 6a.75.75 0 0 0-1.5 0v.816a3.836 3.836 0 0 0-1.72.756c-.712.566-1.112 1.35-1.112 2.178 0 .829.4 1.612 1.113 2.178.502.4 1.102.647 1.719.756v2.978a2.536 2.536 0 0 1-.921-.421l-.879-.66a.75.75 0 0 0-.9 1.2l.879.66c.533.4 1.169.645 1.821.75V18a.75.75 0 0 0 1.5 0v-.81a4.124 4.124 0 0 0 1.821-.749c.745-.559 1.179-1.344 1.179-2.191 0-.847-.434-1.632-1.179-2.191a4.122 4.122 0 0 0-1.821-.75V8.354c.29.082.559.213.786.393l.415.33a.75.75 0 0 0 .933-1.175l-.415-.33a3.836 3.836 0 0 0-1.719-.755V6Z",
        "clip-rule": "evenodd"
    })])
}

function Ls(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        "fill-rule": "evenodd",
        d: "M4.5 3.75a3 3 0 0 0-3 3v10.5a3 3 0 0 0 3 3h15a3 3 0 0 0 3-3V6.75a3 3 0 0 0-3-3h-15Zm4.125 3a2.25 2.25 0 1 0 0 4.5 2.25 2.25 0 0 0 0-4.5Zm-3.873 8.703a4.126 4.126 0 0 1 7.746 0 .75.75 0 0 1-.351.92 7.47 7.47 0 0 1-3.522.877 7.47 7.47 0 0 1-3.522-.877.75.75 0 0 1-.351-.92ZM15 8.25a.75.75 0 0 0 0 1.5h3.75a.75.75 0 0 0 0-1.5H15ZM14.25 12a.75.75 0 0 1 .75-.75h3.75a.75.75 0 0 1 0 1.5H15a.75.75 0 0 1-.75-.75Zm.75 2.25a.75.75 0 0 0 0 1.5h3.75a.75.75 0 0 0 0-1.5H15Z",
        "clip-rule": "evenodd"
    })])
}

function Bd(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        "fill-rule": "evenodd",
        d: "M15.75 1.5a6.75 6.75 0 0 0-6.651 7.906c.067.39-.032.717-.221.906l-6.5 6.499a3 3 0 0 0-.878 2.121v2.818c0 .414.336.75.75.75H6a.75.75 0 0 0 .75-.75v-1.5h1.5A.75.75 0 0 0 9 19.5V18h1.5a.75.75 0 0 0 .53-.22l2.658-2.658c.19-.189.517-.288.906-.22A6.75 6.75 0 1 0 15.75 1.5Zm0 3a.75.75 0 0 0 0 1.5A2.25 2.25 0 0 1 18 8.25a.75.75 0 0 0 1.5 0 3.75 3.75 0 0 0-3.75-3.75Z",
        "clip-rule": "evenodd"
    })])
}

function zd(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        "fill-rule": "evenodd",
        d: "m11.54 22.351.07.04.028.016a.76.76 0 0 0 .723 0l.028-.015.071-.041a16.975 16.975 0 0 0 1.144-.742 19.58 19.58 0 0 0 2.683-2.282c1.944-1.99 3.963-4.98 3.963-8.827a8.25 8.25 0 0 0-16.5 0c0 3.846 2.02 6.837 3.963 8.827a19.58 19.58 0 0 0 2.682 2.282 16.975 16.975 0 0 0 1.145.742ZM12 13.5a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z",
        "clip-rule": "evenodd"
    })])
}

function Zd(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        "fill-rule": "evenodd",
        d: "M2.25 4.125c0-1.036.84-1.875 1.875-1.875h5.25c1.036 0 1.875.84 1.875 1.875V17.25a4.5 4.5 0 1 1-9 0V4.125Zm4.5 14.25a1.125 1.125 0 1 0 0-2.25 1.125 1.125 0 0 0 0 2.25Z",
        "clip-rule": "evenodd"
    }), _("path", {
        d: "M10.719 21.75h9.156c1.036 0 1.875-.84 1.875-1.875v-5.25c0-1.036-.84-1.875-1.875-1.875h-.14l-8.742 8.743c-.09.089-.18.175-.274.257ZM12.738 17.625l6.474-6.474a1.875 1.875 0 0 0 0-2.651L15.5 4.787a1.875 1.875 0 0 0-2.651 0l-.1.099V17.25c0 .126-.003.251-.01.375Z"
    })])
}

function Gd(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        "fill-rule": "evenodd",
        d: "M16.5 4.478v.227a48.816 48.816 0 0 1 3.878.512.75.75 0 1 1-.256 1.478l-.209-.035-1.005 13.07a3 3 0 0 1-2.991 2.77H8.084a3 3 0 0 1-2.991-2.77L4.087 6.66l-.209.035a.75.75 0 0 1-.256-1.478A48.567 48.567 0 0 1 7.5 4.705v-.227c0-1.564 1.213-2.9 2.816-2.951a52.662 52.662 0 0 1 3.369 0c1.603.051 2.815 1.387 2.815 2.951Zm-6.136-1.452a51.196 51.196 0 0 1 3.273 0C14.39 3.05 15 3.684 15 4.478v.113a49.488 49.488 0 0 0-6 0v-.113c0-.794.609-1.428 1.364-1.452Zm-.355 5.945a.75.75 0 1 0-1.5.058l.347 9a.75.75 0 1 0 1.499-.058l-.346-9Zm5.48.058a.75.75 0 1 0-1.498-.058l-.347 9a.75.75 0 0 0 1.5.058l.345-9Z",
        "clip-rule": "evenodd"
    })])
}

function Qd(e, t) {
    return Y(), te("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        fill: "currentColor",
        "aria-hidden": "true",
        "data-slot": "icon"
    }, [_("path", {
        d: "M4.5 6.375a4.125 4.125 0 1 1 8.25 0 4.125 4.125 0 0 1-8.25 0ZM14.25 8.625a3.375 3.375 0 1 1 6.75 0 3.375 3.375 0 0 1-6.75 0ZM1.5 19.125a7.125 7.125 0 0 1 14.25 0v.003l-.001.119a.75.75 0 0 1-.363.63 13.067 13.067 0 0 1-6.761 1.873c-2.472 0-4.786-.684-6.76-1.873a.75.75 0 0 1-.364-.63l-.001-.122ZM17.25 19.128l-.001.144a2.25 2.25 0 0 1-.233.96 10.088 10.088 0 0 0 5.06-1.01.75.75 0 0 0 .42-.643 4.875 4.875 0 0 0-6.957-4.611 8.586 8.586 0 0 1 1.71 5.157v.003Z"
    })])
}
const Kd = GetParentResourceName();
async function kr(e, t) {
    try {
        return await (await fetch(`https://${Kd}/${e}`, {
            method: "post",
            headers: {
                "Content-Type": "application/json; charset=UTF-8"
            },
            body: JSON.stringify(t)
        })).json()
    } catch (r) {
        console.error(r)
    }
}

function wt(e) {
    var t = new Audio(`./audio/${e}.wav`);
    t.play(), t.volume = .1
}
const Xd = {
        class: "mt-10 text-center uppercase"
    },
    Jd = {
        class: "text-center uppercase"
    },
    ef = {
        key: 0,
        class: "text-center uppercase"
    },
    tf = {
        key: 1,
        class: "text-center uppercase"
    },
    rf = {
        class: "text-center uppercase"
    },
    nf = {
        key: 2,
        class: "text-center mt-5 uppercase"
    },
    af = {
        class: "text-xs lowercase font-none"
    },
    sf = {
        __name: "Buttonlist",
        props: {
            remeainSlot: {
                type: Number,
                required: !0
            },
            Lang: {
                type: Object,
                required: !0
            },
            PageStatus: {
                type: Object,
                required: !0
            }
        },
        emits: ["register-updated", "photomode-updated", "credits-updated", "play-game"],
        setup(e, {
            emit: t
        }) {
            const r = re(!1),
                n = e,
                a = () => {
                    n.remeainSlot >= 1 && (r.value = !r.value, s("register-updated", r.value), wt("selectsound"))
                },
                i = (o, l = null) => {
                    s(o, !0, l), wt("selectsound")
                },
                s = t;
            return (o, l) => (Y(), te(Ue, null, [_("div", Xd, [_("button", {
                onMouseover: l[0] || (l[0] = u => q(wt)("hoversound")),
                onClick: l[1] || (l[1] = u => i("play-game")),
                class: "text-white font-bold text-2xl opacity-80 m-2 drop-shadow-md hover:text-gray-500 p-3 rounded transition-colors duration-200 items-center justify-center uppercase"
            }, ve(e.Lang.playgame), 33)]), _("div", Jd, [_("button", {
                onMouseover: l[2] || (l[2] = u => q(wt)("hoversound")),
                onClick: l[3] || (l[3] = u => i("photomode-updated", "photo")),
                class: "text-white font-bold text-2xl opacity-80 m-2 drop-shadow-md hover:text-gray-500 p-3 rounded transition-colors duration-200 items-center justify-center uppercase"
            }, ve(e.Lang.photomode), 33)]), e.PageStatus.Store.Status ? (Y(), te("div", ef, [_("button", {
                onMouseover: l[4] || (l[4] = u => q(wt)("hoversound")),
                onClick: l[5] || (l[5] = u => i("store-updated")),
                class: "text-white font-bold text-2xl opacity-80 m-2 drop-shadow-md hover:text-gray-500 p-3 rounded transition-colors duration-200 items-center justify-center uppercase"
            }, ve(e.Lang.store), 33)])) : et("", !0), e.PageStatus.Credits.Status ? (Y(), te("div", tf, [_("button", {
                onMouseover: l[6] || (l[6] = u => q(wt)("hoversound")),
                onClick: l[7] || (l[7] = u => i("credits-updated", "credits")),
                class: "text-white font-bold text-2xl opacity-80 m-2 drop-shadow-md hover:text-gray-500 p-3 rounded transition-colors duration-200 items-center justify-center uppercase"
            }, ve(e.Lang.credits), 33)])) : et("", !0), _("div", rf, [_("button", {
                onMouseover: l[8] || (l[8] = u => q(wt)("hoversound")),
                onClick: l[9] || (l[9] = u => q(kr)("exit")),
                class: "text-white font-bold text-2xl opacity-80 m-2 drop-shadow-md hover:text-gray-500 p-3 rounded transition-colors duration-200 items-center justify-center uppercase"
            }, ve(e.Lang.exit), 33)]), e.remeainSlot >= 1 ? (Y(), te("div", nf, [_("button", {
                onMouseover: l[10] || (l[10] = u => q(wt)("hoversound")),
                onClick: a,
                class: "text-white font-bold text-2xl opacity-40 m-2 drop-shadow-md hover:text-gray-500 p-3 rounded transition-colors duration-200 items-center justify-center uppercase"
            }, [Pr(ve(e.Lang.createcharacter.title) + " ", 1), _("p", af, "( " + ve(e.remeainSlot) + " " + ve(e.Lang.createcharacter.subtitle) + ")", 1)], 32)])) : et("", !0)], 64))
        }
    };
/**
 * vee-validate v4.12.6
 * (c) 2024 Abdelrahman Awad
 * @license MIT
 */
function ot(e) {
    return typeof e == "function"
}

function _l(e) {
    return e == null
}
const Dr = e => e !== null && !!e && typeof e == "object" && !Array.isArray(e);

function Vi(e) {
    return Number(e) >= 0
}

function of(e) {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
}

function lf(e) {
    return typeof e == "object" && e !== null
}

function uf(e) {
    return e == null ? e === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e)
}

function As(e) {
    if (!lf(e) || uf(e) !== "[object Object]") return !1;
    if (Object.getPrototypeOf(e) === null) return !0;
    let t = e;
    for (; Object.getPrototypeOf(t) !== null;) t = Object.getPrototypeOf(t);
    return Object.getPrototypeOf(e) === t
}

function gn(e, t) {
    return Object.keys(t).forEach(r => {
        if (As(t[r]) && As(e[r])) {
            e[r] || (e[r] = {}), gn(e[r], t[r]);
            return
        }
        e[r] = t[r]
    }), e
}

function an(e) {
    const t = e.split(".");
    if (!t.length) return "";
    let r = String(t[0]);
    for (let n = 1; n < t.length; n++) {
        if (Vi(t[n])) {
            r += `[${t[n]}]`;
            continue
        }
        r += `.${t[n]}`
    }
    return r
}
const cf = {};

function df(e) {
    return cf[e]
}

function Ns(e, t, r) {
    typeof r.value == "object" && (r.value = Ae(r.value)), !r.enumerable || r.get || r.set || !r.configurable || !r.writable || t === "__proto__" ? Object.defineProperty(e, t, r) : e[t] = r.value
}

function Ae(e) {
    if (typeof e != "object") return e;
    var t = 0,
        r, n, a, i = Object.prototype.toString.call(e);
    if (i === "[object Object]" ? a = Object.create(e.__proto__ || null) : i === "[object Array]" ? a = Array(e.length) : i === "[object Set]" ? (a = new Set, e.forEach(function(s) {
            a.add(Ae(s))
        })) : i === "[object Map]" ? (a = new Map, e.forEach(function(s, o) {
            a.set(Ae(o), Ae(s))
        })) : i === "[object Date]" ? a = new Date(+e) : i === "[object RegExp]" ? a = new RegExp(e.source, e.flags) : i === "[object DataView]" ? a = new e.constructor(Ae(e.buffer)) : i === "[object ArrayBuffer]" ? a = e.slice(0) : i.slice(-6) === "Array]" && (a = new e.constructor(e)), a) {
        for (n = Object.getOwnPropertySymbols(e); t < n.length; t++) Ns(a, n[t], Object.getOwnPropertyDescriptor(e, n[t]));
        for (t = 0, n = Object.getOwnPropertyNames(e); t < n.length; t++) Object.hasOwnProperty.call(a, r = n[t]) && a[r] === e[r] || Ns(a, r, Object.getOwnPropertyDescriptor(e, r))
    }
    return a || e
}
const ba = Symbol("vee-validate-form"),
    ff = Symbol("vee-validate-field-instance"),
    Zn = Symbol("Default empty value"),
    hf = typeof window < "u";

function ii(e) {
    return ot(e) && !!e.__locatorRef
}

function St(e) {
    return !!e && ot(e.parse) && e.__type === "VVTypedSchema"
}

function Gn(e) {
    return !!e && ot(e.validate)
}

function xn(e) {
    return e === "checkbox" || e === "radio"
}

function mf(e) {
    return Dr(e) || Array.isArray(e)
}

function vf(e) {
    return Array.isArray(e) ? e.length === 0 : Dr(e) && Object.keys(e).length === 0
}

function wa(e) {
    return /^\[.+\]$/i.test(e)
}

function pf(e) {
    return xl(e) && e.multiple
}

function xl(e) {
    return e.tagName === "SELECT"
}

function gf(e, t) {
    const r = ![!1, null, void 0, 0].includes(t.multiple) && !Number.isNaN(t.multiple);
    return e === "select" && "multiple" in t && r
}

function yf(e, t) {
    return !gf(e, t) && t.type !== "file" && !xn(t.type)
}

function kl(e) {
    return Ri(e) && e.target && "submit" in e.target
}

function Ri(e) {
    return e ? !!(typeof Event < "u" && ot(Event) && e instanceof Event || e && e.srcElement) : !1
}

function js(e, t) {
    return t in e && e[t] !== Zn
}

function ut(e, t) {
    if (e === t) return !0;
    if (e && t && typeof e == "object" && typeof t == "object") {
        if (e.constructor !== t.constructor) return !1;
        var r, n, a;
        if (Array.isArray(e)) {
            if (r = e.length, r != t.length) return !1;
            for (n = r; n-- !== 0;)
                if (!ut(e[n], t[n])) return !1;
            return !0
        }
        if (e instanceof Map && t instanceof Map) {
            if (e.size !== t.size) return !1;
            for (n of e.entries())
                if (!t.has(n[0])) return !1;
            for (n of e.entries())
                if (!ut(n[1], t.get(n[0]))) return !1;
            return !0
        }
        if (Is(e) && Is(t)) return !(e.size !== t.size || e.name !== t.name || e.lastModified !== t.lastModified || e.type !== t.type);
        if (e instanceof Set && t instanceof Set) {
            if (e.size !== t.size) return !1;
            for (n of e.entries())
                if (!t.has(n[0])) return !1;
            return !0
        }
        if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
            if (r = e.length, r != t.length) return !1;
            for (n = r; n-- !== 0;)
                if (e[n] !== t[n]) return !1;
            return !0
        }
        if (e.constructor === RegExp) return e.source === t.source && e.flags === t.flags;
        if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === t.valueOf();
        if (e.toString !== Object.prototype.toString) return e.toString() === t.toString();
        for (a = Object.keys(e), r = a.length, n = r; n-- !== 0;) {
            var i = a[n];
            if (!ut(e[i], t[i])) return !1
        }
        return !0
    }
    return e !== e && t !== t
}

function Is(e) {
    return hf ? e instanceof File : !1
}

function Ui(e) {
    return wa(e) ? e.replace(/\[|\]/gi, "") : e
}

function mt(e, t, r) {
    return e ? wa(t) ? e[Ui(t)] : (t || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((a, i) => mf(a) && i in a ? a[i] : r, e) : r
}

function Xt(e, t, r) {
    if (wa(t)) {
        e[Ui(t)] = r;
        return
    }
    const n = t.split(/\.|\[(\d+)\]/).filter(Boolean);
    let a = e;
    for (let i = 0; i < n.length; i++) {
        if (i === n.length - 1) {
            a[n[i]] = r;
            return
        }(!(n[i] in a) || _l(a[n[i]])) && (a[n[i]] = Vi(n[i + 1]) ? [] : {}), a = a[n[i]]
    }
}

function Ia(e, t) {
    if (Array.isArray(e) && Vi(t)) {
        e.splice(Number(t), 1);
        return
    }
    Dr(e) && delete e[t]
}

function Vs(e, t) {
    if (wa(t)) {
        delete e[Ui(t)];
        return
    }
    const r = t.split(/\.|\[(\d+)\]/).filter(Boolean);
    let n = e;
    for (let i = 0; i < r.length; i++) {
        if (i === r.length - 1) {
            Ia(n, r[i]);
            break
        }
        if (!(r[i] in n) || _l(n[r[i]])) break;
        n = n[r[i]]
    }
    const a = r.map((i, s) => mt(e, r.slice(0, s).join(".")));
    for (let i = a.length - 1; i >= 0; i--)
        if (vf(a[i])) {
            if (i === 0) {
                Ia(e, r[0]);
                continue
            }
            Ia(a[i - 1], r[i - 1])
        }
}

function gt(e) {
    return Object.keys(e)
}

function Ol(e, t = void 0) {
    const r = pa();
    return (r == null ? void 0 : r.provides[e]) || qr(e, t)
}

function Rs(e, t, r) {
    if (Array.isArray(e)) {
        const n = [...e],
            a = n.findIndex(i => ut(i, t));
        return a >= 0 ? n.splice(a, 1) : n.push(t), n
    }
    return ut(e, t) ? r : t
}

function Us(e, t = 0) {
    let r = null,
        n = [];
    return function(...a) {
        return r && clearTimeout(r), r = setTimeout(() => {
            const i = e(...a);
            n.forEach(s => s(i)), n = []
        }, t), new Promise(i => n.push(i))
    }
}

function bf(e, t) {
    return Dr(t) && t.number ? of(e) : e
}

function si(e, t) {
    let r;
    return async function(...a) {
        const i = e(...a);
        r = i;
        const s = await i;
        return i !== r ? s : (r = void 0, t(s, a))
    }
}

function oi(e) {
    return Array.isArray(e) ? e : e ? [e] : []
}

function Mn(e, t) {
    const r = {};
    for (const n in e) t.includes(n) || (r[n] = e[n]);
    return r
}

function wf(e) {
    let t = null,
        r = [];
    return function(...n) {
        const a = pt(() => {
            if (t !== a) return;
            const i = e(...n);
            r.forEach(s => s(i)), r = [], t = null
        });
        return t = a, new Promise(i => r.push(i))
    }
}

function Yi(e, t, r) {
    return t.slots.default ? typeof e == "string" || !e ? t.slots.default(r()) : {
        default: () => {
            var n, a;
            return (a = (n = t.slots).default) === null || a === void 0 ? void 0 : a.call(n, r())
        }
    } : t.slots.default
}

function Va(e) {
    if (Tl(e)) return e._value
}

function Tl(e) {
    return "_value" in e
}

function _f(e) {
    return e.type === "number" || e.type === "range" ? Number.isNaN(e.valueAsNumber) ? e.value : e.valueAsNumber : e.value
}

function Qn(e) {
    if (!Ri(e)) return e;
    const t = e.target;
    if (xn(t.type) && Tl(t)) return Va(t);
    if (t.type === "file" && t.files) {
        const r = Array.from(t.files);
        return t.multiple ? r : r[0]
    }
    if (pf(t)) return Array.from(t.options).filter(r => r.selected && !r.disabled).map(Va);
    if (xl(t)) {
        const r = Array.from(t.options).find(n => n.selected);
        return r ? Va(r) : t.value
    }
    return _f(t)
}

function Cl(e) {
    const t = {};
    return Object.defineProperty(t, "_$$isNormalized", {
        value: !0,
        writable: !1,
        enumerable: !1,
        configurable: !1
    }), e ? Dr(e) && e._$$isNormalized ? e : Dr(e) ? Object.keys(e).reduce((r, n) => {
        const a = xf(e[n]);
        return e[n] !== !1 && (r[n] = Ys(a)), r
    }, t) : typeof e != "string" ? t : e.split("|").reduce((r, n) => {
        const a = kf(n);
        return a.name && (r[a.name] = Ys(a.params)), r
    }, t) : t
}

function xf(e) {
    return e === !0 ? [] : Array.isArray(e) || Dr(e) ? e : [e]
}

function Ys(e) {
    const t = r => typeof r == "string" && r[0] === "@" ? Of(r.slice(1)) : r;
    return Array.isArray(e) ? e.map(t) : e instanceof RegExp ? [e] : Object.keys(e).reduce((r, n) => (r[n] = t(e[n]), r), {})
}
const kf = e => {
    let t = [];
    const r = e.split(":")[0];
    return e.includes(":") && (t = e.split(":").slice(1).join(":").split(",")), {
        name: r,
        params: t
    }
};

function Of(e) {
    const t = r => mt(r, e) || r[e];
    return t.__locatorRef = e, t
}

function Tf(e) {
    return Array.isArray(e) ? e.filter(ii) : gt(e).filter(t => ii(e[t])).map(t => e[t])
}
const Cf = {
    generateMessage: ({
        field: e
    }) => `${e} is not valid.`,
    bails: !0,
    validateOnBlur: !0,
    validateOnChange: !0,
    validateOnInput: !1,
    validateOnModelUpdate: !0
};
let Df = Object.assign({}, Cf);
const br = () => Df;
async function Dl(e, t, r = {}) {
    const n = r == null ? void 0 : r.bails,
        a = {
            name: (r == null ? void 0 : r.name) || "{field}",
            rules: t,
            label: r == null ? void 0 : r.label,
            bails: n ?? !0,
            formData: (r == null ? void 0 : r.values) || {}
        },
        s = (await Sf(a, e)).errors;
    return {
        errors: s,
        valid: !s.length
    }
}
async function Sf(e, t) {
    if (St(e.rules) || Gn(e.rules)) return Ef(t, e.rules);
    if (ot(e.rules) || Array.isArray(e.rules)) {
        const s = {
                field: e.label || e.name,
                name: e.name,
                label: e.label,
                form: e.formData,
                value: t
            },
            o = Array.isArray(e.rules) ? e.rules : [e.rules],
            l = o.length,
            u = [];
        for (let c = 0; c < l; c++) {
            const d = o[c],
                h = await d(t, s);
            if (!(typeof h != "string" && !Array.isArray(h) && h)) {
                if (Array.isArray(h)) u.push(...h);
                else {
                    const y = typeof h == "string" ? h : Ml(s);
                    u.push(y)
                }
                if (e.bails) return {
                    errors: u
                }
            }
        }
        return {
            errors: u
        }
    }
    const r = Object.assign(Object.assign({}, e), {
            rules: Cl(e.rules)
        }),
        n = [],
        a = Object.keys(r.rules),
        i = a.length;
    for (let s = 0; s < i; s++) {
        const o = a[s],
            l = await Pf(r, t, {
                name: o,
                params: r.rules[o]
            });
        if (l.error && (n.push(l.error), e.bails)) return {
            errors: n
        }
    }
    return {
        errors: n
    }
}

function Mf(e) {
    return !!e && e.name === "ValidationError"
}

function Sl(e) {
    return {
        __type: "VVTypedSchema",
        async parse(r) {
            var n;
            try {
                return {
                    output: await e.validate(r, {
                        abortEarly: !1
                    }),
                    errors: []
                }
            } catch (a) {
                if (!Mf(a)) throw a;
                if (!(!((n = a.inner) === null || n === void 0) && n.length) && a.errors.length) return {
                    errors: [{
                        path: a.path,
                        errors: a.errors
                    }]
                };
                const i = a.inner.reduce((s, o) => {
                    const l = o.path || "";
                    return s[l] || (s[l] = {
                        errors: [],
                        path: l
                    }), s[l].errors.push(...o.errors), s
                }, {});
                return {
                    errors: Object.values(i)
                }
            }
        }
    }
}
async function Ef(e, t) {
    const n = await (St(t) ? t : Sl(t)).parse(e),
        a = [];
    for (const i of n.errors) i.errors.length && a.push(...i.errors);
    return {
        errors: a
    }
}
async function Pf(e, t, r) {
    const n = df(r.name);
    if (!n) throw new Error(`No such validator '${r.name}' exists.`);
    const a = $f(r.params, e.formData),
        i = {
            field: e.label || e.name,
            name: e.name,
            label: e.label,
            value: t,
            form: e.formData,
            rule: Object.assign(Object.assign({}, r), {
                params: a
            })
        },
        s = await n(t, a, i);
    return typeof s == "string" ? {
        error: s
    } : {
        error: s ? void 0 : Ml(i)
    }
}

function Ml(e) {
    const t = br().generateMessage;
    return t ? t(e) : "Field is invalid"
}

function $f(e, t) {
    const r = n => ii(n) ? n(t) : n;
    return Array.isArray(e) ? e.map(r) : Object.keys(e).reduce((n, a) => (n[a] = r(e[a]), n), {})
}
async function Ff(e, t) {
    const n = await (St(e) ? e : Sl(e)).parse(Ae(t)),
        a = {},
        i = {};
    for (const s of n.errors) {
        const o = s.errors,
            l = (s.path || "").replace(/\["(\d+)"\]/g, (u, c) => `[${c}]`);
        a[l] = {
            valid: !o.length,
            errors: o
        }, o.length && (i[l] = o[0])
    }
    return {
        valid: !n.errors.length,
        results: a,
        errors: i,
        values: n.value
    }
}
async function Lf(e, t, r) {
    const a = gt(e).map(async u => {
        var c, d, h;
        const g = (c = r == null ? void 0 : r.names) === null || c === void 0 ? void 0 : c[u],
            y = await Dl(mt(t, u), e[u], {
                name: (g == null ? void 0 : g.name) || u,
                label: g == null ? void 0 : g.label,
                values: t,
                bails: (h = (d = r == null ? void 0 : r.bailsMap) === null || d === void 0 ? void 0 : d[u]) !== null && h !== void 0 ? h : !0
            });
        return Object.assign(Object.assign({}, y), {
            path: u
        })
    });
    let i = !0;
    const s = await Promise.all(a),
        o = {},
        l = {};
    for (const u of s) o[u.path] = {
        valid: u.valid,
        errors: u.errors
    }, u.valid || (i = !1, l[u.path] = u.errors[0]);
    return {
        valid: i,
        results: o,
        errors: l
    }
}
let qs = 0;

function Af(e, t) {
    const {
        value: r,
        initialValue: n,
        setInitialValue: a
    } = Nf(e, t.modelValue, t.form);
    if (!t.form) {
        let l = function(g) {
            var y;
            "value" in g && (r.value = g.value), "errors" in g && c(g.errors), "touched" in g && (h.touched = (y = g.touched) !== null && y !== void 0 ? y : h.touched), "initialValue" in g && a(g.initialValue)
        };
        const {
            errors: u,
            setErrors: c
        } = Vf(), d = qs >= Number.MAX_SAFE_INTEGER ? 0 : ++qs, h = If(r, n, u, t.schema);
        return {
            id: d,
            path: e,
            value: r,
            initialValue: n,
            meta: h,
            flags: {
                pendingUnmount: {
                    [d]: !1
                },
                pendingReset: !1
            },
            errors: u,
            setState: l
        }
    }
    const i = t.form.createPathState(e, {
            bails: t.bails,
            label: t.label,
            type: t.type,
            validate: t.validate,
            schema: t.schema
        }),
        s = z(() => i.errors);

    function o(l) {
        var u, c, d;
        "value" in l && (r.value = l.value), "errors" in l && ((u = t.form) === null || u === void 0 || u.setFieldError(q(e), l.errors)), "touched" in l && ((c = t.form) === null || c === void 0 || c.setFieldTouched(q(e), (d = l.touched) !== null && d !== void 0 ? d : !1)), "initialValue" in l && a(l.initialValue)
    }
    return {
        id: Array.isArray(i.id) ? i.id[i.id.length - 1] : i.id,
        path: e,
        value: r,
        errors: s,
        meta: i,
        initialValue: n,
        flags: i.__flags,
        setState: o
    }
}

function Nf(e, t, r) {
    const n = re(q(t));

    function a() {
        return r ? mt(r.initialValues.value, q(e), q(n)) : q(n)
    }

    function i(u) {
        if (!r) {
            n.value = u;
            return
        }
        r.setFieldInitialValue(q(e), u, !0)
    }
    const s = z(a);
    if (!r) return {
        value: re(a()),
        initialValue: s,
        setInitialValue: i
    };
    const o = jf(t, r, s, e);
    return r.stageInitialValue(q(e), o, !0), {
        value: z({
            get() {
                return mt(r.values, q(e))
            },
            set(u) {
                r.setFieldValue(q(e), u, !1)
            }
        }),
        initialValue: s,
        setInitialValue: i
    }
}

function jf(e, t, r, n) {
    return Ge(e) ? q(e) : e !== void 0 ? e : mt(t.values, q(n), q(r))
}

function If(e, t, r, n) {
    var a, i;
    const s = (i = (a = n == null ? void 0 : n.describe) === null || a === void 0 ? void 0 : a.call(n).required) !== null && i !== void 0 ? i : !1,
        o = Tr({
            touched: !1,
            pending: !1,
            valid: !0,
            required: s,
            validated: !!q(r).length,
            initialValue: z(() => q(t)),
            dirty: z(() => !ut(q(e), q(t)))
        });
    return xt(r, l => {
        o.valid = !l.length
    }, {
        immediate: !0,
        flush: "sync"
    }), o
}

function Vf() {
    const e = re([]);
    return {
        errors: e,
        setErrors: t => {
            e.value = oi(t)
        }
    }
}

function Rf(e, t, r) {
    return xn(r == null ? void 0 : r.type) ? Yf(e, t, r) : El(e, t, r)
}

function El(e, t, r) {
    const {
        initialValue: n,
        validateOnMount: a,
        bails: i,
        type: s,
        checkedValue: o,
        label: l,
        validateOnValueUpdate: u,
        uncheckedValue: c,
        controlled: d,
        keepValueOnUnmount: h,
        syncVModel: g,
        form: y
    } = Uf(r), k = d ? Ol(ba) : void 0, O = y || k, U = z(() => an(De(e))), N = z(() => {
        if (De(O == null ? void 0 : O.schema)) return;
        const X = q(t);
        return Gn(X) || St(X) || ot(X) || Array.isArray(X) ? X : Cl(X)
    }), {
        id: L,
        value: P,
        initialValue: E,
        meta: w,
        setState: G,
        errors: se,
        flags: he
    } = Af(U, {
        modelValue: n,
        form: O,
        bails: i,
        label: l,
        type: s,
        validate: N.value ? we : void 0,
        schema: St(t) ? t : void 0
    }), de = z(() => se.value[0]);
    g && qf({
        value: P,
        prop: g,
        handleChange: V,
        shouldValidate: () => u && !he.pendingReset
    });
    const le = (W, X = !1) => {
        w.touched = !0, X && Ne()
    };
    async function Le(W) {
        var X, pe;
        if (O != null && O.validateSchema) {
            const {
                results: ee
            } = await O.validateSchema(W);
            return (X = ee[De(U)]) !== null && X !== void 0 ? X : {
                valid: !0,
                errors: []
            }
        }
        return N.value ? Dl(P.value, N.value, {
            name: De(U),
            label: De(l),
            values: (pe = O == null ? void 0 : O.values) !== null && pe !== void 0 ? pe : {},
            bails: i
        }) : {
            valid: !0,
            errors: []
        }
    }
    const Ne = si(async () => (w.pending = !0, w.validated = !0, Le("validated-only")), W => (he.pendingUnmount[We.id] || (G({
            errors: W.errors
        }), w.pending = !1, w.valid = W.valid), W)),
        je = si(async () => Le("silent"), W => (w.valid = W.valid, W));

    function we(W) {
        return (W == null ? void 0 : W.mode) === "silent" ? je() : Ne()
    }

    function V(W, X = !0) {
        const pe = Qn(W);
        bt(pe, X)
    }
    ma(() => {
        if (a) return Ne();
        (!O || !O.validateSchema) && je()
    });

    function ne(W) {
        w.touched = W
    }

    function ce(W) {
        var X;
        const pe = W && "value" in W ? W.value : E.value;
        G({
            value: Ae(pe),
            initialValue: Ae(pe),
            touched: (X = W == null ? void 0 : W.touched) !== null && X !== void 0 ? X : !1,
            errors: (W == null ? void 0 : W.errors) || []
        }), w.pending = !1, w.validated = !1, je()
    }
    const Qe = pa();

    function bt(W, X = !0) {
        P.value = Qe && g ? bf(W, Qe.props.modelModifiers) : W, (X ? Ne : je)()
    }

    function nt(W) {
        G({
            errors: Array.isArray(W) ? W : [W]
        })
    }
    const Ke = z({
            get() {
                return P.value
            },
            set(W) {
                bt(W, u)
            }
        }),
        We = {
            id: L,
            name: U,
            label: l,
            value: Ke,
            meta: w,
            errors: se,
            errorMessage: de,
            type: s,
            checkedValue: o,
            uncheckedValue: c,
            bails: i,
            keepValueOnUnmount: h,
            resetField: ce,
            handleReset: () => ce(),
            validate: we,
            handleChange: V,
            handleBlur: le,
            setState: G,
            setTouched: ne,
            setErrors: nt,
            setValue: bt
        };
    if (Ni(ff, We), Ge(t) && typeof q(t) != "function" && xt(t, (W, X) => {
            ut(W, X) || (w.validated ? Ne() : je())
        }, {
            deep: !0
        }), !O) return We;
    const $t = z(() => {
        const W = N.value;
        return !W || ot(W) || Gn(W) || St(W) || Array.isArray(W) ? {} : Object.keys(W).reduce((X, pe) => {
            const ee = Tf(W[pe]).map(fe => fe.__locatorRef).reduce((fe, Me) => {
                const He = mt(O.values, Me) || O.values[Me];
                return He !== void 0 && (fe[Me] = He), fe
            }, {});
            return Object.assign(X, ee), X
        }, {})
    });
    return xt($t, (W, X) => {
        if (!Object.keys(W).length) return;
        !ut(W, X) && (w.validated ? Ne() : je())
    }), el(() => {
        var W;
        const X = (W = De(We.keepValueOnUnmount)) !== null && W !== void 0 ? W : De(O.keepValuesOnUnmount),
            pe = De(U);
        if (X || !O || he.pendingUnmount[We.id]) {
            O == null || O.removePathState(pe, L);
            return
        }
        he.pendingUnmount[We.id] = !0;
        const ee = O.getPathState(pe);
        if (Array.isArray(ee == null ? void 0 : ee.id) && (ee != null && ee.multiple) ? ee != null && ee.id.includes(We.id) : (ee == null ? void 0 : ee.id) === We.id) {
            if (ee != null && ee.multiple && Array.isArray(ee.value)) {
                const Me = ee.value.findIndex(He => ut(He, De(We.checkedValue)));
                if (Me > -1) {
                    const He = [...ee.value];
                    He.splice(Me, 1), O.setFieldValue(pe, He)
                }
                Array.isArray(ee.id) && ee.id.splice(ee.id.indexOf(We.id), 1)
            } else O.unsetPathValue(De(U));
            O.removePathState(pe, L)
        }
    }), We
}

function Uf(e) {
    const t = () => ({
            initialValue: void 0,
            validateOnMount: !1,
            bails: !0,
            label: void 0,
            validateOnValueUpdate: !0,
            keepValueOnUnmount: void 0,
            syncVModel: !1,
            controlled: !0
        }),
        r = !!(e != null && e.syncVModel),
        n = typeof(e == null ? void 0 : e.syncVModel) == "string" ? e.syncVModel : (e == null ? void 0 : e.modelPropName) || "modelValue",
        a = r && !("initialValue" in (e || {})) ? li(pa(), n) : e == null ? void 0 : e.initialValue;
    if (!e) return Object.assign(Object.assign({}, t()), {
        initialValue: a
    });
    const i = "valueProp" in e ? e.valueProp : e.checkedValue,
        s = "standalone" in e ? !e.standalone : e.controlled,
        o = (e == null ? void 0 : e.modelPropName) || (e == null ? void 0 : e.syncVModel) || !1;
    return Object.assign(Object.assign(Object.assign({}, t()), e || {}), {
        initialValue: a,
        controlled: s ?? !0,
        checkedValue: i,
        syncVModel: o
    })
}

function Yf(e, t, r) {
    const n = r != null && r.standalone ? void 0 : Ol(ba),
        a = r == null ? void 0 : r.checkedValue,
        i = r == null ? void 0 : r.uncheckedValue;

    function s(o) {
        const l = o.handleChange,
            u = z(() => {
                const d = De(o.value),
                    h = De(a);
                return Array.isArray(d) ? d.findIndex(g => ut(g, h)) >= 0 : ut(h, d)
            });

        function c(d, h = !0) {
            var g, y;
            if (u.value === ((g = d == null ? void 0 : d.target) === null || g === void 0 ? void 0 : g.checked)) {
                h && o.validate();
                return
            }
            const k = De(e),
                O = n == null ? void 0 : n.getPathState(k),
                U = Qn(d);
            let N = (y = De(a)) !== null && y !== void 0 ? y : U;
            n && (O != null && O.multiple) && O.type === "checkbox" ? N = Rs(mt(n.values, k) || [], N, void 0) : (r == null ? void 0 : r.type) === "checkbox" && (N = Rs(De(o.value), N, De(i))), l(N, h)
        }
        return Object.assign(Object.assign({}, o), {
            checked: u,
            checkedValue: a,
            uncheckedValue: i,
            handleChange: c
        })
    }
    return s(El(e, t, r))
}

function qf({
    prop: e,
    value: t,
    handleChange: r,
    shouldValidate: n
}) {
    const a = pa();
    if (!a || !e) return;
    const i = typeof e == "string" ? e : "modelValue",
        s = `update:${i}`;
    i in a.props && (xt(t, o => {
        ut(o, li(a, i)) || a.emit(s, o)
    }), xt(() => li(a, i), o => {
        if (o === Zn && t.value === void 0) return;
        const l = o === Zn ? void 0 : o;
        ut(l, t.value) || r(l, n())
    }))
}

function li(e, t) {
    if (e) return e.props[t]
}
const Wf = Ht({
    name: "Field",
    inheritAttrs: !1,
    props: {
        as: {
            type: [String, Object],
            default: void 0
        },
        name: {
            type: String,
            required: !0
        },
        rules: {
            type: [Object, String, Function],
            default: void 0
        },
        validateOnMount: {
            type: Boolean,
            default: !1
        },
        validateOnBlur: {
            type: Boolean,
            default: void 0
        },
        validateOnChange: {
            type: Boolean,
            default: void 0
        },
        validateOnInput: {
            type: Boolean,
            default: void 0
        },
        validateOnModelUpdate: {
            type: Boolean,
            default: void 0
        },
        bails: {
            type: Boolean,
            default: () => br().bails
        },
        label: {
            type: String,
            default: void 0
        },
        uncheckedValue: {
            type: null,
            default: void 0
        },
        modelValue: {
            type: null,
            default: Zn
        },
        modelModifiers: {
            type: null,
            default: () => ({})
        },
        "onUpdate:modelValue": {
            type: null,
            default: void 0
        },
        standalone: {
            type: Boolean,
            default: !1
        },
        keepValue: {
            type: Boolean,
            default: void 0
        }
    },
    setup(e, t) {
        const r = vr(e, "rules"),
            n = vr(e, "name"),
            a = vr(e, "label"),
            i = vr(e, "uncheckedValue"),
            s = vr(e, "keepValue"),
            {
                errors: o,
                value: l,
                errorMessage: u,
                validate: c,
                handleChange: d,
                handleBlur: h,
                setTouched: g,
                resetField: y,
                handleReset: k,
                meta: O,
                checked: U,
                setErrors: N
            } = Rf(n, r, {
                validateOnMount: e.validateOnMount,
                bails: e.bails,
                standalone: e.standalone,
                type: t.attrs.type,
                initialValue: Bf(e, t),
                checkedValue: t.attrs.value,
                uncheckedValue: i,
                label: a,
                validateOnValueUpdate: e.validateOnModelUpdate,
                keepValueOnUnmount: s,
                syncVModel: !0
            }),
            L = function(he, de = !0) {
                d(he, de)
            },
            P = z(() => {
                const {
                    validateOnInput: se,
                    validateOnChange: he,
                    validateOnBlur: de,
                    validateOnModelUpdate: le
                } = Hf(e);

                function Le(V) {
                    h(V, de), ot(t.attrs.onBlur) && t.attrs.onBlur(V)
                }

                function Ne(V) {
                    L(V, se), ot(t.attrs.onInput) && t.attrs.onInput(V)
                }

                function je(V) {
                    L(V, he), ot(t.attrs.onChange) && t.attrs.onChange(V)
                }
                const we = {
                    name: e.name,
                    onBlur: Le,
                    onInput: Ne,
                    onChange: je
                };
                return we["onUpdate:modelValue"] = V => L(V, le), we
            }),
            E = z(() => {
                const se = Object.assign({}, P.value);
                xn(t.attrs.type) && U && (se.checked = U.value);
                const he = Ws(e, t);
                return yf(he, t.attrs) && (se.value = l.value), se
            }),
            w = z(() => Object.assign(Object.assign({}, P.value), {
                modelValue: l.value
            }));

        function G() {
            return {
                field: E.value,
                componentField: w.value,
                value: l.value,
                meta: O,
                errors: o.value,
                errorMessage: u.value,
                validate: c,
                resetField: y,
                handleChange: L,
                handleInput: se => L(se, !1),
                handleReset: k,
                handleBlur: P.value.onBlur,
                setTouched: g,
                setErrors: N
            }
        }
        return t.expose({
            value: l,
            meta: O,
            errors: o,
            errorMessage: u,
            setErrors: N,
            setTouched: g,
            reset: y,
            validate: c,
            handleChange: d
        }), () => {
            const se = fa(Ws(e, t)),
                he = Yi(se, t, G);
            return se ? Bn(se, Object.assign(Object.assign({}, t.attrs), E.value), he) : he
        }
    }
});

function Ws(e, t) {
    let r = e.as || "";
    return !e.as && !t.slots.default && (r = "input"), r
}

function Hf(e) {
    var t, r, n, a;
    const {
        validateOnInput: i,
        validateOnChange: s,
        validateOnBlur: o,
        validateOnModelUpdate: l
    } = br();
    return {
        validateOnInput: (t = e.validateOnInput) !== null && t !== void 0 ? t : i,
        validateOnChange: (r = e.validateOnChange) !== null && r !== void 0 ? r : s,
        validateOnBlur: (n = e.validateOnBlur) !== null && n !== void 0 ? n : o,
        validateOnModelUpdate: (a = e.validateOnModelUpdate) !== null && a !== void 0 ? a : l
    }
}

function Bf(e, t) {
    return xn(t.attrs.type) ? js(e, "modelValue") ? e.modelValue : void 0 : js(e, "modelValue") ? e.modelValue : t.attrs.value
}
const Ra = Wf;
let zf = 0;
const En = ["bails", "fieldsCount", "id", "multiple", "type", "validate"];

function Pl(e) {
    const t = Object.assign({}, De((e == null ? void 0 : e.initialValues) || {})),
        r = q(e == null ? void 0 : e.validationSchema);
    return r && St(r) && ot(r.cast) ? Ae(r.cast(t) || {}) : Ae(t)
}

function Zf(e) {
    var t;
    const r = zf++;
    let n = 0;
    const a = re(!1),
        i = re(!1),
        s = re(0),
        o = [],
        l = Tr(Pl(e)),
        u = re([]),
        c = re({}),
        d = re({}),
        h = wf(() => {
            d.value = u.value.reduce((v, p) => (v[an(De(p.path))] = p, v), {})
        });

    function g(v, p) {
        const x = V(v);
        if (!x) {
            typeof v == "string" && (c.value[an(v)] = oi(p));
            return
        }
        if (typeof v == "string") {
            const A = an(v);
            c.value[A] && delete c.value[A]
        }
        x.errors = oi(p), x.valid = !x.errors.length
    }

    function y(v) {
        gt(v).forEach(p => {
            g(p, v[p])
        })
    }
    e != null && e.initialErrors && y(e.initialErrors);
    const k = z(() => {
            const v = u.value.reduce((p, x) => (x.errors.length && (p[x.path] = x.errors), p), {});
            return Object.assign(Object.assign({}, c.value), v)
        }),
        O = z(() => gt(k.value).reduce((v, p) => {
            const x = k.value[p];
            return x != null && x.length && (v[p] = x[0]), v
        }, {})),
        U = z(() => u.value.reduce((v, p) => (v[p.path] = {
            name: p.path || "",
            label: p.label || ""
        }, v), {})),
        N = z(() => u.value.reduce((v, p) => {
            var x;
            return v[p.path] = (x = p.bails) !== null && x !== void 0 ? x : !0, v
        }, {})),
        L = Object.assign({}, (e == null ? void 0 : e.initialErrors) || {}),
        P = (t = e == null ? void 0 : e.keepValuesOnUnmount) !== null && t !== void 0 ? t : !1,
        {
            initialValues: E,
            originalInitialValues: w,
            setInitialValues: G
        } = Qf(u, l, e),
        se = Gf(u, l, w, O),
        he = z(() => u.value.reduce((v, p) => {
            const x = mt(l, p.path);
            return Xt(v, p.path, x), v
        }, {})),
        de = e == null ? void 0 : e.validationSchema;

    function le(v, p) {
        var x, A;
        const J = z(() => mt(E.value, De(v))),
            H = d.value[De(v)],
            ge = (p == null ? void 0 : p.type) === "checkbox" || (p == null ? void 0 : p.type) === "radio";
        if (H && ge) {
            H.multiple = !0;
            const Ot = n++;
            return Array.isArray(H.id) ? H.id.push(Ot) : H.id = [H.id, Ot], H.fieldsCount++, H.__flags.pendingUnmount[Ot] = !1, H
        }
        const _e = z(() => mt(l, De(v))),
            Ce = De(v),
            Je = ce.findIndex(Ot => Ot === Ce);
        Je !== -1 && ce.splice(Je, 1);
        const Ie = z(() => {
                var Ot, Qr, Ca, es, Da, Sa;
                return St(de) ? (Ca = (Qr = (Ot = de).describe) === null || Qr === void 0 ? void 0 : Qr.call(Ot, De(v)).required) !== null && Ca !== void 0 ? Ca : !1 : St(p == null ? void 0 : p.schema) && (Sa = (Da = (es = p == null ? void 0 : p.schema).describe) === null || Da === void 0 ? void 0 : Da.call(es).required) !== null && Sa !== void 0 ? Sa : !1
            }),
            at = n++,
            ct = Tr({
                id: at,
                path: v,
                touched: !1,
                pending: !1,
                valid: !0,
                validated: !!(!((x = L[Ce]) === null || x === void 0) && x.length),
                required: Ie,
                initialValue: J,
                errors: Qu([]),
                bails: (A = p == null ? void 0 : p.bails) !== null && A !== void 0 ? A : !1,
                label: p == null ? void 0 : p.label,
                type: (p == null ? void 0 : p.type) || "default",
                value: _e,
                multiple: !1,
                __flags: {
                    pendingUnmount: {
                        [at]: !1
                    },
                    pendingReset: !1
                },
                fieldsCount: 1,
                validate: p == null ? void 0 : p.validate,
                dirty: z(() => !ut(q(_e), q(J)))
            });
        return u.value.push(ct), d.value[Ce] = ct, h(), O.value[Ce] && !L[Ce] && pt(() => {
            $(Ce, {
                mode: "silent"
            })
        }), Ge(v) && xt(v, Ot => {
            h();
            const Qr = Ae(_e.value);
            d.value[Ot] = ct, pt(() => {
                Xt(l, Ot, Qr)
            })
        }), ct
    }
    const Le = Us(I, 5),
        Ne = Us(I, 5),
        je = si(async v => await (v === "silent" ? Le() : Ne()), (v, [p]) => {
            const x = gt(X.errorBag.value),
                J = [...new Set([...gt(v.results), ...u.value.map(H => H.path), ...x])].sort().reduce((H, ge) => {
                    var _e;
                    const Ce = ge,
                        Je = V(Ce) || ne(Ce),
                        Ie = ((_e = v.results[Ce]) === null || _e === void 0 ? void 0 : _e.errors) || [],
                        at = De(Je == null ? void 0 : Je.path) || Ce,
                        ct = Kf({
                            errors: Ie,
                            valid: !Ie.length
                        }, H.results[at]);
                    return H.results[at] = ct, ct.valid || (H.errors[at] = ct.errors[0]), Je && c.value[at] && delete c.value[at], Je ? (Je.valid = ct.valid, p === "silent" || p === "validated-only" && !Je.validated || g(Je, ct.errors), H) : (g(at, Ie), H)
                }, {
                    valid: v.valid,
                    results: {},
                    errors: {}
                });
            return v.values && (J.values = v.values), gt(J.results).forEach(H => {
                var ge;
                const _e = V(H);
                _e && p !== "silent" && (p === "validated-only" && !_e.validated || g(_e, (ge = J.results[H]) === null || ge === void 0 ? void 0 : ge.errors))
            }), J
        });

    function we(v) {
        u.value.forEach(v)
    }

    function V(v) {
        const p = typeof v == "string" ? an(v) : v;
        return typeof p == "string" ? d.value[p] : p
    }

    function ne(v) {
        return u.value.filter(x => v.startsWith(x.path)).reduce((x, A) => x ? A.path.length > x.path.length ? A : x : A, void 0)
    }
    let ce = [],
        Qe;

    function bt(v) {
        return ce.push(v), Qe || (Qe = pt(() => {
            [...ce].sort().reverse().forEach(x => {
                Vs(l, x)
            }), ce = [], Qe = null
        })), Qe
    }

    function nt(v) {
        return function(x, A) {
            return function(H) {
                return H instanceof Event && (H.preventDefault(), H.stopPropagation()), we(ge => ge.touched = !0), a.value = !0, s.value++, S().then(ge => {
                    const _e = Ae(l);
                    if (ge.valid && typeof x == "function") {
                        const Ce = Ae(he.value);
                        let Je = v ? Ce : _e;
                        return ge.values && (Je = ge.values), x(Je, {
                            evt: H,
                            controlledValues: Ce,
                            setErrors: y,
                            setFieldError: g,
                            setTouched: b,
                            setFieldTouched: He,
                            setValues: fe,
                            setFieldValue: pe,
                            resetForm: C,
                            resetField: T
                        })
                    }!ge.valid && typeof A == "function" && A({
                        values: _e,
                        evt: H,
                        errors: ge.errors,
                        results: ge.results
                    })
                }).then(ge => (a.value = !1, ge), ge => {
                    throw a.value = !1, ge
                })
            }
        }
    }
    const We = nt(!1);
    We.withControlled = nt(!0);

    function $t(v, p) {
        const x = u.value.findIndex(J => J.path === v && (Array.isArray(J.id) ? J.id.includes(p) : J.id === p)),
            A = u.value[x];
        if (!(x === -1 || !A)) {
            if (pt(() => {
                    $(v, {
                        mode: "silent",
                        warn: !1
                    })
                }), A.multiple && A.fieldsCount && A.fieldsCount--, Array.isArray(A.id)) {
                const J = A.id.indexOf(p);
                J >= 0 && A.id.splice(J, 1), delete A.__flags.pendingUnmount[p]
            }(!A.multiple || A.fieldsCount <= 0) && (u.value.splice(x, 1), M(v), h(), delete d.value[v])
        }
    }

    function W(v) {
        gt(d.value).forEach(p => {
            p.startsWith(v) && delete d.value[p]
        }), u.value = u.value.filter(p => !p.path.startsWith(v)), pt(() => {
            h()
        })
    }
    const X = {
        formId: r,
        values: l,
        controlledValues: he,
        errorBag: k,
        errors: O,
        schema: de,
        submitCount: s,
        meta: se,
        isSubmitting: a,
        isValidating: i,
        fieldArrays: o,
        keepValuesOnUnmount: P,
        validateSchema: q(de) ? je : void 0,
        validate: S,
        setFieldError: g,
        validateField: $,
        setFieldValue: pe,
        setValues: fe,
        setErrors: y,
        setFieldTouched: He,
        setTouched: b,
        resetForm: C,
        resetField: T,
        handleSubmit: We,
        useFieldModel: ae,
        defineInputBinds: me,
        defineComponentBinds: Ee,
        defineField: B,
        stageInitialValue: F,
        unsetInitialValue: M,
        setFieldInitialValue: D,
        createPathState: le,
        getPathState: V,
        unsetPathValue: bt,
        removePathState: $t,
        initialValues: E,
        getAllPathStates: () => u.value,
        destroyPath: W,
        isFieldTouched: Zt,
        isFieldDirty: f,
        isFieldValid: m
    };

    function pe(v, p, x = !0) {
        const A = Ae(p),
            J = typeof v == "string" ? v : v.path;
        V(J) || le(J), Xt(l, J, A), x && $(J)
    }

    function ee(v, p = !0) {
        gt(l).forEach(x => {
            delete l[x]
        }), gt(v).forEach(x => {
            pe(x, v[x], !1)
        }), p && S()
    }

    function fe(v, p = !0) {
        gn(l, v), o.forEach(x => x && x.reset()), p && S()
    }

    function Me(v, p) {
        const x = V(De(v)) || le(v);
        return z({
            get() {
                return x.value
            },
            set(A) {
                var J;
                const H = De(v);
                pe(H, A, (J = De(p)) !== null && J !== void 0 ? J : !1)
            }
        })
    }

    function He(v, p) {
        const x = V(v);
        x && (x.touched = p)
    }

    function Zt(v) {
        const p = V(v);
        return p ? p.touched : u.value.filter(x => x.path.startsWith(v)).some(x => x.touched)
    }

    function f(v) {
        const p = V(v);
        return p ? p.dirty : u.value.filter(x => x.path.startsWith(v)).some(x => x.dirty)
    }

    function m(v) {
        const p = V(v);
        return p ? p.valid : u.value.filter(x => x.path.startsWith(v)).every(x => x.valid)
    }

    function b(v) {
        if (typeof v == "boolean") {
            we(p => {
                p.touched = v
            });
            return
        }
        gt(v).forEach(p => {
            He(p, !!v[p])
        })
    }

    function T(v, p) {
        var x;
        const A = p && "value" in p ? p.value : mt(E.value, v),
            J = V(v);
        J && (J.__flags.pendingReset = !0), D(v, Ae(A), !0), pe(v, A, !1), He(v, (x = p == null ? void 0 : p.touched) !== null && x !== void 0 ? x : !1), g(v, (p == null ? void 0 : p.errors) || []), pt(() => {
            J && (J.__flags.pendingReset = !1)
        })
    }

    function C(v, p) {
        let x = Ae(v != null && v.values ? v.values : w.value);
        x = p != null && p.force ? x : gn(w.value, x), x = St(de) && ot(de.cast) ? de.cast(x) : x, G(x), we(A => {
            var J;
            A.__flags.pendingReset = !0, A.validated = !1, A.touched = ((J = v == null ? void 0 : v.touched) === null || J === void 0 ? void 0 : J[A.path]) || !1, pe(A.path, mt(x, A.path), !1), g(A.path, void 0)
        }), p != null && p.force ? ee(x, !1) : fe(x, !1), y((v == null ? void 0 : v.errors) || {}), s.value = (v == null ? void 0 : v.submitCount) || 0, pt(() => {
            S({
                mode: "silent"
            }), we(A => {
                A.__flags.pendingReset = !1
            })
        })
    }
    async function S(v) {
        const p = (v == null ? void 0 : v.mode) || "force";
        if (p === "force" && we(H => H.validated = !0), X.validateSchema) return X.validateSchema(p);
        i.value = !0;
        const x = await Promise.all(u.value.map(H => H.validate ? H.validate(v).then(ge => ({
            key: H.path,
            valid: ge.valid,
            errors: ge.errors
        })) : Promise.resolve({
            key: H.path,
            valid: !0,
            errors: []
        })));
        i.value = !1;
        const A = {},
            J = {};
        for (const H of x) A[H.key] = {
            valid: H.valid,
            errors: H.errors
        }, H.errors.length && (J[H.key] = H.errors[0]);
        return {
            valid: x.every(H => H.valid),
            results: A,
            errors: J
        }
    }
    async function $(v, p) {
        var x;
        const A = V(v);
        if (A && (p == null ? void 0 : p.mode) !== "silent" && (A.validated = !0), de) {
            const {
                results: J
            } = await je((p == null ? void 0 : p.mode) || "validated-only");
            return J[v] || {
                errors: [],
                valid: !0
            }
        }
        return A != null && A.validate ? A.validate(p) : (!A && (x = p == null ? void 0 : p.warn), Promise.resolve({
            errors: [],
            valid: !0
        }))
    }

    function M(v) {
        Vs(E.value, v)
    }

    function F(v, p, x = !1) {
        D(v, p), Xt(l, v, p), x && !(e != null && e.initialValues) && Xt(w.value, v, Ae(p))
    }

    function D(v, p, x = !1) {
        Xt(E.value, v, Ae(p)), x && Xt(w.value, v, Ae(p))
    }
    async function I() {
        const v = q(de);
        if (!v) return {
            valid: !0,
            results: {},
            errors: {}
        };
        i.value = !0;
        const p = Gn(v) || St(v) ? await Ff(v, l) : await Lf(v, l, {
            names: U.value,
            bailsMap: N.value
        });
        return i.value = !1, p
    }
    const K = We((v, {
        evt: p
    }) => {
        kl(p) && p.target.submit()
    });
    ma(() => {
        if (e != null && e.initialErrors && y(e.initialErrors), e != null && e.initialTouched && b(e.initialTouched), e != null && e.validateOnMount) {
            S();
            return
        }
        X.validateSchema && X.validateSchema("silent")
    }), Ge(de) && xt(de, () => {
        var v;
        (v = X.validateSchema) === null || v === void 0 || v.call(X, "validated-only")
    }), Ni(ba, X);

    function B(v, p) {
        const x = ot(p) || p == null ? void 0 : p.label,
            A = V(De(v)) || le(v, {
                label: x
            }),
            J = () => ot(p) ? p(Mn(A, En)) : p || {};

        function H() {
            var Ie;
            A.touched = !0, ((Ie = J().validateOnBlur) !== null && Ie !== void 0 ? Ie : br().validateOnBlur) && $(A.path)
        }

        function ge() {
            var Ie;
            ((Ie = J().validateOnInput) !== null && Ie !== void 0 ? Ie : br().validateOnInput) && pt(() => {
                $(A.path)
            })
        }

        function _e() {
            var Ie;
            ((Ie = J().validateOnChange) !== null && Ie !== void 0 ? Ie : br().validateOnChange) && pt(() => {
                $(A.path)
            })
        }
        const Ce = z(() => {
            const Ie = {
                onChange: _e,
                onInput: ge,
                onBlur: H
            };
            return ot(p) ? Object.assign(Object.assign({}, Ie), p(Mn(A, En)).props || {}) : p != null && p.props ? Object.assign(Object.assign({}, Ie), p.props(Mn(A, En))) : Ie
        });
        return [Me(v, () => {
            var Ie, at, ct;
            return (ct = (Ie = J().validateOnModelUpdate) !== null && Ie !== void 0 ? Ie : (at = br()) === null || at === void 0 ? void 0 : at.validateOnModelUpdate) !== null && ct !== void 0 ? ct : !0
        }), Ce]
    }

    function ae(v) {
        return Array.isArray(v) ? v.map(p => Me(p, !0)) : Me(v)
    }

    function me(v, p) {
        const [x, A] = B(v, p);

        function J() {
            A.value.onBlur()
        }

        function H(_e) {
            const Ce = Qn(_e);
            pe(De(v), Ce, !1), A.value.onInput()
        }

        function ge(_e) {
            const Ce = Qn(_e);
            pe(De(v), Ce, !1), A.value.onChange()
        }
        return z(() => Object.assign(Object.assign({}, A.value), {
            onBlur: J,
            onInput: H,
            onChange: ge,
            value: x.value
        }))
    }

    function Ee(v, p) {
        const [x, A] = B(v, p), J = V(De(v));

        function H(ge) {
            x.value = ge
        }
        return z(() => {
            const ge = ot(p) ? p(Mn(J, En)) : p || {};
            return Object.assign({
                [ge.model || "modelValue"]: x.value,
                [`onUpdate:${ge.model || "modelValue"}`]: H
            }, A.value)
        })
    }
    return Object.assign(Object.assign({}, X), {
        values: Di(l),
        handleReset: () => C(),
        submitForm: K
    })
}

function Gf(e, t, r, n) {
    const a = {
            touched: "some",
            pending: "some",
            valid: "every"
        },
        i = z(() => !ut(t, q(r)));

    function s() {
        const l = e.value;
        return gt(a).reduce((u, c) => {
            const d = a[c];
            return u[c] = l[d](h => h[c]), u
        }, {})
    }
    const o = Tr(s());
    return Nn(() => {
        const l = s();
        o.touched = l.touched, o.valid = l.valid, o.pending = l.pending
    }), z(() => Object.assign(Object.assign({
        initialValues: q(r)
    }, o), {
        valid: o.valid && !gt(n.value).length,
        dirty: i.value
    }))
}

function Qf(e, t, r) {
    const n = Pl(r),
        a = re(n),
        i = re(Ae(n));

    function s(o, l = !1) {
        a.value = gn(Ae(a.value) || {}, Ae(o)), i.value = gn(Ae(i.value) || {}, Ae(o)), l && e.value.forEach(u => {
            if (u.touched) return;
            const d = mt(a.value, u.path);
            Xt(t, u.path, Ae(d))
        })
    }
    return {
        initialValues: a,
        originalInitialValues: i,
        setInitialValues: s
    }
}

function Kf(e, t) {
    return t ? {
        valid: e.valid && t.valid,
        errors: [...e.errors, ...t.errors]
    } : e
}
const Xf = Ht({
        name: "Form",
        inheritAttrs: !1,
        props: {
            as: {
                type: null,
                default: "form"
            },
            validationSchema: {
                type: Object,
                default: void 0
            },
            initialValues: {
                type: Object,
                default: void 0
            },
            initialErrors: {
                type: Object,
                default: void 0
            },
            initialTouched: {
                type: Object,
                default: void 0
            },
            validateOnMount: {
                type: Boolean,
                default: !1
            },
            onSubmit: {
                type: Function,
                default: void 0
            },
            onInvalidSubmit: {
                type: Function,
                default: void 0
            },
            keepValues: {
                type: Boolean,
                default: !1
            }
        },
        setup(e, t) {
            const r = vr(e, "validationSchema"),
                n = vr(e, "keepValues"),
                {
                    errors: a,
                    errorBag: i,
                    values: s,
                    meta: o,
                    isSubmitting: l,
                    isValidating: u,
                    submitCount: c,
                    controlledValues: d,
                    validate: h,
                    validateField: g,
                    handleReset: y,
                    resetForm: k,
                    handleSubmit: O,
                    setErrors: U,
                    setFieldError: N,
                    setFieldValue: L,
                    setValues: P,
                    setFieldTouched: E,
                    setTouched: w,
                    resetField: G
                } = Zf({
                    validationSchema: r.value ? r : void 0,
                    initialValues: e.initialValues,
                    initialErrors: e.initialErrors,
                    initialTouched: e.initialTouched,
                    validateOnMount: e.validateOnMount,
                    keepValuesOnUnmount: n
                }),
                se = O((V, {
                    evt: ne
                }) => {
                    kl(ne) && ne.target.submit()
                }, e.onInvalidSubmit),
                he = e.onSubmit ? O(e.onSubmit, e.onInvalidSubmit) : se;

            function de(V) {
                Ri(V) && V.preventDefault(), y(), typeof t.attrs.onReset == "function" && t.attrs.onReset()
            }

            function le(V, ne) {
                return O(typeof V == "function" && !ne ? V : ne, e.onInvalidSubmit)(V)
            }

            function Le() {
                return Ae(s)
            }

            function Ne() {
                return Ae(o.value)
            }

            function je() {
                return Ae(a.value)
            }

            function we() {
                return {
                    meta: o.value,
                    errors: a.value,
                    errorBag: i.value,
                    values: s,
                    isSubmitting: l.value,
                    isValidating: u.value,
                    submitCount: c.value,
                    controlledValues: d.value,
                    validate: h,
                    validateField: g,
                    handleSubmit: le,
                    handleReset: y,
                    submitForm: se,
                    setErrors: U,
                    setFieldError: N,
                    setFieldValue: L,
                    setValues: P,
                    setFieldTouched: E,
                    setTouched: w,
                    resetForm: k,
                    resetField: G,
                    getValues: Le,
                    getMeta: Ne,
                    getErrors: je
                }
            }
            return t.expose({
                    setFieldError: N,
                    setErrors: U,
                    setFieldValue: L,
                    setValues: P,
                    setFieldTouched: E,
                    setTouched: w,
                    resetForm: k,
                    validate: h,
                    validateField: g,
                    resetField: G,
                    getValues: Le,
                    getMeta: Ne,
                    getErrors: je,
                    values: s,
                    meta: o,
                    errors: a
                }),
                function() {
                    const ne = e.as === "form" ? e.as : e.as ? fa(e.as) : null,
                        ce = Yi(ne, t, we);
                    return ne ? Bn(ne, Object.assign(Object.assign(Object.assign({}, ne === "form" ? {
                        novalidate: !0
                    } : {}), t.attrs), {
                        onSubmit: he,
                        onReset: de
                    }), ce) : ce
                }
        }
    }),
    Jf = Xf,
    eh = Ht({
        name: "ErrorMessage",
        props: {
            as: {
                type: String,
                default: void 0
            },
            name: {
                type: String,
                required: !0
            }
        },
        setup(e, t) {
            const r = qr(ba, void 0),
                n = z(() => r == null ? void 0 : r.errors.value[e.name]);

            function a() {
                return {
                    message: n.value
                }
            }
            return () => {
                if (!n.value) return;
                const i = e.as ? fa(e.as) : e.as,
                    s = Yi(i, t, a),
                    o = Object.assign({
                        role: "alert"
                    }, t.attrs);
                return !i && (Array.isArray(s) || !s) && (s != null && s.length) ? s : (Array.isArray(s) || !s) && !(s != null && s.length) ? Bn(i || "span", o, n.value) : Bn(i, o, s)
            }
        }
    }),
    Ua = eh;

function th(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}

function $r(e) {
    this._maxSize = e, this.clear()
}
$r.prototype.clear = function() {
    this._size = 0, this._values = Object.create(null)
};
$r.prototype.get = function(e) {
    return this._values[e]
};
$r.prototype.set = function(e, t) {
    return this._size >= this._maxSize && this.clear(), e in this._values || this._size++, this._values[e] = t
};
var rh = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
    $l = /^\d+$/,
    nh = /^\d/,
    ah = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
    ih = /^\s*(['"]?)(.*?)(\1)\s*$/,
    qi = 512,
    Hs = new $r(qi),
    Bs = new $r(qi),
    zs = new $r(qi),
    Or = {
        Cache: $r,
        split: ui,
        normalizePath: Ya,
        setter: function(e) {
            var t = Ya(e);
            return Bs.get(e) || Bs.set(e, function(n, a) {
                for (var i = 0, s = t.length, o = n; i < s - 1;) {
                    var l = t[i];
                    if (l === "__proto__" || l === "constructor" || l === "prototype") return n;
                    o = o[t[i++]]
                }
                o[t[i]] = a
            })
        },
        getter: function(e, t) {
            var r = Ya(e);
            return zs.get(e) || zs.set(e, function(a) {
                for (var i = 0, s = r.length; i < s;)
                    if (a != null || !t) a = a[r[i++]];
                    else return;
                return a
            })
        },
        join: function(e) {
            return e.reduce(function(t, r) {
                return t + (Wi(r) || $l.test(r) ? "[" + r + "]" : (t ? "." : "") + r)
            }, "")
        },
        forEach: function(e, t, r) {
            sh(Array.isArray(e) ? e : ui(e), t, r)
        }
    };

function Ya(e) {
    return Hs.get(e) || Hs.set(e, ui(e).map(function(t) {
        return t.replace(ih, "$2")
    }))
}

function ui(e) {
    return e.match(rh) || [""]
}

function sh(e, t, r) {
    var n = e.length,
        a, i, s, o;
    for (i = 0; i < n; i++) a = e[i], a && (uh(a) && (a = '"' + a + '"'), o = Wi(a), s = !o && /^\d+$/.test(a), t.call(r, a, o, s, i, e))
}

function Wi(e) {
    return typeof e == "string" && e && ["'", '"'].indexOf(e.charAt(0)) !== -1
}

function oh(e) {
    return e.match(nh) && !e.match($l)
}

function lh(e) {
    return ah.test(e)
}

function uh(e) {
    return !Wi(e) && (oh(e) || lh(e))
}
const ch = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g,
    _a = e => e.match(ch) || [],
    xa = e => e[0].toUpperCase() + e.slice(1),
    Hi = (e, t) => _a(e).join(t).toLowerCase(),
    Fl = e => _a(e).reduce((t, r) => `${t}${t ? r[0].toUpperCase() + r.slice(1).toLowerCase() : r.toLowerCase()}`, ""),
    dh = e => xa(Fl(e)),
    fh = e => Hi(e, "_"),
    hh = e => Hi(e, "-"),
    mh = e => xa(Hi(e, " ")),
    vh = e => _a(e).map(xa).join(" ");
var qa = {
        words: _a,
        upperFirst: xa,
        camelCase: Fl,
        pascalCase: dh,
        snakeCase: fh,
        kebabCase: hh,
        sentenceCase: mh,
        titleCase: vh
    },
    Bi = {
        exports: {}
    };
Bi.exports = function(e) {
    return Ll(ph(e), e)
};
Bi.exports.array = Ll;

function Ll(e, t) {
    var r = e.length,
        n = new Array(r),
        a = {},
        i = r,
        s = gh(t),
        o = yh(e);
    for (t.forEach(function(u) {
            if (!o.has(u[0]) || !o.has(u[1])) throw new Error("Unknown node. There is an unknown node in the supplied edges.")
        }); i--;) a[i] || l(e[i], i, new Set);
    return n;

    function l(u, c, d) {
        if (d.has(u)) {
            var h;
            try {
                h = ", node was:" + JSON.stringify(u)
            } catch {
                h = ""
            }
            throw new Error("Cyclic dependency" + h)
        }
        if (!o.has(u)) throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(u));
        if (!a[c]) {
            a[c] = !0;
            var g = s.get(u) || new Set;
            if (g = Array.from(g), c = g.length) {
                d.add(u);
                do {
                    var y = g[--c];
                    l(y, o.get(y), d)
                } while (c);
                d.delete(u)
            }
            n[--r] = u
        }
    }
}

function ph(e) {
    for (var t = new Set, r = 0, n = e.length; r < n; r++) {
        var a = e[r];
        t.add(a[0]), t.add(a[1])
    }
    return Array.from(t)
}

function gh(e) {
    for (var t = new Map, r = 0, n = e.length; r < n; r++) {
        var a = e[r];
        t.has(a[0]) || t.set(a[0], new Set), t.has(a[1]) || t.set(a[1], new Set), t.get(a[0]).add(a[1])
    }
    return t
}

function yh(e) {
    for (var t = new Map, r = 0, n = e.length; r < n; r++) t.set(e[r], r);
    return t
}
var bh = Bi.exports;
const wh = th(bh),
    _h = Object.prototype.toString,
    xh = Error.prototype.toString,
    kh = RegExp.prototype.toString,
    Oh = typeof Symbol < "u" ? Symbol.prototype.toString : () => "",
    Th = /^Symbol\((.*)\)(.*)$/;

function Ch(e) {
    return e != +e ? "NaN" : e === 0 && 1 / e < 0 ? "-0" : "" + e
}

function Zs(e, t = !1) {
    if (e == null || e === !0 || e === !1) return "" + e;
    const r = typeof e;
    if (r === "number") return Ch(e);
    if (r === "string") return t ? `"${e}"` : e;
    if (r === "function") return "[Function " + (e.name || "anonymous") + "]";
    if (r === "symbol") return Oh.call(e).replace(Th, "Symbol($1)");
    const n = _h.call(e).slice(8, -1);
    return n === "Date" ? isNaN(e.getTime()) ? "" + e : e.toISOString(e) : n === "Error" || e instanceof Error ? "[" + xh.call(e) + "]" : n === "RegExp" ? kh.call(e) : null
}

function ir(e, t) {
    let r = Zs(e, t);
    return r !== null ? r : JSON.stringify(e, function(n, a) {
        let i = Zs(this[n], t);
        return i !== null ? i : a
    }, 2)
}

function Al(e) {
    return e == null ? [] : [].concat(e)
}
let Nl, jl, Il, Dh = /\$\{\s*(\w+)\s*\}/g;
Nl = Symbol.toStringTag;
class Gs {
    constructor(t, r, n, a) {
        this.name = void 0, this.message = void 0, this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = void 0, this.inner = void 0, this[Nl] = "Error", this.name = "ValidationError", this.value = r, this.path = n, this.type = a, this.errors = [], this.inner = [], Al(t).forEach(i => {
            if (ht.isError(i)) {
                this.errors.push(...i.errors);
                const s = i.inner.length ? i.inner : [i];
                this.inner.push(...s)
            } else this.errors.push(i)
        }), this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0]
    }
}
jl = Symbol.hasInstance;
Il = Symbol.toStringTag;
class ht extends Error {
    static formatError(t, r) {
        const n = r.label || r.path || "this";
        return n !== r.path && (r = Object.assign({}, r, {
            path: n
        })), typeof t == "string" ? t.replace(Dh, (a, i) => ir(r[i])) : typeof t == "function" ? t(r) : t
    }
    static isError(t) {
        return t && t.name === "ValidationError"
    }
    constructor(t, r, n, a, i) {
        const s = new Gs(t, r, n, a);
        if (i) return s;
        super(), this.value = void 0, this.path = void 0, this.type = void 0, this.params = void 0, this.errors = [], this.inner = [], this[Il] = "Error", this.name = s.name, this.message = s.message, this.type = s.type, this.value = s.value, this.path = s.path, this.errors = s.errors, this.inner = s.inner, Error.captureStackTrace && Error.captureStackTrace(this, ht)
    }
    static[jl](t) {
        return Gs[Symbol.hasInstance](t) || super[Symbol.hasInstance](t)
    }
}
let Lt = {
        default: "${path} is invalid",
        required: "${path} is a required field",
        defined: "${path} must be defined",
        notNull: "${path} cannot be null",
        oneOf: "${path} must be one of the following values: ${values}",
        notOneOf: "${path} must not be one of the following values: ${values}",
        notType: ({
            path: e,
            type: t,
            value: r,
            originalValue: n
        }) => {
            const a = n != null && n !== r ? ` (cast from the value \`${ir(n, !0)}\`).` : ".";
            return t !== "mixed" ? `${e} must be a \`${t}\` type, but the final value was: \`${ir(r, !0)}\`` + a : `${e} must match the configured type. The validated value was: \`${ir(r, !0)}\`` + a
        }
    },
    dt = {
        length: "${path} must be exactly ${length} characters",
        min: "${path} must be at least ${min} characters",
        max: "${path} must be at most ${max} characters",
        matches: '${path} must match the following: "${regex}"',
        email: "${path} must be a valid email",
        url: "${path} must be a valid URL",
        uuid: "${path} must be a valid UUID",
        datetime: "${path} must be a valid ISO date-time",
        datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
        datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
        trim: "${path} must be a trimmed string",
        lowercase: "${path} must be a lowercase string",
        uppercase: "${path} must be a upper case string"
    },
    Sh = {
        min: "${path} must be greater than or equal to ${min}",
        max: "${path} must be less than or equal to ${max}",
        lessThan: "${path} must be less than ${less}",
        moreThan: "${path} must be greater than ${more}",
        positive: "${path} must be a positive number",
        negative: "${path} must be a negative number",
        integer: "${path} must be an integer"
    },
    ci = {
        min: "${path} field must be later than ${min}",
        max: "${path} field must be at earlier than ${max}"
    },
    Mh = {
        isValue: "${path} field must be ${value}"
    },
    di = {
        noUnknown: "${path} field has unspecified keys: ${unknown}"
    },
    Eh = {
        min: "${path} field must have at least ${min} items",
        max: "${path} field must have less than or equal to ${max} items",
        length: "${path} must have ${length} items"
    },
    Ph = {
        notType: e => {
            const {
                path: t,
                value: r,
                spec: n
            } = e, a = n.types.length;
            if (Array.isArray(r)) {
                if (r.length < a) return `${t} tuple value has too few items, expected a length of ${a} but got ${r.length} for value: \`${ir(r, !0)}\``;
                if (r.length > a) return `${t} tuple value has too many items, expected a length of ${a} but got ${r.length} for value: \`${ir(r, !0)}\``
            }
            return ht.formatError(Lt.notType, e)
        }
    };
Object.assign(Object.create(null), {
    mixed: Lt,
    string: dt,
    number: Sh,
    date: ci,
    object: di,
    array: Eh,
    boolean: Mh,
    tuple: Ph
});
const zi = e => e && e.__isYupSchema__;
class Kn {
    static fromOptions(t, r) {
        if (!r.then && !r.otherwise) throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
        let {
            is: n,
            then: a,
            otherwise: i
        } = r, s = typeof n == "function" ? n : (...o) => o.every(l => l === n);
        return new Kn(t, (o, l) => {
            var u;
            let c = s(...o) ? a : i;
            return (u = c == null ? void 0 : c(l)) != null ? u : l
        })
    }
    constructor(t, r) {
        this.fn = void 0, this.refs = t, this.refs = t, this.fn = r
    }
    resolve(t, r) {
        let n = this.refs.map(i => i.getValue(r == null ? void 0 : r.value, r == null ? void 0 : r.parent, r == null ? void 0 : r.context)),
            a = this.fn(n, t, r);
        if (a === void 0 || a === t) return t;
        if (!zi(a)) throw new TypeError("conditions must return a schema object");
        return a.resolve(r)
    }
}
const Pn = {
    context: "$",
    value: "."
};
class Fr {
    constructor(t, r = {}) {
        if (this.key = void 0, this.isContext = void 0, this.isValue = void 0, this.isSibling = void 0, this.path = void 0, this.getter = void 0, this.map = void 0, typeof t != "string") throw new TypeError("ref must be a string, got: " + t);
        if (this.key = t.trim(), t === "") throw new TypeError("ref must be a non-empty string");
        this.isContext = this.key[0] === Pn.context, this.isValue = this.key[0] === Pn.value, this.isSibling = !this.isContext && !this.isValue;
        let n = this.isContext ? Pn.context : this.isValue ? Pn.value : "";
        this.path = this.key.slice(n.length), this.getter = this.path && Or.getter(this.path, !0), this.map = r.map
    }
    getValue(t, r, n) {
        let a = this.isContext ? n : this.isValue ? t : r;
        return this.getter && (a = this.getter(a || {})), this.map && (a = this.map(a)), a
    }
    cast(t, r) {
        return this.getValue(t, r == null ? void 0 : r.parent, r == null ? void 0 : r.context)
    }
    resolve() {
        return this
    }
    describe() {
        return {
            type: "ref",
            key: this.key
        }
    }
    toString() {
        return `Ref(${this.key})`
    }
    static isRef(t) {
        return t && t.__isYupRef
    }
}
Fr.prototype.__isYupRef = !0;
const wr = e => e == null;

function Lr(e) {
    function t({
        value: r,
        path: n = "",
        options: a,
        originalValue: i,
        schema: s
    }, o, l) {
        const {
            name: u,
            test: c,
            params: d,
            message: h,
            skipAbsent: g
        } = e;
        let {
            parent: y,
            context: k,
            abortEarly: O = s.spec.abortEarly,
            disableStackTrace: U = s.spec.disableStackTrace
        } = a;

        function N(le) {
            return Fr.isRef(le) ? le.getValue(r, y, k) : le
        }

        function L(le = {}) {
            const Le = Object.assign({
                value: r,
                originalValue: i,
                label: s.spec.label,
                path: le.path || n,
                spec: s.spec,
                disableStackTrace: le.disableStackTrace || U
            }, d, le.params);
            for (const je of Object.keys(Le)) Le[je] = N(Le[je]);
            const Ne = new ht(ht.formatError(le.message || h, Le), r, Le.path, le.type || u, Le.disableStackTrace);
            return Ne.params = Le, Ne
        }
        const P = O ? o : l;
        let E = {
            path: n,
            parent: y,
            type: u,
            from: a.from,
            createError: L,
            resolve: N,
            options: a,
            originalValue: i,
            schema: s
        };
        const w = le => {
                ht.isError(le) ? P(le) : le ? l(null) : P(L())
            },
            G = le => {
                ht.isError(le) ? P(le) : o(le)
            };
        if (g && wr(r)) return w(!0);
        let he;
        try {
            var de;
            if (he = c.call(E, r, E), typeof((de = he) == null ? void 0 : de.then) == "function") {
                if (a.sync) throw new Error(`Validation test of type: "${E.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
                return Promise.resolve(he).then(w, G)
            }
        } catch (le) {
            G(le);
            return
        }
        w(he)
    }
    return t.OPTIONS = e, t
}

function $h(e, t, r, n = r) {
    let a, i, s;
    return t ? (Or.forEach(t, (o, l, u) => {
        let c = l ? o.slice(1, o.length - 1) : o;
        e = e.resolve({
            context: n,
            parent: a,
            value: r
        });
        let d = e.type === "tuple",
            h = u ? parseInt(c, 10) : 0;
        if (e.innerType || d) {
            if (d && !u) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${s}" must contain an index to the tuple element, e.g. "${s}[0]"`);
            if (r && h >= r.length) throw new Error(`Yup.reach cannot resolve an array item at index: ${o}, in the path: ${t}. because there is no value at that index. `);
            a = r, r = r && r[h], e = d ? e.spec.types[h] : e.innerType
        }
        if (!u) {
            if (!e.fields || !e.fields[c]) throw new Error(`The schema does not contain the path: ${t}. (failed at: ${s} which is a type: "${e.type}")`);
            a = r, r = r && r[c], e = e.fields[c]
        }
        i = c, s = l ? "[" + o + "]" : "." + o
    }), {
        schema: e,
        parent: a,
        parentPath: i
    }) : {
        parent: a,
        parentPath: t,
        schema: e
    }
}
class Xn extends Set {
    describe() {
        const t = [];
        for (const r of this.values()) t.push(Fr.isRef(r) ? r.describe() : r);
        return t
    }
    resolveAll(t) {
        let r = [];
        for (const n of this.values()) r.push(t(n));
        return r
    }
    clone() {
        return new Xn(this.values())
    }
    merge(t, r) {
        const n = this.clone();
        return t.forEach(a => n.add(a)), r.forEach(a => n.delete(a)), n
    }
}

function Vr(e, t = new Map) {
    if (zi(e) || !e || typeof e != "object") return e;
    if (t.has(e)) return t.get(e);
    let r;
    if (e instanceof Date) r = new Date(e.getTime()), t.set(e, r);
    else if (e instanceof RegExp) r = new RegExp(e), t.set(e, r);
    else if (Array.isArray(e)) {
        r = new Array(e.length), t.set(e, r);
        for (let n = 0; n < e.length; n++) r[n] = Vr(e[n], t)
    } else if (e instanceof Map) {
        r = new Map, t.set(e, r);
        for (const [n, a] of e.entries()) r.set(n, Vr(a, t))
    } else if (e instanceof Set) {
        r = new Set, t.set(e, r);
        for (const n of e) r.add(Vr(n, t))
    } else if (e instanceof Object) {
        r = {}, t.set(e, r);
        for (const [n, a] of Object.entries(e)) r[n] = Vr(a, t)
    } else throw Error(`Unable to clone ${e}`);
    return r
}
class Et {
    constructor(t) {
        this.type = void 0, this.deps = [], this.tests = void 0, this.transforms = void 0, this.conditions = [], this._mutate = void 0, this.internalTests = {}, this._whitelist = new Xn, this._blacklist = new Xn, this.exclusiveTests = Object.create(null), this._typeCheck = void 0, this.spec = void 0, this.tests = [], this.transforms = [], this.withMutation(() => {
            this.typeError(Lt.notType)
        }), this.type = t.type, this._typeCheck = t.check, this.spec = Object.assign({
            strip: !1,
            strict: !1,
            abortEarly: !0,
            recursive: !0,
            disableStackTrace: !1,
            nullable: !1,
            optional: !0,
            coerce: !0
        }, t == null ? void 0 : t.spec), this.withMutation(r => {
            r.nonNullable()
        })
    }
    get _type() {
        return this.type
    }
    clone(t) {
        if (this._mutate) return t && Object.assign(this.spec, t), this;
        const r = Object.create(Object.getPrototypeOf(this));
        return r.type = this.type, r._typeCheck = this._typeCheck, r._whitelist = this._whitelist.clone(), r._blacklist = this._blacklist.clone(), r.internalTests = Object.assign({}, this.internalTests), r.exclusiveTests = Object.assign({}, this.exclusiveTests), r.deps = [...this.deps], r.conditions = [...this.conditions], r.tests = [...this.tests], r.transforms = [...this.transforms], r.spec = Vr(Object.assign({}, this.spec, t)), r
    }
    label(t) {
        let r = this.clone();
        return r.spec.label = t, r
    }
    meta(...t) {
        if (t.length === 0) return this.spec.meta;
        let r = this.clone();
        return r.spec.meta = Object.assign(r.spec.meta || {}, t[0]), r
    }
    withMutation(t) {
        let r = this._mutate;
        this._mutate = !0;
        let n = t(this);
        return this._mutate = r, n
    }
    concat(t) {
        if (!t || t === this) return this;
        if (t.type !== this.type && this.type !== "mixed") throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${t.type}`);
        let r = this,
            n = t.clone();
        const a = Object.assign({}, r.spec, n.spec);
        return n.spec = a, n.internalTests = Object.assign({}, r.internalTests, n.internalTests), n._whitelist = r._whitelist.merge(t._whitelist, t._blacklist), n._blacklist = r._blacklist.merge(t._blacklist, t._whitelist), n.tests = r.tests, n.exclusiveTests = r.exclusiveTests, n.withMutation(i => {
            t.tests.forEach(s => {
                i.test(s.OPTIONS)
            })
        }), n.transforms = [...r.transforms, ...n.transforms], n
    }
    isType(t) {
        return t == null ? !!(this.spec.nullable && t === null || this.spec.optional && t === void 0) : this._typeCheck(t)
    }
    resolve(t) {
        let r = this;
        if (r.conditions.length) {
            let n = r.conditions;
            r = r.clone(), r.conditions = [], r = n.reduce((a, i) => i.resolve(a, t), r), r = r.resolve(t)
        }
        return r
    }
    resolveOptions(t) {
        var r, n, a, i;
        return Object.assign({}, t, {
            from: t.from || [],
            strict: (r = t.strict) != null ? r : this.spec.strict,
            abortEarly: (n = t.abortEarly) != null ? n : this.spec.abortEarly,
            recursive: (a = t.recursive) != null ? a : this.spec.recursive,
            disableStackTrace: (i = t.disableStackTrace) != null ? i : this.spec.disableStackTrace
        })
    }
    cast(t, r = {}) {
        let n = this.resolve(Object.assign({
                value: t
            }, r)),
            a = r.assert === "ignore-optionality",
            i = n._cast(t, r);
        if (r.assert !== !1 && !n.isType(i)) {
            if (a && wr(i)) return i;
            let s = ir(t),
                o = ir(i);
            throw new TypeError(`The value of ${r.path || "field"} could not be cast to a value that satisfies the schema type: "${n.type}".

attempted value: ${s}
` + (o !== s ? `result of cast: ${o}` : ""))
        }
        return i
    }
    _cast(t, r) {
        let n = t === void 0 ? t : this.transforms.reduce((a, i) => i.call(this, a, t, this), t);
        return n === void 0 && (n = this.getDefault(r)), n
    }
    _validate(t, r = {}, n, a) {
        let {
            path: i,
            originalValue: s = t,
            strict: o = this.spec.strict
        } = r, l = t;
        o || (l = this._cast(l, Object.assign({
            assert: !1
        }, r)));
        let u = [];
        for (let c of Object.values(this.internalTests)) c && u.push(c);
        this.runTests({
            path: i,
            value: l,
            originalValue: s,
            options: r,
            tests: u
        }, n, c => {
            if (c.length) return a(c, l);
            this.runTests({
                path: i,
                value: l,
                originalValue: s,
                options: r,
                tests: this.tests
            }, n, a)
        })
    }
    runTests(t, r, n) {
        let a = !1,
            {
                tests: i,
                value: s,
                originalValue: o,
                path: l,
                options: u
            } = t,
            c = k => {
                a || (a = !0, r(k, s))
            },
            d = k => {
                a || (a = !0, n(k, s))
            },
            h = i.length,
            g = [];
        if (!h) return d([]);
        let y = {
            value: s,
            originalValue: o,
            path: l,
            options: u,
            schema: this
        };
        for (let k = 0; k < i.length; k++) {
            const O = i[k];
            O(y, c, function(N) {
                N && (Array.isArray(N) ? g.push(...N) : g.push(N)), --h <= 0 && d(g)
            })
        }
    }
    asNestedTest({
        key: t,
        index: r,
        parent: n,
        parentPath: a,
        originalParent: i,
        options: s
    }) {
        const o = t ?? r;
        if (o == null) throw TypeError("Must include `key` or `index` for nested validations");
        const l = typeof o == "number";
        let u = n[o];
        const c = Object.assign({}, s, {
            strict: !0,
            parent: n,
            value: u,
            originalValue: i[o],
            key: void 0,
            [l ? "index" : "key"]: o,
            path: l || o.includes(".") ? `${a || ""}[${l ? o : `"${o}"`}]` : (a ? `${a}.` : "") + t
        });
        return (d, h, g) => this.resolve(c)._validate(u, c, h, g)
    }
    validate(t, r) {
        var n;
        let a = this.resolve(Object.assign({}, r, {
                value: t
            })),
            i = (n = r == null ? void 0 : r.disableStackTrace) != null ? n : a.spec.disableStackTrace;
        return new Promise((s, o) => a._validate(t, r, (l, u) => {
            ht.isError(l) && (l.value = u), o(l)
        }, (l, u) => {
            l.length ? o(new ht(l, u, void 0, void 0, i)) : s(u)
        }))
    }
    validateSync(t, r) {
        var n;
        let a = this.resolve(Object.assign({}, r, {
                value: t
            })),
            i, s = (n = r == null ? void 0 : r.disableStackTrace) != null ? n : a.spec.disableStackTrace;
        return a._validate(t, Object.assign({}, r, {
            sync: !0
        }), (o, l) => {
            throw ht.isError(o) && (o.value = l), o
        }, (o, l) => {
            if (o.length) throw new ht(o, t, void 0, void 0, s);
            i = l
        }), i
    }
    isValid(t, r) {
        return this.validate(t, r).then(() => !0, n => {
            if (ht.isError(n)) return !1;
            throw n
        })
    }
    isValidSync(t, r) {
        try {
            return this.validateSync(t, r), !0
        } catch (n) {
            if (ht.isError(n)) return !1;
            throw n
        }
    }
    _getDefault(t) {
        let r = this.spec.default;
        return r == null ? r : typeof r == "function" ? r.call(this, t) : Vr(r)
    }
    getDefault(t) {
        return this.resolve(t || {})._getDefault(t)
    }
    default (t) {
        return arguments.length === 0 ? this._getDefault() : this.clone({
            default: t
        })
    }
    strict(t = !0) {
        return this.clone({
            strict: t
        })
    }
    nullability(t, r) {
        const n = this.clone({
            nullable: t
        });
        return n.internalTests.nullable = Lr({
            message: r,
            name: "nullable",
            test(a) {
                return a === null ? this.schema.spec.nullable : !0
            }
        }), n
    }
    optionality(t, r) {
        const n = this.clone({
            optional: t
        });
        return n.internalTests.optionality = Lr({
            message: r,
            name: "optionality",
            test(a) {
                return a === void 0 ? this.schema.spec.optional : !0
            }
        }), n
    }
    optional() {
        return this.optionality(!0)
    }
    defined(t = Lt.defined) {
        return this.optionality(!1, t)
    }
    nullable() {
        return this.nullability(!0)
    }
    nonNullable(t = Lt.notNull) {
        return this.nullability(!1, t)
    }
    required(t = Lt.required) {
        return this.clone().withMutation(r => r.nonNullable(t).defined(t))
    }
    notRequired() {
        return this.clone().withMutation(t => t.nullable().optional())
    }
    transform(t) {
        let r = this.clone();
        return r.transforms.push(t), r
    }
    test(...t) {
        let r;
        if (t.length === 1 ? typeof t[0] == "function" ? r = {
                test: t[0]
            } : r = t[0] : t.length === 2 ? r = {
                name: t[0],
                test: t[1]
            } : r = {
                name: t[0],
                message: t[1],
                test: t[2]
            }, r.message === void 0 && (r.message = Lt.default), typeof r.test != "function") throw new TypeError("`test` is a required parameters");
        let n = this.clone(),
            a = Lr(r),
            i = r.exclusive || r.name && n.exclusiveTests[r.name] === !0;
        if (r.exclusive && !r.name) throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
        return r.name && (n.exclusiveTests[r.name] = !!r.exclusive), n.tests = n.tests.filter(s => !(s.OPTIONS.name === r.name && (i || s.OPTIONS.test === a.OPTIONS.test))), n.tests.push(a), n
    }
    when(t, r) {
        !Array.isArray(t) && typeof t != "string" && (r = t, t = ".");
        let n = this.clone(),
            a = Al(t).map(i => new Fr(i));
        return a.forEach(i => {
            i.isSibling && n.deps.push(i.key)
        }), n.conditions.push(typeof r == "function" ? new Kn(a, r) : Kn.fromOptions(a, r)), n
    }
    typeError(t) {
        let r = this.clone();
        return r.internalTests.typeError = Lr({
            message: t,
            name: "typeError",
            skipAbsent: !0,
            test(n) {
                return this.schema._typeCheck(n) ? !0 : this.createError({
                    params: {
                        type: this.schema.type
                    }
                })
            }
        }), r
    }
    oneOf(t, r = Lt.oneOf) {
        let n = this.clone();
        return t.forEach(a => {
            n._whitelist.add(a), n._blacklist.delete(a)
        }), n.internalTests.whiteList = Lr({
            message: r,
            name: "oneOf",
            skipAbsent: !0,
            test(a) {
                let i = this.schema._whitelist,
                    s = i.resolveAll(this.resolve);
                return s.includes(a) ? !0 : this.createError({
                    params: {
                        values: Array.from(i).join(", "),
                        resolved: s
                    }
                })
            }
        }), n
    }
    notOneOf(t, r = Lt.notOneOf) {
        let n = this.clone();
        return t.forEach(a => {
            n._blacklist.add(a), n._whitelist.delete(a)
        }), n.internalTests.blacklist = Lr({
            message: r,
            name: "notOneOf",
            test(a) {
                let i = this.schema._blacklist,
                    s = i.resolveAll(this.resolve);
                return s.includes(a) ? this.createError({
                    params: {
                        values: Array.from(i).join(", "),
                        resolved: s
                    }
                }) : !0
            }
        }), n
    }
    strip(t = !0) {
        let r = this.clone();
        return r.spec.strip = t, r
    }
    describe(t) {
        const r = (t ? this.resolve(t) : this).clone(),
            {
                label: n,
                meta: a,
                optional: i,
                nullable: s
            } = r.spec;
        return {
            meta: a,
            label: n,
            optional: i,
            nullable: s,
            default: r.getDefault(t),
            type: r.type,
            oneOf: r._whitelist.describe(),
            notOneOf: r._blacklist.describe(),
            tests: r.tests.map(l => ({
                name: l.OPTIONS.name,
                params: l.OPTIONS.params
            })).filter((l, u, c) => c.findIndex(d => d.name === l.name) === u)
        }
    }
}
Et.prototype.__isYupSchema__ = !0;
for (const e of ["validate", "validateSync"]) Et.prototype[`${e}At`] = function(t, r, n = {}) {
    const {
        parent: a,
        parentPath: i,
        schema: s
    } = $h(this, t, r, n.context);
    return s[e](a && a[i], Object.assign({}, n, {
        parent: a,
        path: t
    }))
};
for (const e of ["equals", "is"]) Et.prototype[e] = Et.prototype.oneOf;
for (const e of ["not", "nope"]) Et.prototype[e] = Et.prototype.notOneOf;
const Fh = () => !0;

function Vl(e) {
    return new Rl(e)
}
class Rl extends Et {
    constructor(t) {
        super(typeof t == "function" ? {
            type: "mixed",
            check: t
        } : Object.assign({
            type: "mixed",
            check: Fh
        }, t))
    }
}
Vl.prototype = Rl.prototype;
const Lh = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;

function Ah(e) {
    const t = fi(e);
    if (!t) return Date.parse ? Date.parse(e) : Number.NaN;
    if (t.z === void 0 && t.plusMinus === void 0) return new Date(t.year, t.month, t.day, t.hour, t.minute, t.second, t.millisecond).valueOf();
    let r = 0;
    return t.z !== "Z" && t.plusMinus !== void 0 && (r = t.hourOffset * 60 + t.minuteOffset, t.plusMinus === "+" && (r = 0 - r)), Date.UTC(t.year, t.month, t.day, t.hour, t.minute + r, t.second, t.millisecond)
}

function fi(e) {
    var t, r;
    const n = Lh.exec(e);
    return n ? {
        year: Yt(n[1]),
        month: Yt(n[2], 1) - 1,
        day: Yt(n[3], 1),
        hour: Yt(n[4]),
        minute: Yt(n[5]),
        second: Yt(n[6]),
        millisecond: n[7] ? Yt(n[7].substring(0, 3)) : 0,
        precision: (t = (r = n[7]) == null ? void 0 : r.length) != null ? t : void 0,
        z: n[8] || void 0,
        plusMinus: n[9] || void 0,
        hourOffset: Yt(n[10]),
        minuteOffset: Yt(n[11])
    } : null
}

function Yt(e, t = 0) {
    return Number(e) || t
}
let Nh = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
    jh = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i,
    Ih = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i,
    Vh = "^\\d{4}-\\d{2}-\\d{2}",
    Rh = "\\d{2}:\\d{2}:\\d{2}",
    Uh = "(([+-]\\d{2}(:?\\d{2})?)|Z)",
    Yh = new RegExp(`${Vh}T${Rh}(\\.\\d+)?${Uh}$`),
    qh = e => wr(e) || e === e.trim(),
    Wh = {}.toString();

function hi() {
    return new Ul
}
class Ul extends Et {
    constructor() {
        super({
            type: "string",
            check(t) {
                return t instanceof String && (t = t.valueOf()), typeof t == "string"
            }
        }), this.withMutation(() => {
            this.transform((t, r, n) => {
                if (!n.spec.coerce || n.isType(t) || Array.isArray(t)) return t;
                const a = t != null && t.toString ? t.toString() : t;
                return a === Wh ? t : a
            })
        })
    }
    required(t) {
        return super.required(t).withMutation(r => r.test({
            message: t || Lt.required,
            name: "required",
            skipAbsent: !0,
            test: n => !!n.length
        }))
    }
    notRequired() {
        return super.notRequired().withMutation(t => (t.tests = t.tests.filter(r => r.OPTIONS.name !== "required"), t))
    }
    length(t, r = dt.length) {
        return this.test({
            message: r,
            name: "length",
            exclusive: !0,
            params: {
                length: t
            },
            skipAbsent: !0,
            test(n) {
                return n.length === this.resolve(t)
            }
        })
    }
    min(t, r = dt.min) {
        return this.test({
            message: r,
            name: "min",
            exclusive: !0,
            params: {
                min: t
            },
            skipAbsent: !0,
            test(n) {
                return n.length >= this.resolve(t)
            }
        })
    }
    max(t, r = dt.max) {
        return this.test({
            name: "max",
            exclusive: !0,
            message: r,
            params: {
                max: t
            },
            skipAbsent: !0,
            test(n) {
                return n.length <= this.resolve(t)
            }
        })
    }
    matches(t, r) {
        let n = !1,
            a, i;
        return r && (typeof r == "object" ? {
            excludeEmptyString: n = !1,
            message: a,
            name: i
        } = r : a = r), this.test({
            name: i || "matches",
            message: a || dt.matches,
            params: {
                regex: t
            },
            skipAbsent: !0,
            test: s => s === "" && n || s.search(t) !== -1
        })
    }
    email(t = dt.email) {
        return this.matches(Nh, {
            name: "email",
            message: t,
            excludeEmptyString: !0
        })
    }
    url(t = dt.url) {
        return this.matches(jh, {
            name: "url",
            message: t,
            excludeEmptyString: !0
        })
    }
    uuid(t = dt.uuid) {
        return this.matches(Ih, {
            name: "uuid",
            message: t,
            excludeEmptyString: !1
        })
    }
    datetime(t) {
        let r = "",
            n, a;
        return t && (typeof t == "object" ? {
            message: r = "",
            allowOffset: n = !1,
            precision: a = void 0
        } = t : r = t), this.matches(Yh, {
            name: "datetime",
            message: r || dt.datetime,
            excludeEmptyString: !0
        }).test({
            name: "datetime_offset",
            message: r || dt.datetime_offset,
            params: {
                allowOffset: n
            },
            skipAbsent: !0,
            test: i => {
                if (!i || n) return !0;
                const s = fi(i);
                return s ? !!s.z : !1
            }
        }).test({
            name: "datetime_precision",
            message: r || dt.datetime_precision,
            params: {
                precision: a
            },
            skipAbsent: !0,
            test: i => {
                if (!i || a == null) return !0;
                const s = fi(i);
                return s ? s.precision === a : !1
            }
        })
    }
    ensure() {
        return this.default("").transform(t => t === null ? "" : t)
    }
    trim(t = dt.trim) {
        return this.transform(r => r != null ? r.trim() : r).test({
            message: t,
            name: "trim",
            test: qh
        })
    }
    lowercase(t = dt.lowercase) {
        return this.transform(r => wr(r) ? r : r.toLowerCase()).test({
            message: t,
            name: "string_case",
            exclusive: !0,
            skipAbsent: !0,
            test: r => wr(r) || r === r.toLowerCase()
        })
    }
    uppercase(t = dt.uppercase) {
        return this.transform(r => wr(r) ? r : r.toUpperCase()).test({
            message: t,
            name: "string_case",
            exclusive: !0,
            skipAbsent: !0,
            test: r => wr(r) || r === r.toUpperCase()
        })
    }
}
hi.prototype = Ul.prototype;
let Hh = new Date(""),
    Bh = e => Object.prototype.toString.call(e) === "[object Date]";
class ka extends Et {
    constructor() {
        super({
            type: "date",
            check(t) {
                return Bh(t) && !isNaN(t.getTime())
            }
        }), this.withMutation(() => {
            this.transform((t, r, n) => !n.spec.coerce || n.isType(t) || t === null ? t : (t = Ah(t), isNaN(t) ? ka.INVALID_DATE : new Date(t)))
        })
    }
    prepareParam(t, r) {
        let n;
        if (Fr.isRef(t)) n = t;
        else {
            let a = this.cast(t);
            if (!this._typeCheck(a)) throw new TypeError(`\`${r}\` must be a Date or a value that can be \`cast()\` to a Date`);
            n = a
        }
        return n
    }
    min(t, r = ci.min) {
        let n = this.prepareParam(t, "min");
        return this.test({
            message: r,
            name: "min",
            exclusive: !0,
            params: {
                min: t
            },
            skipAbsent: !0,
            test(a) {
                return a >= this.resolve(n)
            }
        })
    }
    max(t, r = ci.max) {
        let n = this.prepareParam(t, "max");
        return this.test({
            message: r,
            name: "max",
            exclusive: !0,
            params: {
                max: t
            },
            skipAbsent: !0,
            test(a) {
                return a <= this.resolve(n)
            }
        })
    }
}
ka.INVALID_DATE = Hh;
ka.prototype;

function zh(e, t = []) {
    let r = [],
        n = new Set,
        a = new Set(t.map(([s, o]) => `${s}-${o}`));

    function i(s, o) {
        let l = Or.split(s)[0];
        n.add(l), a.has(`${o}-${l}`) || r.push([o, l])
    }
    for (const s of Object.keys(e)) {
        let o = e[s];
        n.add(s), Fr.isRef(o) && o.isSibling ? i(o.path, s) : zi(o) && "deps" in o && o.deps.forEach(l => i(l, s))
    }
    return wh.array(Array.from(n), r).reverse()
}

function Qs(e, t) {
    let r = 1 / 0;
    return e.some((n, a) => {
        var i;
        if ((i = t.path) != null && i.includes(n)) return r = a, !0
    }), r
}

function Yl(e) {
    return (t, r) => Qs(e, t) - Qs(e, r)
}
const Zh = (e, t, r) => {
    if (typeof e != "string") return e;
    let n = e;
    try {
        n = JSON.parse(e)
    } catch {}
    return r.isType(n) ? n : e
};

function Vn(e) {
    if ("fields" in e) {
        const t = {};
        for (const [r, n] of Object.entries(e.fields)) t[r] = Vn(n);
        return e.setFields(t)
    }
    if (e.type === "array") {
        const t = e.optional();
        return t.innerType && (t.innerType = Vn(t.innerType)), t
    }
    return e.type === "tuple" ? e.optional().clone({
        types: e.spec.types.map(Vn)
    }) : "optional" in e ? e.optional() : e
}
const Gh = (e, t) => {
    const r = [...Or.normalizePath(t)];
    if (r.length === 1) return r[0] in e;
    let n = r.pop(),
        a = Or.getter(Or.join(r), !0)(e);
    return !!(a && n in a)
};
let Ks = e => Object.prototype.toString.call(e) === "[object Object]";

function Qh(e, t) {
    let r = Object.keys(e.fields);
    return Object.keys(t).filter(n => r.indexOf(n) === -1)
}
const Kh = Yl([]);

function ql(e) {
    return new Wl(e)
}
class Wl extends Et {
    constructor(t) {
        super({
            type: "object",
            check(r) {
                return Ks(r) || typeof r == "function"
            }
        }), this.fields = Object.create(null), this._sortErrors = Kh, this._nodes = [], this._excludedEdges = [], this.withMutation(() => {
            t && this.shape(t)
        })
    }
    _cast(t, r = {}) {
        var n;
        let a = super._cast(t, r);
        if (a === void 0) return this.getDefault(r);
        if (!this._typeCheck(a)) return a;
        let i = this.fields,
            s = (n = r.stripUnknown) != null ? n : this.spec.noUnknown,
            o = [].concat(this._nodes, Object.keys(a).filter(d => !this._nodes.includes(d))),
            l = {},
            u = Object.assign({}, r, {
                parent: l,
                __validating: r.__validating || !1
            }),
            c = !1;
        for (const d of o) {
            let h = i[d],
                g = d in a;
            if (h) {
                let y, k = a[d];
                u.path = (r.path ? `${r.path}.` : "") + d, h = h.resolve({
                    value: k,
                    context: r.context,
                    parent: l
                });
                let O = h instanceof Et ? h.spec : void 0,
                    U = O == null ? void 0 : O.strict;
                if (O != null && O.strip) {
                    c = c || d in a;
                    continue
                }
                y = !r.__validating || !U ? h.cast(a[d], u) : a[d], y !== void 0 && (l[d] = y)
            } else g && !s && (l[d] = a[d]);
            (g !== d in l || l[d] !== a[d]) && (c = !0)
        }
        return c ? l : a
    }
    _validate(t, r = {}, n, a) {
        let {
            from: i = [],
            originalValue: s = t,
            recursive: o = this.spec.recursive
        } = r;
        r.from = [{
            schema: this,
            value: s
        }, ...i], r.__validating = !0, r.originalValue = s, super._validate(t, r, n, (l, u) => {
            if (!o || !Ks(u)) {
                a(l, u);
                return
            }
            s = s || u;
            let c = [];
            for (let d of this._nodes) {
                let h = this.fields[d];
                !h || Fr.isRef(h) || c.push(h.asNestedTest({
                    options: r,
                    key: d,
                    parent: u,
                    parentPath: r.path,
                    originalParent: s
                }))
            }
            this.runTests({
                tests: c,
                value: u,
                originalValue: s,
                options: r
            }, n, d => {
                a(d.sort(this._sortErrors).concat(l), u)
            })
        })
    }
    clone(t) {
        const r = super.clone(t);
        return r.fields = Object.assign({}, this.fields), r._nodes = this._nodes, r._excludedEdges = this._excludedEdges, r._sortErrors = this._sortErrors, r
    }
    concat(t) {
        let r = super.concat(t),
            n = r.fields;
        for (let [a, i] of Object.entries(this.fields)) {
            const s = n[a];
            n[a] = s === void 0 ? i : s
        }
        return r.withMutation(a => a.setFields(n, [...this._excludedEdges, ...t._excludedEdges]))
    }
    _getDefault(t) {
        if ("default" in this.spec) return super._getDefault(t);
        if (!this._nodes.length) return;
        let r = {};
        return this._nodes.forEach(n => {
            var a;
            const i = this.fields[n];
            let s = t;
            (a = s) != null && a.value && (s = Object.assign({}, s, {
                parent: s.value,
                value: s.value[n]
            })), r[n] = i && "getDefault" in i ? i.getDefault(s) : void 0
        }), r
    }
    setFields(t, r) {
        let n = this.clone();
        return n.fields = t, n._nodes = zh(t, r), n._sortErrors = Yl(Object.keys(t)), r && (n._excludedEdges = r), n
    }
    shape(t, r = []) {
        return this.clone().withMutation(n => {
            let a = n._excludedEdges;
            return r.length && (Array.isArray(r[0]) || (r = [r]), a = [...n._excludedEdges, ...r]), n.setFields(Object.assign(n.fields, t), a)
        })
    }
    partial() {
        const t = {};
        for (const [r, n] of Object.entries(this.fields)) t[r] = "optional" in n && n.optional instanceof Function ? n.optional() : n;
        return this.setFields(t)
    }
    deepPartial() {
        return Vn(this)
    }
    pick(t) {
        const r = {};
        for (const n of t) this.fields[n] && (r[n] = this.fields[n]);
        return this.setFields(r, this._excludedEdges.filter(([n, a]) => t.includes(n) && t.includes(a)))
    }
    omit(t) {
        const r = [];
        for (const n of Object.keys(this.fields)) t.includes(n) || r.push(n);
        return this.pick(r)
    }
    from(t, r, n) {
        let a = Or.getter(t, !0);
        return this.transform(i => {
            if (!i) return i;
            let s = i;
            return Gh(i, t) && (s = Object.assign({}, i), n || delete s[t], s[r] = a(i)), s
        })
    }
    json() {
        return this.transform(Zh)
    }
    noUnknown(t = !0, r = di.noUnknown) {
        typeof t != "boolean" && (r = t, t = !0);
        let n = this.test({
            name: "noUnknown",
            exclusive: !0,
            message: r,
            test(a) {
                if (a == null) return !0;
                const i = Qh(this.schema, a);
                return !t || i.length === 0 || this.createError({
                    params: {
                        unknown: i.join(", ")
                    }
                })
            }
        });
        return n.spec.noUnknown = t, n
    }
    unknown(t = !0, r = di.noUnknown) {
        return this.noUnknown(!t, r)
    }
    transformKeys(t) {
        return this.transform(r => {
            if (!r) return r;
            const n = {};
            for (const a of Object.keys(r)) n[t(a)] = r[a];
            return n
        })
    }
    camelCase() {
        return this.transformKeys(qa.camelCase)
    }
    snakeCase() {
        return this.transformKeys(qa.snakeCase)
    }
    constantCase() {
        return this.transformKeys(t => qa.snakeCase(t).toUpperCase())
    }
    describe(t) {
        const r = (t ? this.resolve(t) : this).clone(),
            n = super.describe(t);
        n.fields = {};
        for (const [i, s] of Object.entries(r.fields)) {
            var a;
            let o = t;
            (a = o) != null && a.value && (o = Object.assign({}, o, {
                parent: o.value,
                value: o.value[i]
            })), n.fields[i] = s.describe(o)
        }
        return n
    }
}
ql.prototype = Wl.prototype;
const Xs = ["4r5e", "5h1t", "5hit", "a55", "anal", "anus", "ar5e", "arrse", "arse", "ass", "ass-fucker", "asses", "assfucker", "assfukka", "asshole", "assholes", "asswhole", "a_s_s", "b!tch", "b00bs", "b17ch", "b1tch", "ballbag", "balls", "ballsack", "bastard", "beastial", "beastiality", "bellend", "bestial", "bestiality", "bi+ch", "biatch", "bitch", "bitcher", "bitchers", "bitches", "bitchin", "bitching", "bloody", "blow job", "blowjob", "blowjobs", "boiolas", "bollock", "bollok", "boner", "boob", "boobs", "booobs", "boooobs", "booooobs", "booooooobs", "breasts", "buceta", "bugger", "bum", "bunny fucker", "butt", "butthole", "buttmuch", "buttplug", "c0ck", "c0cksucker", "carpet muncher", "cawk", "chink", "cipa", "cl1t", "clit", "clitoris", "clits", "cnut", "cock", "cock-sucker", "cockface", "cockhead", "cockmunch", "cockmuncher", "cocks", "cocksuck", "cocksucked", "cocksucker", "cocksucking", "cocksucks", "cocksuka", "cocksukka", "cok", "cokmuncher", "coksucka", "coon", "cox", "crap", "cum", "cummer", "cumming", "cums", "cumshot", "cunilingus", "cunillingus", "cunnilingus", "cunt", "cuntlick", "cuntlicker", "cuntlicking", "cunts", "cyalis", "cyberfuc", "cyberfuck", "cyberfucked", "cyberfucker", "cyberfuckers", "cyberfucking", "d1ck", "damn", "dick", "dickhead", "dildo", "dildos", "dink", "dinks", "dirsa", "dlck", "dog-fucker", "doggin", "dogging", "donkeyribber", "doosh", "duche", "dyke", "ejaculate", "ejaculated", "ejaculates", "ejaculating", "ejaculatings", "ejaculation", "ejakulate", "f u c k", "f u c k e r", "f4nny", "fag", "fagging", "faggitt", "faggot", "faggs", "fagot", "fagots", "fags", "fanny", "fannyflaps", "fannyfucker", "fanyy", "fatass", "fcuk", "fcuker", "fcuking", "feck", "fecker", "felching", "fellate", "fellatio", "fingerfuck", "fingerfucked", "fingerfucker", "fingerfuckers", "fingerfucking", "fingerfucks", "fistfuck", "fistfucked", "fistfucker", "fistfuckers", "fistfucking", "fistfuckings", "fistfucks", "flange", "fook", "fooker", "fuck", "fucka", "fucked", "fucker", "fuckers", "fuckhead", "fuckheads", "fuckin", "fucking", "fuckings", "fuckingshitmotherfucker", "fuckme", "fucks", "fuckwhit", "fuckwit", "fudge packer", "fudgepacker", "fuk", "fuker", "fukker", "fukkin", "fuks", "fukwhit", "fukwit", "fux", "fux0r", "f_u_c_k", "gangbang", "gangbanged", "gangbangs", "gaylord", "gaysex", "goatse", "God", "god-dam", "god-damned", "goddamn", "goddamned", "hardcoresex", "hell", "heshe", "hoar", "hoare", "hoer", "homo", "hore", "horniest", "horny", "hotsex", "jack-off", "jackoff", "jap", "jerk-off", "jism", "jiz", "jizm", "jizz", "kawk", "knob", "knobead", "knobed", "knobend", "knobhead", "knobjocky", "knobjokey", "kock", "kondum", "kondums", "kum", "kummer", "kumming", "kums", "kunilingus", "l3i+ch", "l3itch", "labia", "lust", "lusting", "m0f0", "m0fo", "m45terbate", "ma5terb8", "ma5terbate", "masochist", "master-bate", "masterb8", "masterbat*", "masterbat3", "masterbate", "masterbation", "masterbations", "masturbate", "mo-fo", "mof0", "mofo", "mothafuck", "mothafucka", "mothafuckas", "mothafuckaz", "mothafucked", "mothafucker", "mothafuckers", "mothafuckin", "mothafucking", "mothafuckings", "mothafucks", "mother fucker", "motherfuck", "motherfucked", "motherfucker", "motherfuckers", "motherfuckin", "motherfucking", "motherfuckings", "motherfuckka", "motherfucks", "muff", "mutha", "muthafecker", "muthafuckker", "muther", "mutherfucker", "n1gga", "n1gger", "nazi", "nigg3r", "nigg4h", "nigga", "niggah", "niggas", "niggaz", "nigger", "niggers", "nob", "nob jokey", "nobhead", "nobjocky", "nobjokey", "numbnuts", "nutsack", "orgasim", "orgasims", "orgasm", "orgasms", "p0rn", "pawn", "pecker", "penis", "penisfucker", "phonesex", "phuck", "phuk", "phuked", "phuking", "phukked", "phukking", "phuks", "phuq", "pigfucker", "pimpis", "piss", "pissed", "pisser", "pissers", "pisses", "pissflaps", "pissin", "pissing", "pissoff", "poop", "porn", "porno", "pornography", "pornos", "prick", "pricks", "pron", "pube", "pusse", "pussi", "pussies", "pussy", "pussys", "rectum", "retard", "rimjaw", "rimming", "s hit", "s.o.b.", "sadist", "schlong", "screwing", "scroat", "scrote", "scrotum", "semen", "sex", "sh!+", "sh!t", "sh1t", "shag", "shagger", "shaggin", "shagging", "shemale", "shi+", "shit", "shitdick", "shite", "shited", "shitey", "shitfuck", "shitfull", "shithead", "shiting", "shitings", "shits", "shitted", "shitter", "shitters", "shitting", "shittings", "shitty", "skank", "slut", "sluts", "smegma", "smut", "snatch", "son-of-a-bitch", "spac", "spunk", "s_h_i_t", "t1tt1e5", "t1tties", "teets", "teez", "testical", "testicle", "tit", "titfuck", "tits", "titt", "tittie5", "tittiefucker", "titties", "tittyfuck", "tittywank", "titwank", "tosser", "turd", "tw4t", "twat", "twathead", "twatty", "twunt", "twunter", "v14gra", "v1gra", "vagina", "viagra", "vulva", "w00se", "wang", "wank", "wanker", "wanky", "whoar", "whore", "willies", "willy", "xrated", "xxx"];

function kt(e) {
    "@babel/helpers - typeof";
    return kt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
        return typeof t
    } : function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
    }, kt(e)
}

function Fe(e) {
    if (e === null || e === !0 || e === !1) return NaN;
    var t = Number(e);
    return isNaN(t) ? t : t < 0 ? Math.ceil(t) : Math.floor(t)
}

function Q(e, t) {
    if (t.length < e) throw new TypeError(e + " argument" + (e > 1 ? "s" : "") + " required, but only " + t.length + " present")
}

function Z(e) {
    Q(1, arguments);
    var t = Object.prototype.toString.call(e);
    return e instanceof Date || kt(e) === "object" && t === "[object Date]" ? new Date(e.getTime()) : typeof e == "number" || t === "[object Number]" ? new Date(e) : ((typeof e == "string" || t === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), new Date(NaN))
}

function Xh(e, t) {
    Q(2, arguments);
    var r = Z(e),
        n = Fe(t);
    return isNaN(n) ? new Date(NaN) : (n && r.setDate(r.getDate() + n), r)
}

function Zi(e, t) {
    Q(2, arguments);
    var r = Z(e),
        n = Fe(t);
    if (isNaN(n)) return new Date(NaN);
    if (!n) return r;
    var a = r.getDate(),
        i = new Date(r.getTime());
    i.setMonth(r.getMonth() + n + 1, 0);
    var s = i.getDate();
    return a >= s ? i : (r.setFullYear(i.getFullYear(), i.getMonth(), a), r)
}

function Jh(e, t) {
    Q(2, arguments);
    var r = Z(e).getTime(),
        n = Fe(t);
    return new Date(r + n)
}
var em = {};

function zt() {
    return em
}

function tm(e, t) {
    var r, n, a, i, s, o, l, u;
    Q(1, arguments);
    var c = zt(),
        d = Fe((r = (n = (a = (i = t == null ? void 0 : t.weekStartsOn) !== null && i !== void 0 ? i : t == null || (s = t.locale) === null || s === void 0 || (o = s.options) === null || o === void 0 ? void 0 : o.weekStartsOn) !== null && a !== void 0 ? a : c.weekStartsOn) !== null && n !== void 0 ? n : (l = c.locale) === null || l === void 0 || (u = l.options) === null || u === void 0 ? void 0 : u.weekStartsOn) !== null && r !== void 0 ? r : 0);
    if (!(d >= 0 && d <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var h = Z(e),
        g = h.getDay(),
        y = (g < d ? 7 : 0) + g - d;
    return h.setDate(h.getDate() - y), h.setHours(0, 0, 0, 0), h
}

function Hl(e) {
    var t = new Date(Date.UTC(e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
    return t.setUTCFullYear(e.getFullYear()), e.getTime() - t.getTime()
}

function mi(e) {
    Q(1, arguments);
    var t = Z(e);
    return t.setHours(0, 0, 0, 0), t
}

function Gi(e, t) {
    Q(2, arguments);
    var r = Fe(t);
    return Zi(e, r * 12)
}

function rm(e) {
    Q(1, arguments);
    var t;
    if (e && typeof e.forEach == "function") t = e;
    else if (kt(e) === "object" && e !== null) t = Array.prototype.slice.call(e);
    else return new Date(NaN);
    var r;
    return t.forEach(function(n) {
        var a = Z(n);
        (r === void 0 || r < a || isNaN(Number(a))) && (r = a)
    }), r || new Date(NaN)
}

function nm(e) {
    Q(1, arguments);
    var t;
    if (e && typeof e.forEach == "function") t = e;
    else if (kt(e) === "object" && e !== null) t = Array.prototype.slice.call(e);
    else return new Date(NaN);
    var r;
    return t.forEach(function(n) {
        var a = Z(n);
        (r === void 0 || r > a || isNaN(a.getDate())) && (r = a)
    }), r || new Date(NaN)
}
var am = 6e4,
    im = 36e5,
    sm = 1e3;

function Wa(e, t) {
    Q(2, arguments);
    var r = mi(e),
        n = mi(t);
    return r.getTime() === n.getTime()
}

function om(e) {
    return Q(1, arguments), e instanceof Date || kt(e) === "object" && Object.prototype.toString.call(e) === "[object Date]"
}

function yt(e) {
    if (Q(1, arguments), !om(e) && typeof e != "number") return !1;
    var t = Z(e);
    return !isNaN(Number(t))
}

function lm(e) {
    Q(1, arguments);
    var t = Z(e);
    return t.setHours(23, 59, 59, 999), t
}

function Bl(e) {
    Q(1, arguments);
    var t = Z(e),
        r = t.getMonth();
    return t.setFullYear(t.getFullYear(), r + 1, 0), t.setHours(23, 59, 59, 999), t
}

function um(e, t) {
    var r;
    Q(1, arguments);
    var n = e || {},
        a = Z(n.start),
        i = Z(n.end),
        s = i.getTime();
    if (!(a.getTime() <= s)) throw new RangeError("Invalid interval");
    var o = [],
        l = a;
    l.setHours(0, 0, 0, 0);
    var u = Number((r = t == null ? void 0 : t.step) !== null && r !== void 0 ? r : 1);
    if (u < 1 || isNaN(u)) throw new RangeError("`options.step` must be a number greater than 1");
    for (; l.getTime() <= s;) o.push(Z(l)), l.setDate(l.getDate() + u), l.setHours(0, 0, 0, 0);
    return o
}

function Js(e) {
    Q(1, arguments);
    var t = Z(e);
    return t.setSeconds(0, 0), t
}

function cm(e) {
    Q(1, arguments);
    var t = e || {},
        r = Z(t.start),
        n = Z(t.end),
        a = n.getTime(),
        i = [];
    if (!(r.getTime() <= a)) throw new RangeError("Invalid interval");
    var s = r;
    for (s.setHours(0, 0, 0, 0), s.setDate(1); s.getTime() <= a;) i.push(Z(s)), s.setMonth(s.getMonth() + 1);
    return i
}

function zl(e) {
    Q(1, arguments);
    var t = Z(e);
    return t.setDate(1), t.setHours(0, 0, 0, 0), t
}

function dm(e) {
    Q(1, arguments);
    var t = Z(e),
        r = t.getFullYear();
    return t.setFullYear(r + 1, 0, 0), t.setHours(23, 59, 59, 999), t
}

function fm(e) {
    Q(1, arguments);
    var t = Z(e),
        r = new Date(0);
    return r.setFullYear(t.getFullYear(), 0, 1), r.setHours(0, 0, 0, 0), r
}

function hm(e) {
    Q(1, arguments);
    var t = e || {},
        r = Z(t.start),
        n = Z(t.end),
        a = n.getTime();
    if (!(r.getTime() <= a)) throw new RangeError("Invalid interval");
    var i = [],
        s = r;
    for (s.setHours(0, 0, 0, 0), s.setMonth(0, 1); s.getTime() <= a;) i.push(Z(s)), s.setFullYear(s.getFullYear() + 1);
    return i
}

function mm(e) {
    Q(1, arguments);
    var t = Z(e),
        r = t.getFullYear(),
        n = 9 + Math.floor(r / 10) * 10;
    return t.setFullYear(n, 11, 31), t.setHours(23, 59, 59, 999), t
}

function vm(e, t) {
    var r, n, a, i, s, o, l, u;
    Q(1, arguments);
    var c = zt(),
        d = Fe((r = (n = (a = (i = t == null ? void 0 : t.weekStartsOn) !== null && i !== void 0 ? i : t == null || (s = t.locale) === null || s === void 0 || (o = s.options) === null || o === void 0 ? void 0 : o.weekStartsOn) !== null && a !== void 0 ? a : c.weekStartsOn) !== null && n !== void 0 ? n : (l = c.locale) === null || l === void 0 || (u = l.options) === null || u === void 0 ? void 0 : u.weekStartsOn) !== null && r !== void 0 ? r : 0);
    if (!(d >= 0 && d <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var h = Z(e),
        g = h.getDay(),
        y = (g < d ? -7 : 0) + 6 - (g - d);
    return h.setDate(h.getDate() + y), h.setHours(23, 59, 59, 999), h
}

function Zl(e, t) {
    Q(2, arguments);
    var r = Fe(t);
    return Jh(e, -r)
}
var pm = 864e5;

function gm(e) {
    Q(1, arguments);
    var t = Z(e),
        r = t.getTime();
    t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0);
    var n = t.getTime(),
        a = r - n;
    return Math.floor(a / pm) + 1
}

function Hr(e) {
    Q(1, arguments);
    var t = 1,
        r = Z(e),
        n = r.getUTCDay(),
        a = (n < t ? 7 : 0) + n - t;
    return r.setUTCDate(r.getUTCDate() - a), r.setUTCHours(0, 0, 0, 0), r
}

function Gl(e) {
    Q(1, arguments);
    var t = Z(e),
        r = t.getUTCFullYear(),
        n = new Date(0);
    n.setUTCFullYear(r + 1, 0, 4), n.setUTCHours(0, 0, 0, 0);
    var a = Hr(n),
        i = new Date(0);
    i.setUTCFullYear(r, 0, 4), i.setUTCHours(0, 0, 0, 0);
    var s = Hr(i);
    return t.getTime() >= a.getTime() ? r + 1 : t.getTime() >= s.getTime() ? r : r - 1
}

function ym(e) {
    Q(1, arguments);
    var t = Gl(e),
        r = new Date(0);
    r.setUTCFullYear(t, 0, 4), r.setUTCHours(0, 0, 0, 0);
    var n = Hr(r);
    return n
}
var bm = 6048e5;

function Ql(e) {
    Q(1, arguments);
    var t = Z(e),
        r = Hr(t).getTime() - ym(t).getTime();
    return Math.round(r / bm) + 1
}

function Sr(e, t) {
    var r, n, a, i, s, o, l, u;
    Q(1, arguments);
    var c = zt(),
        d = Fe((r = (n = (a = (i = t == null ? void 0 : t.weekStartsOn) !== null && i !== void 0 ? i : t == null || (s = t.locale) === null || s === void 0 || (o = s.options) === null || o === void 0 ? void 0 : o.weekStartsOn) !== null && a !== void 0 ? a : c.weekStartsOn) !== null && n !== void 0 ? n : (l = c.locale) === null || l === void 0 || (u = l.options) === null || u === void 0 ? void 0 : u.weekStartsOn) !== null && r !== void 0 ? r : 0);
    if (!(d >= 0 && d <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var h = Z(e),
        g = h.getUTCDay(),
        y = (g < d ? 7 : 0) + g - d;
    return h.setUTCDate(h.getUTCDate() - y), h.setUTCHours(0, 0, 0, 0), h
}

function Qi(e, t) {
    var r, n, a, i, s, o, l, u;
    Q(1, arguments);
    var c = Z(e),
        d = c.getUTCFullYear(),
        h = zt(),
        g = Fe((r = (n = (a = (i = t == null ? void 0 : t.firstWeekContainsDate) !== null && i !== void 0 ? i : t == null || (s = t.locale) === null || s === void 0 || (o = s.options) === null || o === void 0 ? void 0 : o.firstWeekContainsDate) !== null && a !== void 0 ? a : h.firstWeekContainsDate) !== null && n !== void 0 ? n : (l = h.locale) === null || l === void 0 || (u = l.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && r !== void 0 ? r : 1);
    if (!(g >= 1 && g <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var y = new Date(0);
    y.setUTCFullYear(d + 1, 0, g), y.setUTCHours(0, 0, 0, 0);
    var k = Sr(y, t),
        O = new Date(0);
    O.setUTCFullYear(d, 0, g), O.setUTCHours(0, 0, 0, 0);
    var U = Sr(O, t);
    return c.getTime() >= k.getTime() ? d + 1 : c.getTime() >= U.getTime() ? d : d - 1
}

function wm(e, t) {
    var r, n, a, i, s, o, l, u;
    Q(1, arguments);
    var c = zt(),
        d = Fe((r = (n = (a = (i = t == null ? void 0 : t.firstWeekContainsDate) !== null && i !== void 0 ? i : t == null || (s = t.locale) === null || s === void 0 || (o = s.options) === null || o === void 0 ? void 0 : o.firstWeekContainsDate) !== null && a !== void 0 ? a : c.firstWeekContainsDate) !== null && n !== void 0 ? n : (l = c.locale) === null || l === void 0 || (u = l.options) === null || u === void 0 ? void 0 : u.firstWeekContainsDate) !== null && r !== void 0 ? r : 1),
        h = Qi(e, t),
        g = new Date(0);
    g.setUTCFullYear(h, 0, d), g.setUTCHours(0, 0, 0, 0);
    var y = Sr(g, t);
    return y
}
var _m = 6048e5;

function Kl(e, t) {
    Q(1, arguments);
    var r = Z(e),
        n = Sr(r, t).getTime() - wm(r, t).getTime();
    return Math.round(n / _m) + 1
}

function Pe(e, t) {
    for (var r = e < 0 ? "-" : "", n = Math.abs(e).toString(); n.length < t;) n = "0" + n;
    return r + n
}
var xm = {
    y: function(t, r) {
        var n = t.getUTCFullYear(),
            a = n > 0 ? n : 1 - n;
        return Pe(r === "yy" ? a % 100 : a, r.length)
    },
    M: function(t, r) {
        var n = t.getUTCMonth();
        return r === "M" ? String(n + 1) : Pe(n + 1, 2)
    },
    d: function(t, r) {
        return Pe(t.getUTCDate(), r.length)
    },
    a: function(t, r) {
        var n = t.getUTCHours() / 12 >= 1 ? "pm" : "am";
        switch (r) {
            case "a":
            case "aa":
                return n.toUpperCase();
            case "aaa":
                return n;
            case "aaaaa":
                return n[0];
            case "aaaa":
            default:
                return n === "am" ? "a.m." : "p.m."
        }
    },
    h: function(t, r) {
        return Pe(t.getUTCHours() % 12 || 12, r.length)
    },
    H: function(t, r) {
        return Pe(t.getUTCHours(), r.length)
    },
    m: function(t, r) {
        return Pe(t.getUTCMinutes(), r.length)
    },
    s: function(t, r) {
        return Pe(t.getUTCSeconds(), r.length)
    },
    S: function(t, r) {
        var n = r.length,
            a = t.getUTCMilliseconds(),
            i = Math.floor(a * Math.pow(10, n - 3));
        return Pe(i, r.length)
    }
};
const Qt = xm;
var Ar = {
        am: "am",
        pm: "pm",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    km = {
        G: function(t, r, n) {
            var a = t.getUTCFullYear() > 0 ? 1 : 0;
            switch (r) {
                case "G":
                case "GG":
                case "GGG":
                    return n.era(a, {
                        width: "abbreviated"
                    });
                case "GGGGG":
                    return n.era(a, {
                        width: "narrow"
                    });
                case "GGGG":
                default:
                    return n.era(a, {
                        width: "wide"
                    })
            }
        },
        y: function(t, r, n) {
            if (r === "yo") {
                var a = t.getUTCFullYear(),
                    i = a > 0 ? a : 1 - a;
                return n.ordinalNumber(i, {
                    unit: "year"
                })
            }
            return Qt.y(t, r)
        },
        Y: function(t, r, n, a) {
            var i = Qi(t, a),
                s = i > 0 ? i : 1 - i;
            if (r === "YY") {
                var o = s % 100;
                return Pe(o, 2)
            }
            return r === "Yo" ? n.ordinalNumber(s, {
                unit: "year"
            }) : Pe(s, r.length)
        },
        R: function(t, r) {
            var n = Gl(t);
            return Pe(n, r.length)
        },
        u: function(t, r) {
            var n = t.getUTCFullYear();
            return Pe(n, r.length)
        },
        Q: function(t, r, n) {
            var a = Math.ceil((t.getUTCMonth() + 1) / 3);
            switch (r) {
                case "Q":
                    return String(a);
                case "QQ":
                    return Pe(a, 2);
                case "Qo":
                    return n.ordinalNumber(a, {
                        unit: "quarter"
                    });
                case "QQQ":
                    return n.quarter(a, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "QQQQQ":
                    return n.quarter(a, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "QQQQ":
                default:
                    return n.quarter(a, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        q: function(t, r, n) {
            var a = Math.ceil((t.getUTCMonth() + 1) / 3);
            switch (r) {
                case "q":
                    return String(a);
                case "qq":
                    return Pe(a, 2);
                case "qo":
                    return n.ordinalNumber(a, {
                        unit: "quarter"
                    });
                case "qqq":
                    return n.quarter(a, {
                        width: "abbreviated",
                        context: "standalone"
                    });
                case "qqqqq":
                    return n.quarter(a, {
                        width: "narrow",
                        context: "standalone"
                    });
                case "qqqq":
                default:
                    return n.quarter(a, {
                        width: "wide",
                        context: "standalone"
                    })
            }
        },
        M: function(t, r, n) {
            var a = t.getUTCMonth();
            switch (r) {
                case "M":
                case "MM":
                    return Qt.M(t, r);
                case "Mo":
                    return n.ordinalNumber(a + 1, {
                        unit: "month"
                    });
                case "MMM":
                    return n.month(a, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "MMMMM":
                    return n.month(a, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "MMMM":
                default:
                    return n.month(a, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        L: function(t, r, n) {
            var a = t.getUTCMonth();
            switch (r) {
                case "L":
                    return String(a + 1);
                case "LL":
                    return Pe(a + 1, 2);
                case "Lo":
                    return n.ordinalNumber(a + 1, {
                        unit: "month"
                    });
                case "LLL":
                    return n.month(a, {
                        width: "abbreviated",
                        context: "standalone"
                    });
                case "LLLLL":
                    return n.month(a, {
                        width: "narrow",
                        context: "standalone"
                    });
                case "LLLL":
                default:
                    return n.month(a, {
                        width: "wide",
                        context: "standalone"
                    })
            }
        },
        w: function(t, r, n, a) {
            var i = Kl(t, a);
            return r === "wo" ? n.ordinalNumber(i, {
                unit: "week"
            }) : Pe(i, r.length)
        },
        I: function(t, r, n) {
            var a = Ql(t);
            return r === "Io" ? n.ordinalNumber(a, {
                unit: "week"
            }) : Pe(a, r.length)
        },
        d: function(t, r, n) {
            return r === "do" ? n.ordinalNumber(t.getUTCDate(), {
                unit: "date"
            }) : Qt.d(t, r)
        },
        D: function(t, r, n) {
            var a = gm(t);
            return r === "Do" ? n.ordinalNumber(a, {
                unit: "dayOfYear"
            }) : Pe(a, r.length)
        },
        E: function(t, r, n) {
            var a = t.getUTCDay();
            switch (r) {
                case "E":
                case "EE":
                case "EEE":
                    return n.day(a, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "EEEEE":
                    return n.day(a, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "EEEEEE":
                    return n.day(a, {
                        width: "short",
                        context: "formatting"
                    });
                case "EEEE":
                default:
                    return n.day(a, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        e: function(t, r, n, a) {
            var i = t.getUTCDay(),
                s = (i - a.weekStartsOn + 8) % 7 || 7;
            switch (r) {
                case "e":
                    return String(s);
                case "ee":
                    return Pe(s, 2);
                case "eo":
                    return n.ordinalNumber(s, {
                        unit: "day"
                    });
                case "eee":
                    return n.day(i, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "eeeee":
                    return n.day(i, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "eeeeee":
                    return n.day(i, {
                        width: "short",
                        context: "formatting"
                    });
                case "eeee":
                default:
                    return n.day(i, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        c: function(t, r, n, a) {
            var i = t.getUTCDay(),
                s = (i - a.weekStartsOn + 8) % 7 || 7;
            switch (r) {
                case "c":
                    return String(s);
                case "cc":
                    return Pe(s, r.length);
                case "co":
                    return n.ordinalNumber(s, {
                        unit: "day"
                    });
                case "ccc":
                    return n.day(i, {
                        width: "abbreviated",
                        context: "standalone"
                    });
                case "ccccc":
                    return n.day(i, {
                        width: "narrow",
                        context: "standalone"
                    });
                case "cccccc":
                    return n.day(i, {
                        width: "short",
                        context: "standalone"
                    });
                case "cccc":
                default:
                    return n.day(i, {
                        width: "wide",
                        context: "standalone"
                    })
            }
        },
        i: function(t, r, n) {
            var a = t.getUTCDay(),
                i = a === 0 ? 7 : a;
            switch (r) {
                case "i":
                    return String(i);
                case "ii":
                    return Pe(i, r.length);
                case "io":
                    return n.ordinalNumber(i, {
                        unit: "day"
                    });
                case "iii":
                    return n.day(a, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "iiiii":
                    return n.day(a, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "iiiiii":
                    return n.day(a, {
                        width: "short",
                        context: "formatting"
                    });
                case "iiii":
                default:
                    return n.day(a, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        a: function(t, r, n) {
            var a = t.getUTCHours(),
                i = a / 12 >= 1 ? "pm" : "am";
            switch (r) {
                case "a":
                case "aa":
                    return n.dayPeriod(i, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "aaa":
                    return n.dayPeriod(i, {
                        width: "abbreviated",
                        context: "formatting"
                    }).toLowerCase();
                case "aaaaa":
                    return n.dayPeriod(i, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "aaaa":
                default:
                    return n.dayPeriod(i, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        b: function(t, r, n) {
            var a = t.getUTCHours(),
                i;
            switch (a === 12 ? i = Ar.noon : a === 0 ? i = Ar.midnight : i = a / 12 >= 1 ? "pm" : "am", r) {
                case "b":
                case "bb":
                    return n.dayPeriod(i, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "bbb":
                    return n.dayPeriod(i, {
                        width: "abbreviated",
                        context: "formatting"
                    }).toLowerCase();
                case "bbbbb":
                    return n.dayPeriod(i, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "bbbb":
                default:
                    return n.dayPeriod(i, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        B: function(t, r, n) {
            var a = t.getUTCHours(),
                i;
            switch (a >= 17 ? i = Ar.evening : a >= 12 ? i = Ar.afternoon : a >= 4 ? i = Ar.morning : i = Ar.night, r) {
                case "B":
                case "BB":
                case "BBB":
                    return n.dayPeriod(i, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "BBBBB":
                    return n.dayPeriod(i, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "BBBB":
                default:
                    return n.dayPeriod(i, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        h: function(t, r, n) {
            if (r === "ho") {
                var a = t.getUTCHours() % 12;
                return a === 0 && (a = 12), n.ordinalNumber(a, {
                    unit: "hour"
                })
            }
            return Qt.h(t, r)
        },
        H: function(t, r, n) {
            return r === "Ho" ? n.ordinalNumber(t.getUTCHours(), {
                unit: "hour"
            }) : Qt.H(t, r)
        },
        K: function(t, r, n) {
            var a = t.getUTCHours() % 12;
            return r === "Ko" ? n.ordinalNumber(a, {
                unit: "hour"
            }) : Pe(a, r.length)
        },
        k: function(t, r, n) {
            var a = t.getUTCHours();
            return a === 0 && (a = 24), r === "ko" ? n.ordinalNumber(a, {
                unit: "hour"
            }) : Pe(a, r.length)
        },
        m: function(t, r, n) {
            return r === "mo" ? n.ordinalNumber(t.getUTCMinutes(), {
                unit: "minute"
            }) : Qt.m(t, r)
        },
        s: function(t, r, n) {
            return r === "so" ? n.ordinalNumber(t.getUTCSeconds(), {
                unit: "second"
            }) : Qt.s(t, r)
        },
        S: function(t, r) {
            return Qt.S(t, r)
        },
        X: function(t, r, n, a) {
            var i = a._originalDate || t,
                s = i.getTimezoneOffset();
            if (s === 0) return "Z";
            switch (r) {
                case "X":
                    return to(s);
                case "XXXX":
                case "XX":
                    return hr(s);
                case "XXXXX":
                case "XXX":
                default:
                    return hr(s, ":")
            }
        },
        x: function(t, r, n, a) {
            var i = a._originalDate || t,
                s = i.getTimezoneOffset();
            switch (r) {
                case "x":
                    return to(s);
                case "xxxx":
                case "xx":
                    return hr(s);
                case "xxxxx":
                case "xxx":
                default:
                    return hr(s, ":")
            }
        },
        O: function(t, r, n, a) {
            var i = a._originalDate || t,
                s = i.getTimezoneOffset();
            switch (r) {
                case "O":
                case "OO":
                case "OOO":
                    return "GMT" + eo(s, ":");
                case "OOOO":
                default:
                    return "GMT" + hr(s, ":")
            }
        },
        z: function(t, r, n, a) {
            var i = a._originalDate || t,
                s = i.getTimezoneOffset();
            switch (r) {
                case "z":
                case "zz":
                case "zzz":
                    return "GMT" + eo(s, ":");
                case "zzzz":
                default:
                    return "GMT" + hr(s, ":")
            }
        },
        t: function(t, r, n, a) {
            var i = a._originalDate || t,
                s = Math.floor(i.getTime() / 1e3);
            return Pe(s, r.length)
        },
        T: function(t, r, n, a) {
            var i = a._originalDate || t,
                s = i.getTime();
            return Pe(s, r.length)
        }
    };

function eo(e, t) {
    var r = e > 0 ? "-" : "+",
        n = Math.abs(e),
        a = Math.floor(n / 60),
        i = n % 60;
    if (i === 0) return r + String(a);
    var s = t || "";
    return r + String(a) + s + Pe(i, 2)
}

function to(e, t) {
    if (e % 60 === 0) {
        var r = e > 0 ? "-" : "+";
        return r + Pe(Math.abs(e) / 60, 2)
    }
    return hr(e, t)
}

function hr(e, t) {
    var r = t || "",
        n = e > 0 ? "-" : "+",
        a = Math.abs(e),
        i = Pe(Math.floor(a / 60), 2),
        s = Pe(a % 60, 2);
    return n + i + r + s
}
var ro = function(t, r) {
        switch (t) {
            case "P":
                return r.date({
                    width: "short"
                });
            case "PP":
                return r.date({
                    width: "medium"
                });
            case "PPP":
                return r.date({
                    width: "long"
                });
            case "PPPP":
            default:
                return r.date({
                    width: "full"
                })
        }
    },
    Xl = function(t, r) {
        switch (t) {
            case "p":
                return r.time({
                    width: "short"
                });
            case "pp":
                return r.time({
                    width: "medium"
                });
            case "ppp":
                return r.time({
                    width: "long"
                });
            case "pppp":
            default:
                return r.time({
                    width: "full"
                })
        }
    },
    Om = function(t, r) {
        var n = t.match(/(P+)(p+)?/) || [],
            a = n[1],
            i = n[2];
        if (!i) return ro(t, r);
        var s;
        switch (a) {
            case "P":
                s = r.dateTime({
                    width: "short"
                });
                break;
            case "PP":
                s = r.dateTime({
                    width: "medium"
                });
                break;
            case "PPP":
                s = r.dateTime({
                    width: "long"
                });
                break;
            case "PPPP":
            default:
                s = r.dateTime({
                    width: "full"
                });
                break
        }
        return s.replace("{{date}}", ro(a, r)).replace("{{time}}", Xl(i, r))
    },
    vi = {
        p: Xl,
        P: Om
    },
    Tm = ["D", "DD"],
    Cm = ["YY", "YYYY"];

function Jl(e) {
    return Tm.indexOf(e) !== -1
}

function eu(e) {
    return Cm.indexOf(e) !== -1
}

function Jn(e, t, r) {
    if (e === "YYYY") throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(t, "`) for formatting years to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "YY") throw new RangeError("Use `yy` instead of `YY` (in `".concat(t, "`) for formatting years to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "D") throw new RangeError("Use `d` instead of `D` (in `".concat(t, "`) for formatting days of the month to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    if (e === "DD") throw new RangeError("Use `dd` instead of `DD` (in `".concat(t, "`) for formatting days of the month to the input `").concat(r, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"))
}
var Dm = {
        lessThanXSeconds: {
            one: "less than a second",
            other: "less than {{count}} seconds"
        },
        xSeconds: {
            one: "1 second",
            other: "{{count}} seconds"
        },
        halfAMinute: "half a minute",
        lessThanXMinutes: {
            one: "less than a minute",
            other: "less than {{count}} minutes"
        },
        xMinutes: {
            one: "1 minute",
            other: "{{count}} minutes"
        },
        aboutXHours: {
            one: "about 1 hour",
            other: "about {{count}} hours"
        },
        xHours: {
            one: "1 hour",
            other: "{{count}} hours"
        },
        xDays: {
            one: "1 day",
            other: "{{count}} days"
        },
        aboutXWeeks: {
            one: "about 1 week",
            other: "about {{count}} weeks"
        },
        xWeeks: {
            one: "1 week",
            other: "{{count}} weeks"
        },
        aboutXMonths: {
            one: "about 1 month",
            other: "about {{count}} months"
        },
        xMonths: {
            one: "1 month",
            other: "{{count}} months"
        },
        aboutXYears: {
            one: "about 1 year",
            other: "about {{count}} years"
        },
        xYears: {
            one: "1 year",
            other: "{{count}} years"
        },
        overXYears: {
            one: "over 1 year",
            other: "over {{count}} years"
        },
        almostXYears: {
            one: "almost 1 year",
            other: "almost {{count}} years"
        }
    },
    Sm = function(t, r, n) {
        var a, i = Dm[t];
        return typeof i == "string" ? a = i : r === 1 ? a = i.one : a = i.other.replace("{{count}}", r.toString()), n != null && n.addSuffix ? n.comparison && n.comparison > 0 ? "in " + a : a + " ago" : a
    };
const Mm = Sm;

function Ha(e) {
    return function() {
        var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            r = t.width ? String(t.width) : e.defaultWidth,
            n = e.formats[r] || e.formats[e.defaultWidth];
        return n
    }
}
var Em = {
        full: "EEEE, MMMM do, y",
        long: "MMMM do, y",
        medium: "MMM d, y",
        short: "MM/dd/yyyy"
    },
    Pm = {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
    },
    $m = {
        full: "{{date}} 'at' {{time}}",
        long: "{{date}} 'at' {{time}}",
        medium: "{{date}}, {{time}}",
        short: "{{date}}, {{time}}"
    },
    Fm = {
        date: Ha({
            formats: Em,
            defaultWidth: "full"
        }),
        time: Ha({
            formats: Pm,
            defaultWidth: "full"
        }),
        dateTime: Ha({
            formats: $m,
            defaultWidth: "full"
        })
    };
const Lm = Fm;
var Am = {
        lastWeek: "'last' eeee 'at' p",
        yesterday: "'yesterday at' p",
        today: "'today at' p",
        tomorrow: "'tomorrow at' p",
        nextWeek: "eeee 'at' p",
        other: "P"
    },
    Nm = function(t, r, n, a) {
        return Am[t]
    };
const jm = Nm;

function Jr(e) {
    return function(t, r) {
        var n = r != null && r.context ? String(r.context) : "standalone",
            a;
        if (n === "formatting" && e.formattingValues) {
            var i = e.defaultFormattingWidth || e.defaultWidth,
                s = r != null && r.width ? String(r.width) : i;
            a = e.formattingValues[s] || e.formattingValues[i]
        } else {
            var o = e.defaultWidth,
                l = r != null && r.width ? String(r.width) : e.defaultWidth;
            a = e.values[l] || e.values[o]
        }
        var u = e.argumentCallback ? e.argumentCallback(t) : t;
        return a[u]
    }
}
var Im = {
        narrow: ["B", "A"],
        abbreviated: ["BC", "AD"],
        wide: ["Before Christ", "Anno Domini"]
    },
    Vm = {
        narrow: ["1", "2", "3", "4"],
        abbreviated: ["Q1", "Q2", "Q3", "Q4"],
        wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    },
    Rm = {
        narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
        abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    },
    Um = {
        narrow: ["S", "M", "T", "W", "T", "F", "S"],
        short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
    Ym = {
        narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        },
        abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        },
        wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        }
    },
    qm = {
        narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        },
        abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        },
        wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        }
    },
    Wm = function(t, r) {
        var n = Number(t),
            a = n % 100;
        if (a > 20 || a < 10) switch (a % 10) {
            case 1:
                return n + "st";
            case 2:
                return n + "nd";
            case 3:
                return n + "rd"
        }
        return n + "th"
    },
    Hm = {
        ordinalNumber: Wm,
        era: Jr({
            values: Im,
            defaultWidth: "wide"
        }),
        quarter: Jr({
            values: Vm,
            defaultWidth: "wide",
            argumentCallback: function(t) {
                return t - 1
            }
        }),
        month: Jr({
            values: Rm,
            defaultWidth: "wide"
        }),
        day: Jr({
            values: Um,
            defaultWidth: "wide"
        }),
        dayPeriod: Jr({
            values: Ym,
            defaultWidth: "wide",
            formattingValues: qm,
            defaultFormattingWidth: "wide"
        })
    };
const Bm = Hm;

function en(e) {
    return function(t) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            n = r.width,
            a = n && e.matchPatterns[n] || e.matchPatterns[e.defaultMatchWidth],
            i = t.match(a);
        if (!i) return null;
        var s = i[0],
            o = n && e.parsePatterns[n] || e.parsePatterns[e.defaultParseWidth],
            l = Array.isArray(o) ? Zm(o, function(d) {
                return d.test(s)
            }) : zm(o, function(d) {
                return d.test(s)
            }),
            u;
        u = e.valueCallback ? e.valueCallback(l) : l, u = r.valueCallback ? r.valueCallback(u) : u;
        var c = t.slice(s.length);
        return {
            value: u,
            rest: c
        }
    }
}

function zm(e, t) {
    for (var r in e)
        if (e.hasOwnProperty(r) && t(e[r])) return r
}

function Zm(e, t) {
    for (var r = 0; r < e.length; r++)
        if (t(e[r])) return r
}

function Gm(e) {
    return function(t) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
            n = t.match(e.matchPattern);
        if (!n) return null;
        var a = n[0],
            i = t.match(e.parsePattern);
        if (!i) return null;
        var s = e.valueCallback ? e.valueCallback(i[0]) : i[0];
        s = r.valueCallback ? r.valueCallback(s) : s;
        var o = t.slice(a.length);
        return {
            value: s,
            rest: o
        }
    }
}
var Qm = /^(\d+)(th|st|nd|rd)?/i,
    Km = /\d+/i,
    Xm = {
        narrow: /^(b|a)/i,
        abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
        wide: /^(before christ|before common era|anno domini|common era)/i
    },
    Jm = {
        any: [/^b/i, /^(a|c)/i]
    },
    e0 = {
        narrow: /^[1234]/i,
        abbreviated: /^q[1234]/i,
        wide: /^[1234](th|st|nd|rd)? quarter/i
    },
    t0 = {
        any: [/1/i, /2/i, /3/i, /4/i]
    },
    r0 = {
        narrow: /^[jfmasond]/i,
        abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
        wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    },
    n0 = {
        narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
        any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    },
    a0 = {
        narrow: /^[smtwf]/i,
        short: /^(su|mo|tu|we|th|fr|sa)/i,
        abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
        wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    },
    i0 = {
        narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
        any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    },
    s0 = {
        narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
        any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    },
    o0 = {
        any: {
            am: /^a/i,
            pm: /^p/i,
            midnight: /^mi/i,
            noon: /^no/i,
            morning: /morning/i,
            afternoon: /afternoon/i,
            evening: /evening/i,
            night: /night/i
        }
    },
    l0 = {
        ordinalNumber: Gm({
            matchPattern: Qm,
            parsePattern: Km,
            valueCallback: function(t) {
                return parseInt(t, 10)
            }
        }),
        era: en({
            matchPatterns: Xm,
            defaultMatchWidth: "wide",
            parsePatterns: Jm,
            defaultParseWidth: "any"
        }),
        quarter: en({
            matchPatterns: e0,
            defaultMatchWidth: "wide",
            parsePatterns: t0,
            defaultParseWidth: "any",
            valueCallback: function(t) {
                return t + 1
            }
        }),
        month: en({
            matchPatterns: r0,
            defaultMatchWidth: "wide",
            parsePatterns: n0,
            defaultParseWidth: "any"
        }),
        day: en({
            matchPatterns: a0,
            defaultMatchWidth: "wide",
            parsePatterns: i0,
            defaultParseWidth: "any"
        }),
        dayPeriod: en({
            matchPatterns: s0,
            defaultMatchWidth: "any",
            parsePatterns: o0,
            defaultParseWidth: "any"
        })
    };
const u0 = l0;
var c0 = {
    code: "en-US",
    formatDistance: Mm,
    formatLong: Lm,
    formatRelative: jm,
    localize: Bm,
    match: u0,
    options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
    }
};
const tu = c0;
var d0 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
    f0 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
    h0 = /^'([^]*?)'?$/,
    m0 = /''/g,
    v0 = /[a-zA-Z]/;

function ea(e, t, r) {
    var n, a, i, s, o, l, u, c, d, h, g, y, k, O, U, N, L, P;
    Q(2, arguments);
    var E = String(t),
        w = zt(),
        G = (n = (a = r == null ? void 0 : r.locale) !== null && a !== void 0 ? a : w.locale) !== null && n !== void 0 ? n : tu,
        se = Fe((i = (s = (o = (l = r == null ? void 0 : r.firstWeekContainsDate) !== null && l !== void 0 ? l : r == null || (u = r.locale) === null || u === void 0 || (c = u.options) === null || c === void 0 ? void 0 : c.firstWeekContainsDate) !== null && o !== void 0 ? o : w.firstWeekContainsDate) !== null && s !== void 0 ? s : (d = w.locale) === null || d === void 0 || (h = d.options) === null || h === void 0 ? void 0 : h.firstWeekContainsDate) !== null && i !== void 0 ? i : 1);
    if (!(se >= 1 && se <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var he = Fe((g = (y = (k = (O = r == null ? void 0 : r.weekStartsOn) !== null && O !== void 0 ? O : r == null || (U = r.locale) === null || U === void 0 || (N = U.options) === null || N === void 0 ? void 0 : N.weekStartsOn) !== null && k !== void 0 ? k : w.weekStartsOn) !== null && y !== void 0 ? y : (L = w.locale) === null || L === void 0 || (P = L.options) === null || P === void 0 ? void 0 : P.weekStartsOn) !== null && g !== void 0 ? g : 0);
    if (!(he >= 0 && he <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    if (!G.localize) throw new RangeError("locale must contain localize property");
    if (!G.formatLong) throw new RangeError("locale must contain formatLong property");
    var de = Z(e);
    if (!yt(de)) throw new RangeError("Invalid time value");
    var le = Hl(de),
        Le = Zl(de, le),
        Ne = {
            firstWeekContainsDate: se,
            weekStartsOn: he,
            locale: G,
            _originalDate: de
        },
        je = E.match(f0).map(function(we) {
            var V = we[0];
            if (V === "p" || V === "P") {
                var ne = vi[V];
                return ne(we, G.formatLong)
            }
            return we
        }).join("").match(d0).map(function(we) {
            if (we === "''") return "'";
            var V = we[0];
            if (V === "'") return p0(we);
            var ne = km[V];
            if (ne) return !(r != null && r.useAdditionalWeekYearTokens) && eu(we) && Jn(we, t, String(e)), !(r != null && r.useAdditionalDayOfYearTokens) && Jl(we) && Jn(we, t, String(e)), ne(Le, we, G.localize, Ne);
            if (V.match(v0)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + V + "`");
            return we
        }).join("");
    return je
}

function p0(e) {
    var t = e.match(h0);
    return t ? t[1].replace(m0, "'") : e
}

function g0(e, t) {
    if (e == null) throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r]);
    return e
}

function y0(e) {
    Q(1, arguments);
    var t = Z(e),
        r = t.getFullYear(),
        n = t.getMonth(),
        a = new Date(0);
    return a.setFullYear(r, n + 1, 0), a.setHours(0, 0, 0, 0), a.getDate()
}

function $n(e) {
    Q(1, arguments);
    var t = Z(e),
        r = t.getFullYear(),
        n = Math.floor(r / 10) * 10;
    return n
}

function Tt(e) {
    return Q(1, arguments), Z(e).getFullYear()
}

function yn(e, t) {
    Q(2, arguments);
    var r = Z(e),
        n = Z(t);
    return r.getTime() > n.getTime()
}

function bn(e, t) {
    Q(2, arguments);
    var r = Z(e),
        n = Z(t);
    return r.getTime() < n.getTime()
}

function no(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
    return n
}

function b0(e, t) {
    if (e) {
        if (typeof e == "string") return no(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
        if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return no(e, t)
    }
}

function ao(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
        if (Array.isArray(e) || (r = b0(e)) || t && e && typeof e.length == "number") {
            r && (e = r);
            var n = 0,
                a = function() {};
            return {
                s: a,
                n: function() {
                    return n >= e.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: e[n++]
                    }
                },
                e: function(u) {
                    throw u
                },
                f: a
            }
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }
    var i = !0,
        s = !1,
        o;
    return {
        s: function() {
            r = r.call(e)
        },
        n: function() {
            var u = r.next();
            return i = u.done, u
        },
        e: function(u) {
            s = !0, o = u
        },
        f: function() {
            try {
                !i && r.return != null && r.return()
            } finally {
                if (s) throw o
            }
        }
    }
}

function R(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
}

function pi(e, t) {
    return pi = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, a) {
        return n.__proto__ = a, n
    }, pi(e, t)
}

function ke(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
        constructor: {
            value: e,
            writable: !0,
            configurable: !0
        }
    }), Object.defineProperty(e, "prototype", {
        writable: !1
    }), t && pi(e, t)
}

function ta(e) {
    return ta = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
        return r.__proto__ || Object.getPrototypeOf(r)
    }, ta(e)
}

function ru() {
    try {
        var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}))
    } catch {}
    return (ru = function() {
        return !!e
    })()
}

function w0(e, t) {
    if (t && (kt(t) === "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return R(e)
}

function Oe(e) {
    var t = ru();
    return function() {
        var n = ta(e),
            a;
        if (t) {
            var i = ta(this).constructor;
            a = Reflect.construct(n, arguments, i)
        } else a = n.apply(this, arguments);
        return w0(this, a)
    }
}

function ye(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}

function _0(e, t) {
    if (kt(e) != "object" || !e) return e;
    var r = e[Symbol.toPrimitive];
    if (r !== void 0) {
        var n = r.call(e, t || "default");
        if (kt(n) != "object") return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (t === "string" ? String : Number)(e)
}

function nu(e) {
    var t = _0(e, "string");
    return kt(t) == "symbol" ? t : t + ""
}

function io(e, t) {
    for (var r = 0; r < t.length; r++) {
        var n = t[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, nu(n.key), n)
    }
}

function be(e, t, r) {
    return t && io(e.prototype, t), r && io(e, r), Object.defineProperty(e, "prototype", {
        writable: !1
    }), e
}

function j(e, t, r) {
    return t = nu(t), t in e ? Object.defineProperty(e, t, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = r, e
}
var x0 = 10,
    au = function() {
        function e() {
            ye(this, e), j(this, "priority", void 0), j(this, "subPriority", 0)
        }
        return be(e, [{
            key: "validate",
            value: function(r, n) {
                return !0
            }
        }]), e
    }(),
    k0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r(n, a, i, s, o) {
            var l;
            return ye(this, r), l = t.call(this), l.value = n, l.validateValue = a, l.setValue = i, l.priority = s, o && (l.subPriority = o), l
        }
        return be(r, [{
            key: "validate",
            value: function(a, i) {
                return this.validateValue(a, this.value, i)
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return this.setValue(a, i, this.value, s)
            }
        }]), r
    }(au),
    O0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", x0), j(R(n), "subPriority", -1), n
        }
        return be(r, [{
            key: "set",
            value: function(a, i) {
                if (i.timestampIsSet) return a;
                var s = new Date(0);
                return s.setFullYear(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate()), s.setHours(a.getUTCHours(), a.getUTCMinutes(), a.getUTCSeconds(), a.getUTCMilliseconds()), s
            }
        }]), r
    }(au),
    Se = function() {
        function e() {
            ye(this, e), j(this, "incompatibleTokens", void 0), j(this, "priority", void 0), j(this, "subPriority", void 0)
        }
        return be(e, [{
            key: "run",
            value: function(r, n, a, i) {
                var s = this.parse(r, n, a, i);
                return s ? {
                    setter: new k0(s.value, this.validate, this.set, this.priority, this.subPriority),
                    rest: s.rest
                } : null
            }
        }, {
            key: "validate",
            value: function(r, n, a) {
                return !0
            }
        }]), e
    }(),
    T0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 140), j(R(n), "incompatibleTokens", ["R", "u", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "G":
                    case "GG":
                    case "GGG":
                        return s.era(a, {
                            width: "abbreviated"
                        }) || s.era(a, {
                            width: "narrow"
                        });
                    case "GGGGG":
                        return s.era(a, {
                            width: "narrow"
                        });
                    case "GGGG":
                    default:
                        return s.era(a, {
                            width: "wide"
                        }) || s.era(a, {
                            width: "abbreviated"
                        }) || s.era(a, {
                            width: "narrow"
                        })
                }
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return i.era = s, a.setUTCFullYear(s, 0, 1), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se),
    Be = {
        month: /^(1[0-2]|0?\d)/,
        date: /^(3[0-1]|[0-2]?\d)/,
        dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
        week: /^(5[0-3]|[0-4]?\d)/,
        hour23h: /^(2[0-3]|[0-1]?\d)/,
        hour24h: /^(2[0-4]|[0-1]?\d)/,
        hour11h: /^(1[0-1]|0?\d)/,
        hour12h: /^(1[0-2]|0?\d)/,
        minute: /^[0-5]?\d/,
        second: /^[0-5]?\d/,
        singleDigit: /^\d/,
        twoDigits: /^\d{1,2}/,
        threeDigits: /^\d{1,3}/,
        fourDigits: /^\d{1,4}/,
        anyDigitsSigned: /^-?\d+/,
        singleDigitSigned: /^-?\d/,
        twoDigitsSigned: /^-?\d{1,2}/,
        threeDigitsSigned: /^-?\d{1,3}/,
        fourDigitsSigned: /^-?\d{1,4}/
    },
    It = {
        basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
        basic: /^([+-])(\d{2})(\d{2})|Z/,
        basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
        extended: /^([+-])(\d{2}):(\d{2})|Z/,
        extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
    };

function ze(e, t) {
    return e && {
        value: t(e.value),
        rest: e.rest
    }
}

function Ye(e, t) {
    var r = t.match(e);
    return r ? {
        value: parseInt(r[0], 10),
        rest: t.slice(r[0].length)
    } : null
}

function Vt(e, t) {
    var r = t.match(e);
    if (!r) return null;
    if (r[0] === "Z") return {
        value: 0,
        rest: t.slice(1)
    };
    var n = r[1] === "+" ? 1 : -1,
        a = r[2] ? parseInt(r[2], 10) : 0,
        i = r[3] ? parseInt(r[3], 10) : 0,
        s = r[5] ? parseInt(r[5], 10) : 0;
    return {
        value: n * (a * im + i * am + s * sm),
        rest: t.slice(r[0].length)
    }
}

function iu(e) {
    return Ye(Be.anyDigitsSigned, e)
}

function qe(e, t) {
    switch (e) {
        case 1:
            return Ye(Be.singleDigit, t);
        case 2:
            return Ye(Be.twoDigits, t);
        case 3:
            return Ye(Be.threeDigits, t);
        case 4:
            return Ye(Be.fourDigits, t);
        default:
            return Ye(new RegExp("^\\d{1," + e + "}"), t)
    }
}

function ra(e, t) {
    switch (e) {
        case 1:
            return Ye(Be.singleDigitSigned, t);
        case 2:
            return Ye(Be.twoDigitsSigned, t);
        case 3:
            return Ye(Be.threeDigitsSigned, t);
        case 4:
            return Ye(Be.fourDigitsSigned, t);
        default:
            return Ye(new RegExp("^-?\\d{1," + e + "}"), t)
    }
}

function Ki(e) {
    switch (e) {
        case "morning":
            return 4;
        case "evening":
            return 17;
        case "pm":
        case "noon":
        case "afternoon":
            return 12;
        case "am":
        case "midnight":
        case "night":
        default:
            return 0
    }
}

function su(e, t) {
    var r = t > 0,
        n = r ? t : 1 - t,
        a;
    if (n <= 50) a = e || 100;
    else {
        var i = n + 50,
            s = Math.floor(i / 100) * 100,
            o = e >= i % 100;
        a = e + s - (o ? 100 : 0)
    }
    return r ? a : 1 - a
}

function ou(e) {
    return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0
}
var C0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 130), j(R(n), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                var o = function(u) {
                    return {
                        year: u,
                        isTwoDigitYear: i === "yy"
                    }
                };
                switch (i) {
                    case "y":
                        return ze(qe(4, a), o);
                    case "yo":
                        return ze(s.ordinalNumber(a, {
                            unit: "year"
                        }), o);
                    default:
                        return ze(qe(i.length, a), o)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i.isTwoDigitYear || i.year > 0
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                var o = a.getUTCFullYear();
                if (s.isTwoDigitYear) {
                    var l = su(s.year, o);
                    return a.setUTCFullYear(l, 0, 1), a.setUTCHours(0, 0, 0, 0), a
                }
                var u = !("era" in i) || i.era === 1 ? s.year : 1 - s.year;
                return a.setUTCFullYear(u, 0, 1), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se),
    D0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 130), j(R(n), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                var o = function(u) {
                    return {
                        year: u,
                        isTwoDigitYear: i === "YY"
                    }
                };
                switch (i) {
                    case "Y":
                        return ze(qe(4, a), o);
                    case "Yo":
                        return ze(s.ordinalNumber(a, {
                            unit: "year"
                        }), o);
                    default:
                        return ze(qe(i.length, a), o)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i.isTwoDigitYear || i.year > 0
            }
        }, {
            key: "set",
            value: function(a, i, s, o) {
                var l = Qi(a, o);
                if (s.isTwoDigitYear) {
                    var u = su(s.year, l);
                    return a.setUTCFullYear(u, 0, o.firstWeekContainsDate), a.setUTCHours(0, 0, 0, 0), Sr(a, o)
                }
                var c = !("era" in i) || i.era === 1 ? s.year : 1 - s.year;
                return a.setUTCFullYear(c, 0, o.firstWeekContainsDate), a.setUTCHours(0, 0, 0, 0), Sr(a, o)
            }
        }]), r
    }(Se),
    S0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 130), j(R(n), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i) {
                return ra(i === "R" ? 4 : i.length, a)
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                var o = new Date(0);
                return o.setUTCFullYear(s, 0, 4), o.setUTCHours(0, 0, 0, 0), Hr(o)
            }
        }]), r
    }(Se),
    M0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 130), j(R(n), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i) {
                return ra(i === "u" ? 4 : i.length, a)
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCFullYear(s, 0, 1), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se),
    E0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 120), j(R(n), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "Q":
                    case "QQ":
                        return qe(i.length, a);
                    case "Qo":
                        return s.ordinalNumber(a, {
                            unit: "quarter"
                        });
                    case "QQQ":
                        return s.quarter(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.quarter(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "QQQQQ":
                        return s.quarter(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "QQQQ":
                    default:
                        return s.quarter(a, {
                            width: "wide",
                            context: "formatting"
                        }) || s.quarter(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.quarter(a, {
                            width: "narrow",
                            context: "formatting"
                        })
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 1 && i <= 4
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCMonth((s - 1) * 3, 1), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se),
    P0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 120), j(R(n), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "q":
                    case "qq":
                        return qe(i.length, a);
                    case "qo":
                        return s.ordinalNumber(a, {
                            unit: "quarter"
                        });
                    case "qqq":
                        return s.quarter(a, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.quarter(a, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "qqqqq":
                        return s.quarter(a, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "qqqq":
                    default:
                        return s.quarter(a, {
                            width: "wide",
                            context: "standalone"
                        }) || s.quarter(a, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.quarter(a, {
                            width: "narrow",
                            context: "standalone"
                        })
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 1 && i <= 4
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCMonth((s - 1) * 3, 1), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se),
    $0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]), j(R(n), "priority", 110), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                var o = function(u) {
                    return u - 1
                };
                switch (i) {
                    case "M":
                        return ze(Ye(Be.month, a), o);
                    case "MM":
                        return ze(qe(2, a), o);
                    case "Mo":
                        return ze(s.ordinalNumber(a, {
                            unit: "month"
                        }), o);
                    case "MMM":
                        return s.month(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.month(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "MMMMM":
                        return s.month(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "MMMM":
                    default:
                        return s.month(a, {
                            width: "wide",
                            context: "formatting"
                        }) || s.month(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.month(a, {
                            width: "narrow",
                            context: "formatting"
                        })
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 0 && i <= 11
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCMonth(s, 1), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se),
    F0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 110), j(R(n), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                var o = function(u) {
                    return u - 1
                };
                switch (i) {
                    case "L":
                        return ze(Ye(Be.month, a), o);
                    case "LL":
                        return ze(qe(2, a), o);
                    case "Lo":
                        return ze(s.ordinalNumber(a, {
                            unit: "month"
                        }), o);
                    case "LLL":
                        return s.month(a, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.month(a, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "LLLLL":
                        return s.month(a, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "LLLL":
                    default:
                        return s.month(a, {
                            width: "wide",
                            context: "standalone"
                        }) || s.month(a, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.month(a, {
                            width: "narrow",
                            context: "standalone"
                        })
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 0 && i <= 11
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCMonth(s, 1), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se);

function L0(e, t, r) {
    Q(2, arguments);
    var n = Z(e),
        a = Fe(t),
        i = Kl(n, r) - a;
    return n.setUTCDate(n.getUTCDate() - i * 7), n
}
var A0 = function(e) {
    ke(r, e);
    var t = Oe(r);

    function r() {
        var n;
        ye(this, r);
        for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
        return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 100), j(R(n), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]), n
    }
    return be(r, [{
        key: "parse",
        value: function(a, i, s) {
            switch (i) {
                case "w":
                    return Ye(Be.week, a);
                case "wo":
                    return s.ordinalNumber(a, {
                        unit: "week"
                    });
                default:
                    return qe(i.length, a)
            }
        }
    }, {
        key: "validate",
        value: function(a, i) {
            return i >= 1 && i <= 53
        }
    }, {
        key: "set",
        value: function(a, i, s, o) {
            return Sr(L0(a, s, o), o)
        }
    }]), r
}(Se);

function N0(e, t) {
    Q(2, arguments);
    var r = Z(e),
        n = Fe(t),
        a = Ql(r) - n;
    return r.setUTCDate(r.getUTCDate() - a * 7), r
}
var j0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 100), j(R(n), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "I":
                        return Ye(Be.week, a);
                    case "Io":
                        return s.ordinalNumber(a, {
                            unit: "week"
                        });
                    default:
                        return qe(i.length, a)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 1 && i <= 53
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return Hr(N0(a, s))
            }
        }]), r
    }(Se),
    I0 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    V0 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    R0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 90), j(R(n), "subPriority", 1), j(R(n), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "d":
                        return Ye(Be.date, a);
                    case "do":
                        return s.ordinalNumber(a, {
                            unit: "date"
                        });
                    default:
                        return qe(i.length, a)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                var s = a.getUTCFullYear(),
                    o = ou(s),
                    l = a.getUTCMonth();
                return o ? i >= 1 && i <= V0[l] : i >= 1 && i <= I0[l]
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCDate(s), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se),
    U0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 90), j(R(n), "subpriority", 1), j(R(n), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "D":
                    case "DD":
                        return Ye(Be.dayOfYear, a);
                    case "Do":
                        return s.ordinalNumber(a, {
                            unit: "date"
                        });
                    default:
                        return qe(i.length, a)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                var s = a.getUTCFullYear(),
                    o = ou(s);
                return o ? i >= 1 && i <= 366 : i >= 1 && i <= 365
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCMonth(0, s), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se);

function Xi(e, t, r) {
    var n, a, i, s, o, l, u, c;
    Q(2, arguments);
    var d = zt(),
        h = Fe((n = (a = (i = (s = r == null ? void 0 : r.weekStartsOn) !== null && s !== void 0 ? s : r == null || (o = r.locale) === null || o === void 0 || (l = o.options) === null || l === void 0 ? void 0 : l.weekStartsOn) !== null && i !== void 0 ? i : d.weekStartsOn) !== null && a !== void 0 ? a : (u = d.locale) === null || u === void 0 || (c = u.options) === null || c === void 0 ? void 0 : c.weekStartsOn) !== null && n !== void 0 ? n : 0);
    if (!(h >= 0 && h <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var g = Z(e),
        y = Fe(t),
        k = g.getUTCDay(),
        O = y % 7,
        U = (O + 7) % 7,
        N = (U < h ? 7 : 0) + y - k;
    return g.setUTCDate(g.getUTCDate() + N), g
}
var Y0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 90), j(R(n), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "E":
                    case "EE":
                    case "EEE":
                        return s.day(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "EEEEE":
                        return s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "EEEEEE":
                        return s.day(a, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "EEEE":
                    default:
                        return s.day(a, {
                            width: "wide",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        })
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 0 && i <= 6
            }
        }, {
            key: "set",
            value: function(a, i, s, o) {
                return a = Xi(a, s, o), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se),
    q0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 90), j(R(n), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s, o) {
                var l = function(c) {
                    var d = Math.floor((c - 1) / 7) * 7;
                    return (c + o.weekStartsOn + 6) % 7 + d
                };
                switch (i) {
                    case "e":
                    case "ee":
                        return ze(qe(i.length, a), l);
                    case "eo":
                        return ze(s.ordinalNumber(a, {
                            unit: "day"
                        }), l);
                    case "eee":
                        return s.day(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "eeeee":
                        return s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "eeeeee":
                        return s.day(a, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "eeee":
                    default:
                        return s.day(a, {
                            width: "wide",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        })
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 0 && i <= 6
            }
        }, {
            key: "set",
            value: function(a, i, s, o) {
                return a = Xi(a, s, o), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se),
    W0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 90), j(R(n), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s, o) {
                var l = function(c) {
                    var d = Math.floor((c - 1) / 7) * 7;
                    return (c + o.weekStartsOn + 6) % 7 + d
                };
                switch (i) {
                    case "c":
                    case "cc":
                        return ze(qe(i.length, a), l);
                    case "co":
                        return ze(s.ordinalNumber(a, {
                            unit: "day"
                        }), l);
                    case "ccc":
                        return s.day(a, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.day(a, {
                            width: "short",
                            context: "standalone"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "ccccc":
                        return s.day(a, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "cccccc":
                        return s.day(a, {
                            width: "short",
                            context: "standalone"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "standalone"
                        });
                    case "cccc":
                    default:
                        return s.day(a, {
                            width: "wide",
                            context: "standalone"
                        }) || s.day(a, {
                            width: "abbreviated",
                            context: "standalone"
                        }) || s.day(a, {
                            width: "short",
                            context: "standalone"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "standalone"
                        })
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 0 && i <= 6
            }
        }, {
            key: "set",
            value: function(a, i, s, o) {
                return a = Xi(a, s, o), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se);

function H0(e, t) {
    Q(2, arguments);
    var r = Fe(t);
    r % 7 === 0 && (r = r - 7);
    var n = 1,
        a = Z(e),
        i = a.getUTCDay(),
        s = r % 7,
        o = (s + 7) % 7,
        l = (o < n ? 7 : 0) + r - i;
    return a.setUTCDate(a.getUTCDate() + l), a
}
var B0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 90), j(R(n), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                var o = function(u) {
                    return u === 0 ? 7 : u
                };
                switch (i) {
                    case "i":
                    case "ii":
                        return qe(i.length, a);
                    case "io":
                        return s.ordinalNumber(a, {
                            unit: "day"
                        });
                    case "iii":
                        return ze(s.day(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        }), o);
                    case "iiiii":
                        return ze(s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        }), o);
                    case "iiiiii":
                        return ze(s.day(a, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        }), o);
                    case "iiii":
                    default:
                        return ze(s.day(a, {
                            width: "wide",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "short",
                            context: "formatting"
                        }) || s.day(a, {
                            width: "narrow",
                            context: "formatting"
                        }), o)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 1 && i <= 7
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a = H0(a, s), a.setUTCHours(0, 0, 0, 0), a
            }
        }]), r
    }(Se),
    z0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 80), j(R(n), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "a":
                    case "aa":
                    case "aaa":
                        return s.dayPeriod(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "aaaaa":
                        return s.dayPeriod(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "aaaa":
                    default:
                        return s.dayPeriod(a, {
                            width: "wide",
                            context: "formatting"
                        }) || s.dayPeriod(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(a, {
                            width: "narrow",
                            context: "formatting"
                        })
                }
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCHours(Ki(s), 0, 0, 0), a
            }
        }]), r
    }(Se),
    Z0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 80), j(R(n), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "b":
                    case "bb":
                    case "bbb":
                        return s.dayPeriod(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "bbbbb":
                        return s.dayPeriod(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "bbbb":
                    default:
                        return s.dayPeriod(a, {
                            width: "wide",
                            context: "formatting"
                        }) || s.dayPeriod(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(a, {
                            width: "narrow",
                            context: "formatting"
                        })
                }
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCHours(Ki(s), 0, 0, 0), a
            }
        }]), r
    }(Se),
    G0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 80), j(R(n), "incompatibleTokens", ["a", "b", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "B":
                    case "BB":
                    case "BBB":
                        return s.dayPeriod(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "BBBBB":
                        return s.dayPeriod(a, {
                            width: "narrow",
                            context: "formatting"
                        });
                    case "BBBB":
                    default:
                        return s.dayPeriod(a, {
                            width: "wide",
                            context: "formatting"
                        }) || s.dayPeriod(a, {
                            width: "abbreviated",
                            context: "formatting"
                        }) || s.dayPeriod(a, {
                            width: "narrow",
                            context: "formatting"
                        })
                }
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCHours(Ki(s), 0, 0, 0), a
            }
        }]), r
    }(Se),
    Q0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 70), j(R(n), "incompatibleTokens", ["H", "K", "k", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "h":
                        return Ye(Be.hour12h, a);
                    case "ho":
                        return s.ordinalNumber(a, {
                            unit: "hour"
                        });
                    default:
                        return qe(i.length, a)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 1 && i <= 12
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                var o = a.getUTCHours() >= 12;
                return o && s < 12 ? a.setUTCHours(s + 12, 0, 0, 0) : !o && s === 12 ? a.setUTCHours(0, 0, 0, 0) : a.setUTCHours(s, 0, 0, 0), a
            }
        }]), r
    }(Se),
    K0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 70), j(R(n), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "H":
                        return Ye(Be.hour23h, a);
                    case "Ho":
                        return s.ordinalNumber(a, {
                            unit: "hour"
                        });
                    default:
                        return qe(i.length, a)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 0 && i <= 23
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCHours(s, 0, 0, 0), a
            }
        }]), r
    }(Se),
    X0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 70), j(R(n), "incompatibleTokens", ["h", "H", "k", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "K":
                        return Ye(Be.hour11h, a);
                    case "Ko":
                        return s.ordinalNumber(a, {
                            unit: "hour"
                        });
                    default:
                        return qe(i.length, a)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 0 && i <= 11
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                var o = a.getUTCHours() >= 12;
                return o && s < 12 ? a.setUTCHours(s + 12, 0, 0, 0) : a.setUTCHours(s, 0, 0, 0), a
            }
        }]), r
    }(Se),
    J0 = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 70), j(R(n), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "k":
                        return Ye(Be.hour24h, a);
                    case "ko":
                        return s.ordinalNumber(a, {
                            unit: "hour"
                        });
                    default:
                        return qe(i.length, a)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 1 && i <= 24
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                var o = s <= 24 ? s % 24 : s;
                return a.setUTCHours(o, 0, 0, 0), a
            }
        }]), r
    }(Se),
    ev = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 60), j(R(n), "incompatibleTokens", ["t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "m":
                        return Ye(Be.minute, a);
                    case "mo":
                        return s.ordinalNumber(a, {
                            unit: "minute"
                        });
                    default:
                        return qe(i.length, a)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 0 && i <= 59
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCMinutes(s, 0, 0), a
            }
        }]), r
    }(Se),
    tv = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 50), j(R(n), "incompatibleTokens", ["t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i, s) {
                switch (i) {
                    case "s":
                        return Ye(Be.second, a);
                    case "so":
                        return s.ordinalNumber(a, {
                            unit: "second"
                        });
                    default:
                        return qe(i.length, a)
                }
            }
        }, {
            key: "validate",
            value: function(a, i) {
                return i >= 0 && i <= 59
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCSeconds(s, 0), a
            }
        }]), r
    }(Se),
    rv = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 30), j(R(n), "incompatibleTokens", ["t", "T"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i) {
                var s = function(l) {
                    return Math.floor(l * Math.pow(10, -i.length + 3))
                };
                return ze(qe(i.length, a), s)
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return a.setUTCMilliseconds(s), a
            }
        }]), r
    }(Se),
    nv = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 10), j(R(n), "incompatibleTokens", ["t", "T", "x"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i) {
                switch (i) {
                    case "X":
                        return Vt(It.basicOptionalMinutes, a);
                    case "XX":
                        return Vt(It.basic, a);
                    case "XXXX":
                        return Vt(It.basicOptionalSeconds, a);
                    case "XXXXX":
                        return Vt(It.extendedOptionalSeconds, a);
                    case "XXX":
                    default:
                        return Vt(It.extended, a)
                }
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return i.timestampIsSet ? a : new Date(a.getTime() - s)
            }
        }]), r
    }(Se),
    av = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 10), j(R(n), "incompatibleTokens", ["t", "T", "X"]), n
        }
        return be(r, [{
            key: "parse",
            value: function(a, i) {
                switch (i) {
                    case "x":
                        return Vt(It.basicOptionalMinutes, a);
                    case "xx":
                        return Vt(It.basic, a);
                    case "xxxx":
                        return Vt(It.basicOptionalSeconds, a);
                    case "xxxxx":
                        return Vt(It.extendedOptionalSeconds, a);
                    case "xxx":
                    default:
                        return Vt(It.extended, a)
                }
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return i.timestampIsSet ? a : new Date(a.getTime() - s)
            }
        }]), r
    }(Se),
    iv = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 40), j(R(n), "incompatibleTokens", "*"), n
        }
        return be(r, [{
            key: "parse",
            value: function(a) {
                return iu(a)
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return [new Date(s * 1e3), {
                    timestampIsSet: !0
                }]
            }
        }]), r
    }(Se),
    sv = function(e) {
        ke(r, e);
        var t = Oe(r);

        function r() {
            var n;
            ye(this, r);
            for (var a = arguments.length, i = new Array(a), s = 0; s < a; s++) i[s] = arguments[s];
            return n = t.call.apply(t, [this].concat(i)), j(R(n), "priority", 20), j(R(n), "incompatibleTokens", "*"), n
        }
        return be(r, [{
            key: "parse",
            value: function(a) {
                return iu(a)
            }
        }, {
            key: "set",
            value: function(a, i, s) {
                return [new Date(s), {
                    timestampIsSet: !0
                }]
            }
        }]), r
    }(Se),
    ov = {
        G: new T0,
        y: new C0,
        Y: new D0,
        R: new S0,
        u: new M0,
        Q: new E0,
        q: new P0,
        M: new $0,
        L: new F0,
        w: new A0,
        I: new j0,
        d: new R0,
        D: new U0,
        E: new Y0,
        e: new q0,
        c: new W0,
        i: new B0,
        a: new z0,
        b: new Z0,
        B: new G0,
        h: new Q0,
        H: new K0,
        K: new X0,
        k: new J0,
        m: new ev,
        s: new tv,
        S: new rv,
        X: new nv,
        x: new av,
        t: new iv,
        T: new sv
    },
    lv = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
    uv = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
    cv = /^'([^]*?)'?$/,
    dv = /''/g,
    fv = /\S/,
    hv = /[a-zA-Z]/;

function so(e, t, r, n) {
    var a, i, s, o, l, u, c, d, h, g, y, k, O, U, N, L, P, E;
    Q(3, arguments);
    var w = String(e),
        G = String(t),
        se = zt(),
        he = (a = (i = n == null ? void 0 : n.locale) !== null && i !== void 0 ? i : se.locale) !== null && a !== void 0 ? a : tu;
    if (!he.match) throw new RangeError("locale must contain match property");
    var de = Fe((s = (o = (l = (u = n == null ? void 0 : n.firstWeekContainsDate) !== null && u !== void 0 ? u : n == null || (c = n.locale) === null || c === void 0 || (d = c.options) === null || d === void 0 ? void 0 : d.firstWeekContainsDate) !== null && l !== void 0 ? l : se.firstWeekContainsDate) !== null && o !== void 0 ? o : (h = se.locale) === null || h === void 0 || (g = h.options) === null || g === void 0 ? void 0 : g.firstWeekContainsDate) !== null && s !== void 0 ? s : 1);
    if (!(de >= 1 && de <= 7)) throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var le = Fe((y = (k = (O = (U = n == null ? void 0 : n.weekStartsOn) !== null && U !== void 0 ? U : n == null || (N = n.locale) === null || N === void 0 || (L = N.options) === null || L === void 0 ? void 0 : L.weekStartsOn) !== null && O !== void 0 ? O : se.weekStartsOn) !== null && k !== void 0 ? k : (P = se.locale) === null || P === void 0 || (E = P.options) === null || E === void 0 ? void 0 : E.weekStartsOn) !== null && y !== void 0 ? y : 0);
    if (!(le >= 0 && le <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    if (G === "") return w === "" ? Z(r) : new Date(NaN);
    var Le = {
            firstWeekContainsDate: de,
            weekStartsOn: le,
            locale: he
        },
        Ne = [new O0],
        je = G.match(uv).map(function(ee) {
            var fe = ee[0];
            if (fe in vi) {
                var Me = vi[fe];
                return Me(ee, he.formatLong)
            }
            return ee
        }).join("").match(lv),
        we = [],
        V = ao(je),
        ne;
    try {
        var ce = function() {
            var fe = ne.value;
            !(n != null && n.useAdditionalWeekYearTokens) && eu(fe) && Jn(fe, G, e), !(n != null && n.useAdditionalDayOfYearTokens) && Jl(fe) && Jn(fe, G, e);
            var Me = fe[0],
                He = ov[Me];
            if (He) {
                var Zt = He.incompatibleTokens;
                if (Array.isArray(Zt)) {
                    var f = we.find(function(b) {
                        return Zt.includes(b.token) || b.token === Me
                    });
                    if (f) throw new RangeError("The format string mustn't contain `".concat(f.fullToken, "` and `").concat(fe, "` at the same time"))
                } else if (He.incompatibleTokens === "*" && we.length > 0) throw new RangeError("The format string mustn't contain `".concat(fe, "` and any other token at the same time"));
                we.push({
                    token: Me,
                    fullToken: fe
                });
                var m = He.run(w, fe, he.match, Le);
                if (!m) return {
                    v: new Date(NaN)
                };
                Ne.push(m.setter), w = m.rest
            } else {
                if (Me.match(hv)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + Me + "`");
                if (fe === "''" ? fe = "'" : Me === "'" && (fe = mv(fe)), w.indexOf(fe) === 0) w = w.slice(fe.length);
                else return {
                    v: new Date(NaN)
                }
            }
        };
        for (V.s(); !(ne = V.n()).done;) {
            var Qe = ce();
            if (kt(Qe) === "object") return Qe.v
        }
    } catch (ee) {
        V.e(ee)
    } finally {
        V.f()
    }
    if (w.length > 0 && fv.test(w)) return new Date(NaN);
    var bt = Ne.map(function(ee) {
            return ee.priority
        }).sort(function(ee, fe) {
            return fe - ee
        }).filter(function(ee, fe, Me) {
            return Me.indexOf(ee) === fe
        }).map(function(ee) {
            return Ne.filter(function(fe) {
                return fe.priority === ee
            }).sort(function(fe, Me) {
                return Me.subPriority - fe.subPriority
            })
        }).map(function(ee) {
            return ee[0]
        }),
        nt = Z(r);
    if (isNaN(nt.getTime())) return new Date(NaN);
    var Ke = Zl(nt, Hl(nt)),
        We = {},
        $t = ao(bt),
        W;
    try {
        for ($t.s(); !(W = $t.n()).done;) {
            var X = W.value;
            if (!X.validate(Ke, Le)) return new Date(NaN);
            var pe = X.set(Ke, We, Le);
            Array.isArray(pe) ? (Ke = pe[0], g0(We, pe[1])) : Ke = pe
        }
    } catch (ee) {
        $t.e(ee)
    } finally {
        $t.f()
    }
    return Ke
}

function mv(e) {
    return e.match(cv)[1].replace(dv, "'")
}

function oo(e) {
    Q(1, arguments);
    var t = Z(e);
    return t.setMinutes(0, 0, 0), t
}

function vv(e, t) {
    Q(2, arguments);
    var r = oo(e),
        n = oo(t);
    return r.getTime() === n.getTime()
}

function pv(e, t) {
    Q(2, arguments);
    var r = Js(e),
        n = Js(t);
    return r.getTime() === n.getTime()
}

function gi(e, t) {
    Q(2, arguments);
    var r = Z(e),
        n = Z(t);
    return r.getFullYear() === n.getFullYear() && r.getMonth() === n.getMonth()
}

function lo(e, t) {
    Q(2, arguments);
    var r = Z(e),
        n = Z(t);
    return r.getFullYear() === n.getFullYear()
}

function gv(e, t) {
    Q(2, arguments);
    var r = Z(e).getTime(),
        n = Z(t.start).getTime(),
        a = Z(t.end).getTime();
    if (!(n <= a)) throw new RangeError("Invalid interval");
    return r >= n && r <= a
}

function yv(e, t) {
    Q(2, arguments);
    var r = Z(e),
        n = Fe(t),
        a = r.getFullYear(),
        i = r.getDate(),
        s = new Date(0);
    s.setFullYear(a, n, 15), s.setHours(0, 0, 0, 0);
    var o = y0(s);
    return r.setMonth(n, Math.min(i, o)), r
}

function uo(e, t) {
    if (Q(2, arguments), kt(t) !== "object" || t === null) throw new RangeError("values parameter must be an object");
    var r = Z(e);
    return isNaN(r.getTime()) ? new Date(NaN) : (t.year != null && r.setFullYear(t.year), t.month != null && (r = yv(r, t.month)), t.date != null && r.setDate(Fe(t.date)), t.hours != null && r.setHours(Fe(t.hours)), t.minutes != null && r.setMinutes(Fe(t.minutes)), t.seconds != null && r.setSeconds(Fe(t.seconds)), t.milliseconds != null && r.setMilliseconds(Fe(t.milliseconds)), r)
}

function bv(e, t, r) {
    var n, a, i, s, o, l, u, c;
    Q(2, arguments);
    var d = zt(),
        h = Fe((n = (a = (i = (s = r == null ? void 0 : r.weekStartsOn) !== null && s !== void 0 ? s : r == null || (o = r.locale) === null || o === void 0 || (l = o.options) === null || l === void 0 ? void 0 : l.weekStartsOn) !== null && i !== void 0 ? i : d.weekStartsOn) !== null && a !== void 0 ? a : (u = d.locale) === null || u === void 0 || (c = u.options) === null || c === void 0 ? void 0 : c.weekStartsOn) !== null && n !== void 0 ? n : 0);
    if (!(h >= 0 && h <= 6)) throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var g = Z(e),
        y = Fe(t),
        k = g.getDay(),
        O = y % 7,
        U = (O + 7) % 7,
        N = 7 - h,
        L = y < 0 || y > 6 ? y - (k + N) % 7 : (U + N) % 7 - (k + N) % 7;
    return Xh(g, L)
}

function wv(e) {
    Q(1, arguments);
    var t = Z(e),
        r = t.getFullYear(),
        n = Math.floor(r / 10) * 10;
    return t.setFullYear(n, 0, 1), t.setHours(0, 0, 0, 0), t
}

function _v(e, t) {
    Q(2, arguments);
    var r = Fe(t);
    return Zi(e, -r)
}

function lu(e, t) {
    Q(2, arguments);
    var r = Fe(t);
    return Gi(e, -r)
}(function() {
    try {
        if (typeof document < "u") {
            var e = document.createElement("style");
            e.appendChild(document.createTextNode(".v3dp__popout[data-v-65eb861b]{z-index:10;position:absolute;text-align:center;width:17.5em;background-color:var(--popout-bg-color);box-shadow:var(--box-shadow);border-radius:var(--border-radius);padding:8px 0 1em;color:var(--text-color)}.v3dp__popout *[data-v-65eb861b]{color:inherit;font-size:inherit;font-weight:inherit}.v3dp__popout[data-v-65eb861b] button{background:none;border:none;outline:none}.v3dp__popout[data-v-65eb861b] button:not(:disabled){cursor:pointer}.v3dp__heading[data-v-65eb861b]{width:100%;display:flex;height:var(--heading-size);line-height:var(--heading-size);font-weight:var(--heading-weight)}.v3dp__heading__button[data-v-65eb861b]{background:none;border:none;padding:0;display:flex;justify-content:center;align-items:center;width:var(--heading-size)}button.v3dp__heading__center[data-v-65eb861b]:hover,.v3dp__heading__button[data-v-65eb861b]:not(:disabled):hover{background-color:var(--heading-hover-color)}.v3dp__heading__center[data-v-65eb861b]{flex:1}.v3dp__heading__icon[data-v-65eb861b]{height:12px;stroke:var(--arrow-color)}.v3dp__heading__button:disabled .v3dp__heading__icon[data-v-65eb861b]{stroke:var(--elem-disabled-color)}.v3dp__subheading[data-v-65eb861b],.v3dp__elements[data-v-65eb861b]{display:grid;grid-template-columns:var(--popout-column-definition);font-size:var(--elem-font-size)}.v3dp__subheading[data-v-65eb861b]{margin-top:1em}.v3dp__divider[data-v-65eb861b]{border:1px solid var(--divider-color);border-radius:3px}.v3dp__elements[data-v-65eb861b] button:disabled{color:var(--elem-disabled-color)}.v3dp__elements[data-v-65eb861b] button{padding:.3em .6em}.v3dp__elements[data-v-65eb861b] button span{display:block;line-height:1.9em;height:1.8em;border-radius:var(--elem-border-radius)}.v3dp__elements[data-v-65eb861b] button:not(:disabled):hover span{background-color:var(--elem-hover-bg-color);color:var(--elem-hover-color)}.v3dp__elements[data-v-65eb861b] button.selected span{background-color:var(--elem-selected-bg-color);color:var(--elem-selected-color)}.v3dp__elements[data-v-65eb861b] button.current span{font-weight:var(--elem-current-font-weight);outline:1px solid var(--elem-current-outline-color)}.v3dp__column[data-v-81ac698d]{display:flex;flex-direction:column;overflow-y:auto;height:190px}.v3dp__datepicker{--popout-bg-color: var(--vdp-bg-color, #fff);--box-shadow: var( --vdp-box-shadow, 0 4px 10px 0 rgba(128, 144, 160, .1), 0 0 1px 0 rgba(128, 144, 160, .81) );--text-color: var(--vdp-text-color, #000000);--border-radius: var(--vdp-border-radius, 3px);--heading-size: var(--vdp-heading-size, 2.5em);--heading-weight: var(--vdp-heading-weight, bold);--heading-hover-color: var(--vdp-heading-hover-color, #eeeeee);--arrow-color: var(--vdp-arrow-color, currentColor);--elem-color: var(--vdp-elem-color, currentColor);--elem-disabled-color: var(--vdp-disabled-color, #d5d9e0);--elem-hover-color: var(--vdp-hover-color, #fff);--elem-hover-bg-color: var(--vdp-hover-bg-color, #0baf74);--elem-selected-color: var(--vdp-selected-color, #fff);--elem-selected-bg-color: var(--vdp-selected-bg-color, #0baf74);--elem-current-outline-color: var(--vdp-current-date-outline-color, #888);--elem-current-font-weight: var(--vdp-current-date-font-weight, bold);--elem-font-size: var(--vdp-elem-font-size, .8em);--elem-border-radius: var(--vdp-elem-border-radius, 3px);--divider-color: var(--vdp-divider-color, var(--elem-disabled-color));position:relative}.v3dp__clearable{display:inline;position:relative;left:-15px;cursor:pointer}")), document.head.appendChild(e)
        }
    } catch (t) {
        console.error("vite-plugin-css-injected-by-js", t)
    }
})();
const xv = ["year", "month", "day", "time", "custom"],
    kv = Ht({
        emits: {
            elementClick: e => yt(e),
            left: () => !0,
            right: () => !0,
            heading: () => !0
        },
        props: {
            headingClickable: {
                type: Boolean,
                default: !1
            },
            leftDisabled: {
                type: Boolean,
                default: !1
            },
            rightDisabled: {
                type: Boolean,
                default: !1
            },
            columnCount: {
                type: Number,
                default: 7
            },
            items: {
                type: Array,
                default: () => []
            },
            viewMode: {
                type: String,
                required: !0,
                validate: e => typeof e == "string" && xv.includes(e)
            }
        }
    }),
    Gr = (e, t) => {
        const r = e.__vccOpts || e;
        for (const [n, a] of t) r[n] = a;
        return r
    },
    Ji = e => (zo("data-v-65eb861b"), e = e(), Zo(), e),
    Ov = {
        class: "v3dp__heading"
    },
    Tv = ["disabled"],
    Cv = Ji(() => _("svg", {
        class: "v3dp__heading__icon",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 6 8"
    }, [_("g", {
        fill: "none",
        "fill-rule": "evenodd"
    }, [_("path", {
        stroke: "none",
        d: "M-9 16V-8h24v24z"
    }), _("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M5 0L1 4l4 4"
    })])], -1)),
    Dv = ["disabled"],
    Sv = Ji(() => _("svg", {
        class: "v3dp__heading__icon",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 6 8"
    }, [_("g", {
        fill: "none",
        "fill-rule": "evenodd"
    }, [_("path", {
        stroke: "none",
        d: "M15-8v24H-9V-8z"
    }), _("path", {
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        d: "M1 8l4-4-4-4"
    })])], -1)),
    Mv = {
        class: "v3dp__body"
    },
    Ev = {
        class: "v3dp__subheading"
    },
    Pv = Ji(() => _("hr", {
        class: "v3dp__divider"
    }, null, -1)),
    $v = {
        class: "v3dp__elements"
    },
    Fv = ["disabled", "onClick"];

function Lv(e, t, r, n, a, i) {
    return Y(), te("div", {
        class: or(["v3dp__popout", `v3dp__popout-${e.viewMode}`]),
        style: zr({
            "--popout-column-definition": `repeat(${e.columnCount}, 1fr)`
        }),
        onMousedown: t[3] || (t[3] = gr(() => {}, ["prevent"]))
    }, [_("div", Ov, [_("button", {
        class: "v3dp__heading__button v3dp__heading__button__left",
        disabled: e.leftDisabled,
        onClick: t[0] || (t[0] = gr(s => e.$emit("left"), ["stop", "prevent"]))
    }, [jr(e.$slots, "arrow-left", {}, () => [Cv], !0)], 8, Tv), (Y(), it(fa(e.headingClickable ? "button" : "span"), {
        class: "v3dp__heading__center",
        onClick: t[1] || (t[1] = gr(s => e.$emit("heading"), ["stop", "prevent"]))
    }, {
        default: Ut(() => [jr(e.$slots, "heading", {}, void 0, !0)]),
        _: 3
    })), _("button", {
        class: "v3dp__heading__button v3dp__heading__button__right",
        disabled: e.rightDisabled,
        onClick: t[2] || (t[2] = gr(s => e.$emit("right"), ["stop", "prevent"]))
    }, [jr(e.$slots, "arrow-right", {}, () => [Sv], !0)], 8, Dv)]), _("div", Mv, ["subheading" in e.$slots ? (Y(), te(Ue, {
        key: 0
    }, [_("div", Ev, [jr(e.$slots, "subheading", {}, void 0, !0)]), Pv], 64)) : et("", !0), _("div", $v, [jr(e.$slots, "body", {}, () => [(Y(!0), te(Ue, null, Cr(e.items, s => (Y(), te("button", {
        key: s.key,
        disabled: s.disabled,
        class: or([{
            selected: s.selected,
            current: s.current
        }, `v3dp__element__button__${e.viewMode}`]),
        onClick: gr(o => e.$emit("elementClick", s.value), ["stop", "prevent"])
    }, [_("span", null, ve(s.display), 1)], 10, Fv))), 128))], !0)])])], 38)
}
const Oa = Gr(kv, [
        ["render", Lv],
        ["__scopeId", "data-v-65eb861b"]
    ]),
    Av = Ht({
        components: {
            PickerPopup: Oa
        },
        emits: {
            "update:pageDate": e => yt(e),
            select: e => yt(e)
        },
        props: {
            selected: {
                type: Date,
                required: !1
            },
            pageDate: {
                type: Date,
                required: !0
            },
            lowerLimit: {
                type: Date,
                required: !1
            },
            upperLimit: {
                type: Date,
                required: !1
            }
        },
        setup(e, {
            emit: t
        }) {
            const r = z(() => wv(e.pageDate)),
                n = z(() => mm(e.pageDate)),
                a = (u, c, d) => !c && !d ? !0 : !(c && Tt(u) < Tt(c) || d && Tt(u) > Tt(d)),
                i = z(() => hm({
                    start: r.value,
                    end: n.value
                }).map(u => ({
                    value: u,
                    key: String(Tt(u)),
                    display: Tt(u),
                    selected: !!e.selected && Tt(u) === Tt(e.selected),
                    disabled: !a(u, e.lowerLimit, e.upperLimit)
                }))),
                s = z(() => {
                    const u = Tt(r.value),
                        c = Tt(n.value);
                    return `${u} - ${c}`
                }),
                o = z(() => e.lowerLimit && ($n(e.lowerLimit) === $n(e.pageDate) || bn(e.pageDate, e.lowerLimit))),
                l = z(() => e.upperLimit && ($n(e.upperLimit) === $n(e.pageDate) || yn(e.pageDate, e.upperLimit)));
            return {
                years: i,
                heading: s,
                leftDisabled: o,
                rightDisabled: l,
                previousPage: () => t("update:pageDate", lu(e.pageDate, 10)),
                nextPage: () => t("update:pageDate", Gi(e.pageDate, 10))
            }
        }
    });

function Nv(e, t, r, n, a, i) {
    const s = rr("picker-popup");
    return Y(), it(s, {
        columnCount: 3,
        leftDisabled: e.leftDisabled,
        rightDisabled: e.rightDisabled,
        items: e.years,
        viewMode: "year",
        onLeft: e.previousPage,
        onRight: e.nextPage,
        onElementClick: t[0] || (t[0] = o => e.$emit("select", o))
    }, {
        heading: Ut(() => [Pr(ve(e.heading), 1)]),
        _: 1
    }, 8, ["leftDisabled", "rightDisabled", "items", "onLeft", "onRight"])
}
const jv = Gr(Av, [
        ["render", Nv]
    ]),
    Iv = Ht({
        components: {
            PickerPopup: Oa
        },
        emits: {
            "update:pageDate": e => yt(e),
            select: e => yt(e),
            back: () => !0
        },
        props: {
            selected: {
                type: Date,
                required: !1
            },
            pageDate: {
                type: Date,
                required: !0
            },
            format: {
                type: String,
                required: !1,
                default: "LLL"
            },
            locale: {
                type: Object,
                required: !1
            },
            lowerLimit: {
                type: Date,
                required: !1
            },
            upperLimit: {
                type: Date,
                required: !1
            }
        },
        setup(e, {
            emit: t
        }) {
            const r = z(() => fm(e.pageDate)),
                n = z(() => dm(e.pageDate)),
                a = z(() => c => ea(c, e.format, {
                    locale: e.locale
                })),
                i = (c, d, h) => !d && !h ? !0 : !(d && bn(c, zl(d)) || h && yn(c, Bl(h))),
                s = z(() => cm({
                    start: r.value,
                    end: n.value
                }).map(c => ({
                    value: c,
                    display: a.value(c),
                    key: a.value(c),
                    selected: !!e.selected && gi(e.selected, c),
                    disabled: !i(c, e.lowerLimit, e.upperLimit)
                }))),
                o = z(() => Tt(r.value)),
                l = z(() => e.lowerLimit && (lo(e.lowerLimit, e.pageDate) || bn(e.pageDate, e.lowerLimit))),
                u = z(() => e.upperLimit && (lo(e.upperLimit, e.pageDate) || yn(e.pageDate, e.upperLimit)));
            return {
                months: s,
                heading: o,
                leftDisabled: l,
                rightDisabled: u,
                previousPage: () => t("update:pageDate", lu(e.pageDate, 1)),
                nextPage: () => t("update:pageDate", Gi(e.pageDate, 1))
            }
        }
    });

function Vv(e, t, r, n, a, i) {
    const s = rr("picker-popup");
    return Y(), it(s, {
        headingClickable: "",
        columnCount: 3,
        items: e.months,
        leftDisabled: e.leftDisabled,
        rightDisabled: e.rightDisabled,
        viewMode: "month",
        onLeft: e.previousPage,
        onRight: e.nextPage,
        onHeading: t[0] || (t[0] = o => e.$emit("back")),
        onElementClick: t[1] || (t[1] = o => e.$emit("select", o))
    }, {
        heading: Ut(() => [Pr(ve(e.heading), 1)]),
        _: 1
    }, 8, ["items", "leftDisabled", "rightDisabled", "onLeft", "onRight"])
}
const Rv = Gr(Iv, [
        ["render", Vv]
    ]),
    Uv = Ht({
        components: {
            PickerPopup: Oa
        },
        emits: {
            "update:pageDate": e => yt(e),
            select: e => yt(e),
            back: () => !0
        },
        props: {
            selected: {
                type: Date,
                required: !1
            },
            pageDate: {
                type: Date,
                required: !0
            },
            format: {
                type: String,
                required: !1,
                default: "dd"
            },
            headingFormat: {
                type: String,
                required: !1,
                default: "LLLL yyyy"
            },
            weekdayFormat: {
                type: String,
                required: !1,
                default: "EE"
            },
            locale: {
                type: Object,
                required: !1
            },
            weekStartsOn: {
                type: Number,
                required: !1,
                default: 1,
                validator: e => typeof e == "number" && Number.isInteger(e) && e >= 0 && e <= 6
            },
            lowerLimit: {
                type: Date,
                required: !1
            },
            upperLimit: {
                type: Date,
                required: !1
            },
            disabledDates: {
                type: Object,
                required: !1
            },
            allowOutsideInterval: {
                type: Boolean,
                required: !1,
                default: !1
            }
        },
        setup(e, {
            emit: t
        }) {
            const r = z(() => g => y => ea(y, g, {
                    locale: e.locale,
                    weekStartsOn: e.weekStartsOn
                })),
                n = z(() => zl(e.pageDate)),
                a = z(() => Bl(e.pageDate)),
                i = z(() => ({
                    start: n.value,
                    end: a.value
                })),
                s = z(() => ({
                    start: tm(n.value, {
                        weekStartsOn: e.weekStartsOn
                    }),
                    end: vm(a.value, {
                        weekStartsOn: e.weekStartsOn
                    })
                })),
                o = z(() => {
                    const g = e.weekStartsOn,
                        y = r.value(e.weekdayFormat);
                    return Array.from(Array(7)).map((k, O) => (g + O) % 7).map(k => bv(new Date, k, {
                        weekStartsOn: e.weekStartsOn
                    })).map(y)
                }),
                l = (g, y, k, O) => {
                    var U, N;
                    return (U = O == null ? void 0 : O.dates) != null && U.some(L => Wa(g, L)) || (N = O == null ? void 0 : O.predicate) != null && N.call(O, g) ? !1 : !y && !k ? !0 : !(y && bn(g, mi(y)) || k && yn(g, lm(k)))
                },
                u = z(() => {
                    const g = new Date,
                        y = r.value(e.format);
                    return um(s.value).map(k => ({
                        value: k,
                        display: y(k),
                        selected: !!e.selected && Wa(e.selected, k),
                        current: Wa(g, k),
                        disabled: !e.allowOutsideInterval && !gv(k, i.value) || !l(k, e.lowerLimit, e.upperLimit, e.disabledDates),
                        key: r.value("yyyy-MM-dd")(k)
                    }))
                }),
                c = z(() => r.value(e.headingFormat)(e.pageDate)),
                d = z(() => e.lowerLimit && (gi(e.lowerLimit, e.pageDate) || bn(e.pageDate, e.lowerLimit))),
                h = z(() => e.upperLimit && (gi(e.upperLimit, e.pageDate) || yn(e.pageDate, e.upperLimit)));
            return {
                weekDays: o,
                days: u,
                heading: c,
                leftDisabled: d,
                rightDisabled: h,
                previousPage: () => t("update:pageDate", _v(e.pageDate, 1)),
                nextPage: () => t("update:pageDate", Zi(e.pageDate, 1))
            }
        }
    });

function Yv(e, t, r, n, a, i) {
    const s = rr("picker-popup");
    return Y(), it(s, {
        headingClickable: "",
        leftDisabled: e.leftDisabled,
        rightDisabled: e.rightDisabled,
        items: e.days,
        viewMode: "day",
        onLeft: e.previousPage,
        onRight: e.nextPage,
        onHeading: t[0] || (t[0] = o => e.$emit("back")),
        onElementClick: t[1] || (t[1] = o => e.$emit("select", o))
    }, {
        heading: Ut(() => [Pr(ve(e.heading), 1)]),
        subheading: Ut(() => [(Y(!0), te(Ue, null, Cr(e.weekDays, (o, l) => (Y(), te("span", {
            key: o,
            class: or(`v3dp__subheading__weekday__${l}`)
        }, ve(o), 3))), 128))]),
        _: 1
    }, 8, ["leftDisabled", "rightDisabled", "items", "onLeft", "onRight"])
}
const qv = Gr(Uv, [
    ["render", Yv]
]);

function co(e, t) {
    const r = e.getBoundingClientRect(),
        n = {
            height: e.clientHeight,
            width: e.clientWidth
        },
        a = t.getBoundingClientRect();
    if (!(a.top >= r.top && a.bottom <= r.top + n.height)) {
        const i = a.top - r.top,
            s = a.bottom - r.bottom;
        Math.abs(i) < Math.abs(s) ? e.scrollTop += i : e.scrollTop += s
    }
}
const Wv = Ht({
        components: {
            PickerPopup: Oa
        },
        emits: {
            select: e => yt(e),
            back: () => !0
        },
        props: {
            selected: {
                type: Date,
                required: !1
            },
            pageDate: {
                type: Date,
                required: !0
            },
            visible: {
                type: Boolean,
                required: !0
            },
            disabledTime: {
                type: Object,
                required: !1
            }
        },
        setup(e, {
            emit: t
        }) {
            const r = re(null),
                n = re(null),
                a = z(() => e.pageDate ?? e.selected),
                i = re(a.value.getHours()),
                s = re(a.value.getMinutes());
            xt(() => e.selected, d => {
                let h = 0,
                    g = 0;
                d && (h = d.getHours(), g = d.getMinutes()), i.value = h, s.value = g
            });
            const o = z(() => [...Array(24).keys()].map(d => ({
                    value: d,
                    date: uo(new Date(a.value.getTime()), {
                        hours: d,
                        minutes: s.value,
                        seconds: 0
                    }),
                    selected: i.value === d,
                    ref: re(null)
                }))),
                l = z(() => [...Array(60).keys()].map(d => ({
                    value: d,
                    date: uo(new Date(a.value.getTime()), {
                        hours: i.value,
                        minutes: d,
                        seconds: 0
                    }),
                    selected: s.value === d,
                    ref: re(null)
                }))),
                u = d => {
                    s.value = d.value, t("select", d.date)
                },
                c = () => {
                    const d = o.value.find(g => {
                            var y, k;
                            return ((k = (y = g.ref.value) == null ? void 0 : y.classList) == null ? void 0 : k.contains("selected")) ?? !1
                        }),
                        h = l.value.find(g => {
                            var y, k;
                            return ((k = (y = g.ref.value) == null ? void 0 : y.classList) == null ? void 0 : k.contains("selected")) ?? !1
                        });
                    d && h && (co(r.value, d.ref.value), co(n.value, h.ref.value))
                };
            return xt(() => e.visible, d => {
                d && pt(c)
            }), {
                hoursListRef: r,
                minutesListRef: n,
                hours: i,
                minutes: s,
                hoursList: o,
                minutesList: l,
                padStartZero: d => `0${d}`.substr(-2),
                selectMinutes: u,
                isEnabled: d => {
                    var h, g, y, k;
                    return !((g = (h = e.disabledTime) == null ? void 0 : h.dates) != null && g.some(O => vv(d, O) && pv(d, O)) || (k = (y = e.disabledTime) == null ? void 0 : y.predicate) != null && k.call(y, d))
                },
                scroll: c
            }
        }
    }),
    Hv = {
        ref: "hoursListRef",
        class: "v3dp__column"
    },
    Bv = ["disabled", "onClick"],
    zv = {
        ref: "minutesListRef",
        class: "v3dp__column"
    },
    Zv = ["disabled", "onClick"];

function Gv(e, t, r, n, a, i) {
    const s = rr("picker-popup");
    return Y(), it(s, {
        headingClickable: "",
        columnCount: 2,
        leftDisabled: !0,
        rightDisabled: !0,
        viewMode: "time",
        onHeading: t[0] || (t[0] = o => e.$emit("back"))
    }, {
        heading: Ut(() => [Pr(ve(e.padStartZero(e.hours)) + ":" + ve(e.padStartZero(e.minutes)), 1)]),
        body: Ut(() => [_("div", Hv, [(Y(!0), te(Ue, null, Cr(e.hoursList, o => (Y(), te("button", {
            key: o.value,
            ref_for: !0,
            ref: o.ref,
            class: or([{
                selected: o.selected
            }, "v3dp__element_button__hour"]),
            disabled: !e.isEnabled(o.date),
            onClick: gr(l => e.hours = o.value, ["stop", "prevent"])
        }, [_("span", null, ve(e.padStartZero(o.value)), 1)], 10, Bv))), 128))], 512), _("div", zv, [(Y(!0), te(Ue, null, Cr(e.minutesList, o => (Y(), te("button", {
            key: o.value,
            ref_for: !0,
            ref: o.ref,
            class: or([{
                selected: o.selected
            }, "v3dp__element_button__minute"]),
            disabled: !e.isEnabled(o.date),
            onClick: gr(l => e.selectMinutes(o), ["stop", "prevent"])
        }, [_("span", null, ve(e.padStartZero(o.value)), 1)], 10, Zv))), 128))], 512)]),
        _: 1
    })
}
const Qv = Gr(Wv, [
        ["render", Gv],
        ["__scopeId", "data-v-81ac698d"]
    ]),
    Fn = ["time", "day", "month", "year"],
    Kv = (e, t, r = void 0) => {
        let n = r || new Date;
        return e && (n = rm([e, n])), t && (n = nm([t, n])), n
    },
    Xv = Ht({
        components: {
            YearPicker: jv,
            MonthPicker: Rv,
            DayPicker: qv,
            TimePicker: Qv
        },
        inheritAttrs: !1,
        props: {
            placeholder: {
                type: String,
                default: ""
            },
            modelValue: {
                type: Date,
                required: !1
            },
            disabledDates: {
                type: Object,
                required: !1
            },
            allowOutsideInterval: {
                type: Boolean,
                required: !1,
                default: !1
            },
            disabledTime: {
                type: Object,
                required: !1
            },
            upperLimit: {
                type: Date,
                required: !1
            },
            lowerLimit: {
                type: Date,
                required: !1
            },
            startingView: {
                type: String,
                required: !1,
                default: "day",
                validate: e => typeof e == "string" && Fn.includes(e)
            },
            startingViewDate: {
                type: Date,
                required: !1,
                default: () => new Date
            },
            dayPickerHeadingFormat: {
                type: String,
                required: !1,
                default: "LLLL yyyy"
            },
            monthListFormat: {
                type: String,
                required: !1,
                default: "LLL"
            },
            weekdayFormat: {
                type: String,
                required: !1,
                default: "EE"
            },
            dayFormat: {
                type: String,
                required: !1,
                default: "dd"
            },
            inputFormat: {
                type: String,
                required: !1,
                default: "yyyy-MM-dd"
            },
            locale: {
                type: Object,
                required: !1
            },
            weekStartsOn: {
                type: Number,
                required: !1,
                default: 1,
                validator: e => [0, 1, 2, 3, 4, 5, 6].includes(e)
            },
            disabled: {
                type: Boolean,
                required: !1,
                default: !1
            },
            clearable: {
                type: Boolean,
                required: !1,
                default: !1
            },
            typeable: {
                type: Boolean,
                required: !1,
                default: !1
            },
            minimumView: {
                type: String,
                required: !1,
                default: "day",
                validate: e => typeof e == "string" && Fn.includes(e)
            }
        },
        emits: {
            "update:modelValue": e => e == null || yt(e),
            decadePageChanged: e => !0,
            yearPageChanged: e => !0,
            monthPageChanged: e => !0,
            opened: () => !0,
            closed: () => !0
        },
        setup(e, {
            emit: t,
            attrs: r
        }) {
            const n = re("none"),
                a = re(e.startingViewDate),
                i = re(null),
                s = re(!1),
                o = re("");
            Nn(() => {
                const P = so(o.value, e.inputFormat, new Date, {
                    locale: e.locale
                });
                yt(P) && (a.value = P)
            }), Nn(() => o.value = e.modelValue && yt(e.modelValue) ? ea(e.modelValue, e.inputFormat, {
                locale: e.locale
            }) : "");
            const l = (P = "none") => {
                e.disabled || (P !== "none" && n.value === "none" && (a.value = e.modelValue || Kv(e.lowerLimit, e.upperLimit, a.value)), n.value = P, t(P !== "none" ? "opened" : "closed"))
            };
            Nn(() => {
                e.disabled && (n.value = "none")
            });
            const u = (P, E) => {
                    a.value = E, P === "year" ? t("decadePageChanged", E) : P === "month" ? t("yearPageChanged", E) : P === "day" && t("monthPageChanged", E)
                },
                c = P => {
                    a.value = P, e.minimumView === "year" ? (l("none"), t("update:modelValue", P)) : n.value = "month"
                },
                d = P => {
                    a.value = P, e.minimumView === "month" ? (l("none"), t("update:modelValue", P)) : n.value = "day"
                },
                h = P => {
                    a.value = P, e.minimumView === "day" ? (l("none"), t("update:modelValue", P)) : n.value = "time"
                },
                g = P => {
                    l("none"), t("update:modelValue", P)
                },
                y = () => {
                    e.clearable && (l("none"), t("update:modelValue", null), a.value = e.startingViewDate)
                },
                k = () => s.value = !0,
                O = () => l(L.value),
                U = () => {
                    s.value = !1, l()
                },
                N = P => {
                    const E = P.keyCode ? P.keyCode : P.which;
                    if ([27, 13].includes(E) && i.value.blur(), e.typeable) {
                        const w = so(i.value.value, e.inputFormat, new Date, {
                            locale: e.locale
                        });
                        yt(w) && o.value === ea(w, e.inputFormat, {
                            locale: e.locale
                        }) && (o.value = i.value.value, t("update:modelValue", w))
                    }
                },
                L = z(() => {
                    const P = Fn.indexOf(e.startingView),
                        E = Fn.indexOf(e.minimumView);
                    return P < E ? e.minimumView : e.startingView
                });
            return {
                blur: U,
                focus: O,
                click: k,
                input: o,
                inputRef: i,
                pageDate: a,
                renderView: l,
                updatePageDate: u,
                selectYear: c,
                selectMonth: d,
                selectDay: h,
                selectTime: g,
                keyUp: N,
                viewShown: n,
                goBackFromTimepicker: () => e.startingView === "time" && e.minimumView === "time" ? null : n.value = "day",
                clearModelValue: y,
                initialView: L,
                log: P => console.log(P),
                variables: P => Object.fromEntries(Object.entries(P ?? {}).filter(([E, w]) => E.startsWith("--")))
            }
        }
    }),
    Jv = {
        class: "v3dp__input_wrapper"
    },
    ep = ["readonly", "placeholder", "disabled", "tabindex"],
    tp = {
        class: "v3dp__clearable"
    };

function rp(e, t, r, n, a, i) {
    const s = rr("year-picker"),
        o = rr("month-picker"),
        l = rr("day-picker"),
        u = rr("time-picker");
    return Y(), te("div", {
        class: "v3dp__datepicker",
        style: zr(e.variables(e.$attrs.style))
    }, [_("div", Jv, [At(_("input", vl({
        type: "text",
        ref: "inputRef",
        readonly: !e.typeable,
        "onUpdate:modelValue": t[0] || (t[0] = c => e.input = c)
    }, e.$attrs, {
        placeholder: e.placeholder,
        disabled: e.disabled,
        tabindex: e.disabled ? -1 : 0,
        onKeyup: t[1] || (t[1] = (...c) => e.keyUp && e.keyUp(...c)),
        onBlur: t[2] || (t[2] = (...c) => e.blur && e.blur(...c)),
        onFocus: t[3] || (t[3] = (...c) => e.focus && e.focus(...c)),
        onClick: t[4] || (t[4] = (...c) => e.click && e.click(...c))
    }), null, 16, ep), [
        [Td, e.input]
    ]), At(_("div", tp, [jr(e.$slots, "clear", {
        onClear: e.clearModelValue
    }, () => [_("i", {
        onClick: t[5] || (t[5] = c => e.clearModelValue())
    }, "x")])], 512), [
        [qt, e.clearable && e.modelValue]
    ])]), At(ue(s, {
        pageDate: e.pageDate,
        "onUpdate:pageDate": t[6] || (t[6] = c => e.updatePageDate("year", c)),
        selected: e.modelValue,
        lowerLimit: e.lowerLimit,
        upperLimit: e.upperLimit,
        onSelect: e.selectYear
    }, null, 8, ["pageDate", "selected", "lowerLimit", "upperLimit", "onSelect"]), [
        [qt, e.viewShown === "year"]
    ]), At(ue(o, {
        pageDate: e.pageDate,
        "onUpdate:pageDate": t[7] || (t[7] = c => e.updatePageDate("month", c)),
        selected: e.modelValue,
        onSelect: e.selectMonth,
        lowerLimit: e.lowerLimit,
        upperLimit: e.upperLimit,
        format: e.monthListFormat,
        locale: e.locale,
        onBack: t[8] || (t[8] = c => e.viewShown = "year")
    }, null, 8, ["pageDate", "selected", "onSelect", "lowerLimit", "upperLimit", "format", "locale"]), [
        [qt, e.viewShown === "month"]
    ]), At(ue(l, {
        pageDate: e.pageDate,
        "onUpdate:pageDate": t[9] || (t[9] = c => e.updatePageDate("day", c)),
        selected: e.modelValue,
        weekStartsOn: e.weekStartsOn,
        lowerLimit: e.lowerLimit,
        upperLimit: e.upperLimit,
        headingFormat: e.dayPickerHeadingFormat,
        disabledDates: e.disabledDates,
        locale: e.locale,
        weekdayFormat: e.weekdayFormat,
        "allow-outside-interval": e.allowOutsideInterval,
        format: e.dayFormat,
        onSelect: e.selectDay,
        onBack: t[10] || (t[10] = c => e.viewShown = "month")
    }, null, 8, ["pageDate", "selected", "weekStartsOn", "lowerLimit", "upperLimit", "headingFormat", "disabledDates", "locale", "weekdayFormat", "allow-outside-interval", "format", "onSelect"]), [
        [qt, e.viewShown === "day"]
    ]), At(ue(u, {
        pageDate: e.pageDate,
        visible: e.viewShown === "time",
        selected: e.modelValue,
        disabledTime: e.disabledTime,
        onSelect: e.selectTime,
        onBack: e.goBackFromTimepicker
    }, null, 8, ["pageDate", "visible", "selected", "disabledTime", "onSelect", "onBack"]), [
        [qt, e.viewShown === "time"]
    ])], 4)
}
const np = Gr(Xv, [
    ["render", rp]
]);

function Pt(e) {
    const t = Object.prototype.toString.call(e);
    return e instanceof Date || typeof e == "object" && t === "[object Date]" ? new e.constructor(+e) : typeof e == "number" || t === "[object Number]" || typeof e == "string" || t === "[object String]" ? new Date(e) : new Date(NaN)
}

function Mr(e, t) {
    return e instanceof Date ? new e.constructor(t) : new Date(t)
}
const uu = 6048e5,
    ap = 864e5;
let ip = {};

function Ta() {
    return ip
}

function wn(e, t) {
    var o, l, u, c;
    const r = Ta(),
        n = (t == null ? void 0 : t.weekStartsOn) ?? ((l = (o = t == null ? void 0 : t.locale) == null ? void 0 : o.options) == null ? void 0 : l.weekStartsOn) ?? r.weekStartsOn ?? ((c = (u = r.locale) == null ? void 0 : u.options) == null ? void 0 : c.weekStartsOn) ?? 0,
        a = Pt(e),
        i = a.getDay(),
        s = (i < n ? 7 : 0) + i - n;
    return a.setDate(a.getDate() - s), a.setHours(0, 0, 0, 0), a
}

function na(e) {
    return wn(e, {
        weekStartsOn: 1
    })
}

function cu(e) {
    const t = Pt(e),
        r = t.getFullYear(),
        n = Mr(e, 0);
    n.setFullYear(r + 1, 0, 4), n.setHours(0, 0, 0, 0);
    const a = na(n),
        i = Mr(e, 0);
    i.setFullYear(r, 0, 4), i.setHours(0, 0, 0, 0);
    const s = na(i);
    return t.getTime() >= a.getTime() ? r + 1 : t.getTime() >= s.getTime() ? r : r - 1
}

function fo(e) {
    const t = Pt(e);
    return t.setHours(0, 0, 0, 0), t
}

function ho(e) {
    const t = Pt(e),
        r = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
    return r.setUTCFullYear(t.getFullYear()), +e - +r
}

function sp(e, t) {
    const r = fo(e),
        n = fo(t),
        a = +r - ho(r),
        i = +n - ho(n);
    return Math.round((a - i) / ap)
}

function op(e) {
    const t = cu(e),
        r = Mr(e, 0);
    return r.setFullYear(t, 0, 4), r.setHours(0, 0, 0, 0), na(r)
}

function lp(e) {
    return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]"
}

function up(e) {
    if (!lp(e) && typeof e != "number") return !1;
    const t = Pt(e);
    return !isNaN(Number(t))
}

function cp(e) {
    const t = Pt(e),
        r = Mr(e, 0);
    return r.setFullYear(t.getFullYear(), 0, 1), r.setHours(0, 0, 0, 0), r
}
const dp = {
        lessThanXSeconds: {
            one: "less than a second",
            other: "less than {{count}} seconds"
        },
        xSeconds: {
            one: "1 second",
            other: "{{count}} seconds"
        },
        halfAMinute: "half a minute",
        lessThanXMinutes: {
            one: "less than a minute",
            other: "less than {{count}} minutes"
        },
        xMinutes: {
            one: "1 minute",
            other: "{{count}} minutes"
        },
        aboutXHours: {
            one: "about 1 hour",
            other: "about {{count}} hours"
        },
        xHours: {
            one: "1 hour",
            other: "{{count}} hours"
        },
        xDays: {
            one: "1 day",
            other: "{{count}} days"
        },
        aboutXWeeks: {
            one: "about 1 week",
            other: "about {{count}} weeks"
        },
        xWeeks: {
            one: "1 week",
            other: "{{count}} weeks"
        },
        aboutXMonths: {
            one: "about 1 month",
            other: "about {{count}} months"
        },
        xMonths: {
            one: "1 month",
            other: "{{count}} months"
        },
        aboutXYears: {
            one: "about 1 year",
            other: "about {{count}} years"
        },
        xYears: {
            one: "1 year",
            other: "{{count}} years"
        },
        overXYears: {
            one: "over 1 year",
            other: "over {{count}} years"
        },
        almostXYears: {
            one: "almost 1 year",
            other: "almost {{count}} years"
        }
    },
    fp = (e, t, r) => {
        let n;
        const a = dp[e];
        return typeof a == "string" ? n = a : t === 1 ? n = a.one : n = a.other.replace("{{count}}", t.toString()), r != null && r.addSuffix ? r.comparison && r.comparison > 0 ? "in " + n : n + " ago" : n
    };

function Ba(e) {
    return (t = {}) => {
        const r = t.width ? String(t.width) : e.defaultWidth;
        return e.formats[r] || e.formats[e.defaultWidth]
    }
}
const hp = {
        full: "EEEE, MMMM do, y",
        long: "MMMM do, y",
        medium: "MMM d, y",
        short: "MM/dd/yyyy"
    },
    mp = {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
    },
    vp = {
        full: "{{date}} 'at' {{time}}",
        long: "{{date}} 'at' {{time}}",
        medium: "{{date}}, {{time}}",
        short: "{{date}}, {{time}}"
    },
    pp = {
        date: Ba({
            formats: hp,
            defaultWidth: "full"
        }),
        time: Ba({
            formats: mp,
            defaultWidth: "full"
        }),
        dateTime: Ba({
            formats: vp,
            defaultWidth: "full"
        })
    },
    gp = {
        lastWeek: "'last' eeee 'at' p",
        yesterday: "'yesterday at' p",
        today: "'today at' p",
        tomorrow: "'tomorrow at' p",
        nextWeek: "eeee 'at' p",
        other: "P"
    },
    yp = (e, t, r, n) => gp[e];

function tn(e) {
    return (t, r) => {
        const n = r != null && r.context ? String(r.context) : "standalone";
        let a;
        if (n === "formatting" && e.formattingValues) {
            const s = e.defaultFormattingWidth || e.defaultWidth,
                o = r != null && r.width ? String(r.width) : s;
            a = e.formattingValues[o] || e.formattingValues[s]
        } else {
            const s = e.defaultWidth,
                o = r != null && r.width ? String(r.width) : e.defaultWidth;
            a = e.values[o] || e.values[s]
        }
        const i = e.argumentCallback ? e.argumentCallback(t) : t;
        return a[i]
    }
}
const bp = {
        narrow: ["B", "A"],
        abbreviated: ["BC", "AD"],
        wide: ["Before Christ", "Anno Domini"]
    },
    wp = {
        narrow: ["1", "2", "3", "4"],
        abbreviated: ["Q1", "Q2", "Q3", "Q4"],
        wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    },
    _p = {
        narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
        abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    },
    xp = {
        narrow: ["S", "M", "T", "W", "T", "F", "S"],
        short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    },
    kp = {
        narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        },
        abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        },
        wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "morning",
            afternoon: "afternoon",
            evening: "evening",
            night: "night"
        }
    },
    Op = {
        narrow: {
            am: "a",
            pm: "p",
            midnight: "mi",
            noon: "n",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        },
        abbreviated: {
            am: "AM",
            pm: "PM",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        },
        wide: {
            am: "a.m.",
            pm: "p.m.",
            midnight: "midnight",
            noon: "noon",
            morning: "in the morning",
            afternoon: "in the afternoon",
            evening: "in the evening",
            night: "at night"
        }
    },
    Tp = (e, t) => {
        const r = Number(e),
            n = r % 100;
        if (n > 20 || n < 10) switch (n % 10) {
            case 1:
                return r + "st";
            case 2:
                return r + "nd";
            case 3:
                return r + "rd"
        }
        return r + "th"
    },
    Cp = {
        ordinalNumber: Tp,
        era: tn({
            values: bp,
            defaultWidth: "wide"
        }),
        quarter: tn({
            values: wp,
            defaultWidth: "wide",
            argumentCallback: e => e - 1
        }),
        month: tn({
            values: _p,
            defaultWidth: "wide"
        }),
        day: tn({
            values: xp,
            defaultWidth: "wide"
        }),
        dayPeriod: tn({
            values: kp,
            defaultWidth: "wide",
            formattingValues: Op,
            defaultFormattingWidth: "wide"
        })
    };

function rn(e) {
    return (t, r = {}) => {
        const n = r.width,
            a = n && e.matchPatterns[n] || e.matchPatterns[e.defaultMatchWidth],
            i = t.match(a);
        if (!i) return null;
        const s = i[0],
            o = n && e.parsePatterns[n] || e.parsePatterns[e.defaultParseWidth],
            l = Array.isArray(o) ? Sp(o, d => d.test(s)) : Dp(o, d => d.test(s));
        let u;
        u = e.valueCallback ? e.valueCallback(l) : l, u = r.valueCallback ? r.valueCallback(u) : u;
        const c = t.slice(s.length);
        return {
            value: u,
            rest: c
        }
    }
}

function Dp(e, t) {
    for (const r in e)
        if (Object.prototype.hasOwnProperty.call(e, r) && t(e[r])) return r
}

function Sp(e, t) {
    for (let r = 0; r < e.length; r++)
        if (t(e[r])) return r
}

function Mp(e) {
    return (t, r = {}) => {
        const n = t.match(e.matchPattern);
        if (!n) return null;
        const a = n[0],
            i = t.match(e.parsePattern);
        if (!i) return null;
        let s = e.valueCallback ? e.valueCallback(i[0]) : i[0];
        s = r.valueCallback ? r.valueCallback(s) : s;
        const o = t.slice(a.length);
        return {
            value: s,
            rest: o
        }
    }
}
const Ep = /^(\d+)(th|st|nd|rd)?/i,
    Pp = /\d+/i,
    $p = {
        narrow: /^(b|a)/i,
        abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
        wide: /^(before christ|before common era|anno domini|common era)/i
    },
    Fp = {
        any: [/^b/i, /^(a|c)/i]
    },
    Lp = {
        narrow: /^[1234]/i,
        abbreviated: /^q[1234]/i,
        wide: /^[1234](th|st|nd|rd)? quarter/i
    },
    Ap = {
        any: [/1/i, /2/i, /3/i, /4/i]
    },
    Np = {
        narrow: /^[jfmasond]/i,
        abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
        wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    },
    jp = {
        narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
        any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    },
    Ip = {
        narrow: /^[smtwf]/i,
        short: /^(su|mo|tu|we|th|fr|sa)/i,
        abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
        wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    },
    Vp = {
        narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
        any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    },
    Rp = {
        narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
        any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    },
    Up = {
        any: {
            am: /^a/i,
            pm: /^p/i,
            midnight: /^mi/i,
            noon: /^no/i,
            morning: /morning/i,
            afternoon: /afternoon/i,
            evening: /evening/i,
            night: /night/i
        }
    },
    Yp = {
        ordinalNumber: Mp({
            matchPattern: Ep,
            parsePattern: Pp,
            valueCallback: e => parseInt(e, 10)
        }),
        era: rn({
            matchPatterns: $p,
            defaultMatchWidth: "wide",
            parsePatterns: Fp,
            defaultParseWidth: "any"
        }),
        quarter: rn({
            matchPatterns: Lp,
            defaultMatchWidth: "wide",
            parsePatterns: Ap,
            defaultParseWidth: "any",
            valueCallback: e => e + 1
        }),
        month: rn({
            matchPatterns: Np,
            defaultMatchWidth: "wide",
            parsePatterns: jp,
            defaultParseWidth: "any"
        }),
        day: rn({
            matchPatterns: Ip,
            defaultMatchWidth: "wide",
            parsePatterns: Vp,
            defaultParseWidth: "any"
        }),
        dayPeriod: rn({
            matchPatterns: Rp,
            defaultMatchWidth: "any",
            parsePatterns: Up,
            defaultParseWidth: "any"
        })
    },
    qp = {
        code: "en-US",
        formatDistance: fp,
        formatLong: pp,
        formatRelative: yp,
        localize: Cp,
        match: Yp,
        options: {
            weekStartsOn: 0,
            firstWeekContainsDate: 1
        }
    };

function Wp(e) {
    const t = Pt(e);
    return sp(t, cp(t)) + 1
}

function Hp(e) {
    const t = Pt(e),
        r = +na(t) - +op(t);
    return Math.round(r / uu) + 1
}

function du(e, t) {
    var c, d, h, g;
    const r = Pt(e),
        n = r.getFullYear(),
        a = Ta(),
        i = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((d = (c = t == null ? void 0 : t.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? a.firstWeekContainsDate ?? ((g = (h = a.locale) == null ? void 0 : h.options) == null ? void 0 : g.firstWeekContainsDate) ?? 1,
        s = Mr(e, 0);
    s.setFullYear(n + 1, 0, i), s.setHours(0, 0, 0, 0);
    const o = wn(s, t),
        l = Mr(e, 0);
    l.setFullYear(n, 0, i), l.setHours(0, 0, 0, 0);
    const u = wn(l, t);
    return r.getTime() >= o.getTime() ? n + 1 : r.getTime() >= u.getTime() ? n : n - 1
}

function Bp(e, t) {
    var o, l, u, c;
    const r = Ta(),
        n = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((l = (o = t == null ? void 0 : t.locale) == null ? void 0 : o.options) == null ? void 0 : l.firstWeekContainsDate) ?? r.firstWeekContainsDate ?? ((c = (u = r.locale) == null ? void 0 : u.options) == null ? void 0 : c.firstWeekContainsDate) ?? 1,
        a = du(e, t),
        i = Mr(e, 0);
    return i.setFullYear(a, 0, n), i.setHours(0, 0, 0, 0), wn(i, t)
}

function zp(e, t) {
    const r = Pt(e),
        n = +wn(r, t) - +Bp(r, t);
    return Math.round(n / uu) + 1
}

function $e(e, t) {
    const r = e < 0 ? "-" : "",
        n = Math.abs(e).toString().padStart(t, "0");
    return r + n
}
const Kt = {
        y(e, t) {
            const r = e.getFullYear(),
                n = r > 0 ? r : 1 - r;
            return $e(t === "yy" ? n % 100 : n, t.length)
        },
        M(e, t) {
            const r = e.getMonth();
            return t === "M" ? String(r + 1) : $e(r + 1, 2)
        },
        d(e, t) {
            return $e(e.getDate(), t.length)
        },
        a(e, t) {
            const r = e.getHours() / 12 >= 1 ? "pm" : "am";
            switch (t) {
                case "a":
                case "aa":
                    return r.toUpperCase();
                case "aaa":
                    return r;
                case "aaaaa":
                    return r[0];
                case "aaaa":
                default:
                    return r === "am" ? "a.m." : "p.m."
            }
        },
        h(e, t) {
            return $e(e.getHours() % 12 || 12, t.length)
        },
        H(e, t) {
            return $e(e.getHours(), t.length)
        },
        m(e, t) {
            return $e(e.getMinutes(), t.length)
        },
        s(e, t) {
            return $e(e.getSeconds(), t.length)
        },
        S(e, t) {
            const r = t.length,
                n = e.getMilliseconds(),
                a = Math.trunc(n * Math.pow(10, r - 3));
            return $e(a, t.length)
        }
    },
    Nr = {
        am: "am",
        pm: "pm",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
    },
    mo = {
        G: function(e, t, r) {
            const n = e.getFullYear() > 0 ? 1 : 0;
            switch (t) {
                case "G":
                case "GG":
                case "GGG":
                    return r.era(n, {
                        width: "abbreviated"
                    });
                case "GGGGG":
                    return r.era(n, {
                        width: "narrow"
                    });
                case "GGGG":
                default:
                    return r.era(n, {
                        width: "wide"
                    })
            }
        },
        y: function(e, t, r) {
            if (t === "yo") {
                const n = e.getFullYear(),
                    a = n > 0 ? n : 1 - n;
                return r.ordinalNumber(a, {
                    unit: "year"
                })
            }
            return Kt.y(e, t)
        },
        Y: function(e, t, r, n) {
            const a = du(e, n),
                i = a > 0 ? a : 1 - a;
            if (t === "YY") {
                const s = i % 100;
                return $e(s, 2)
            }
            return t === "Yo" ? r.ordinalNumber(i, {
                unit: "year"
            }) : $e(i, t.length)
        },
        R: function(e, t) {
            const r = cu(e);
            return $e(r, t.length)
        },
        u: function(e, t) {
            const r = e.getFullYear();
            return $e(r, t.length)
        },
        Q: function(e, t, r) {
            const n = Math.ceil((e.getMonth() + 1) / 3);
            switch (t) {
                case "Q":
                    return String(n);
                case "QQ":
                    return $e(n, 2);
                case "Qo":
                    return r.ordinalNumber(n, {
                        unit: "quarter"
                    });
                case "QQQ":
                    return r.quarter(n, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "QQQQQ":
                    return r.quarter(n, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "QQQQ":
                default:
                    return r.quarter(n, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        q: function(e, t, r) {
            const n = Math.ceil((e.getMonth() + 1) / 3);
            switch (t) {
                case "q":
                    return String(n);
                case "qq":
                    return $e(n, 2);
                case "qo":
                    return r.ordinalNumber(n, {
                        unit: "quarter"
                    });
                case "qqq":
                    return r.quarter(n, {
                        width: "abbreviated",
                        context: "standalone"
                    });
                case "qqqqq":
                    return r.quarter(n, {
                        width: "narrow",
                        context: "standalone"
                    });
                case "qqqq":
                default:
                    return r.quarter(n, {
                        width: "wide",
                        context: "standalone"
                    })
            }
        },
        M: function(e, t, r) {
            const n = e.getMonth();
            switch (t) {
                case "M":
                case "MM":
                    return Kt.M(e, t);
                case "Mo":
                    return r.ordinalNumber(n + 1, {
                        unit: "month"
                    });
                case "MMM":
                    return r.month(n, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "MMMMM":
                    return r.month(n, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "MMMM":
                default:
                    return r.month(n, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        L: function(e, t, r) {
            const n = e.getMonth();
            switch (t) {
                case "L":
                    return String(n + 1);
                case "LL":
                    return $e(n + 1, 2);
                case "Lo":
                    return r.ordinalNumber(n + 1, {
                        unit: "month"
                    });
                case "LLL":
                    return r.month(n, {
                        width: "abbreviated",
                        context: "standalone"
                    });
                case "LLLLL":
                    return r.month(n, {
                        width: "narrow",
                        context: "standalone"
                    });
                case "LLLL":
                default:
                    return r.month(n, {
                        width: "wide",
                        context: "standalone"
                    })
            }
        },
        w: function(e, t, r, n) {
            const a = zp(e, n);
            return t === "wo" ? r.ordinalNumber(a, {
                unit: "week"
            }) : $e(a, t.length)
        },
        I: function(e, t, r) {
            const n = Hp(e);
            return t === "Io" ? r.ordinalNumber(n, {
                unit: "week"
            }) : $e(n, t.length)
        },
        d: function(e, t, r) {
            return t === "do" ? r.ordinalNumber(e.getDate(), {
                unit: "date"
            }) : Kt.d(e, t)
        },
        D: function(e, t, r) {
            const n = Wp(e);
            return t === "Do" ? r.ordinalNumber(n, {
                unit: "dayOfYear"
            }) : $e(n, t.length)
        },
        E: function(e, t, r) {
            const n = e.getDay();
            switch (t) {
                case "E":
                case "EE":
                case "EEE":
                    return r.day(n, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "EEEEE":
                    return r.day(n, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "EEEEEE":
                    return r.day(n, {
                        width: "short",
                        context: "formatting"
                    });
                case "EEEE":
                default:
                    return r.day(n, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        e: function(e, t, r, n) {
            const a = e.getDay(),
                i = (a - n.weekStartsOn + 8) % 7 || 7;
            switch (t) {
                case "e":
                    return String(i);
                case "ee":
                    return $e(i, 2);
                case "eo":
                    return r.ordinalNumber(i, {
                        unit: "day"
                    });
                case "eee":
                    return r.day(a, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "eeeee":
                    return r.day(a, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "eeeeee":
                    return r.day(a, {
                        width: "short",
                        context: "formatting"
                    });
                case "eeee":
                default:
                    return r.day(a, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        c: function(e, t, r, n) {
            const a = e.getDay(),
                i = (a - n.weekStartsOn + 8) % 7 || 7;
            switch (t) {
                case "c":
                    return String(i);
                case "cc":
                    return $e(i, t.length);
                case "co":
                    return r.ordinalNumber(i, {
                        unit: "day"
                    });
                case "ccc":
                    return r.day(a, {
                        width: "abbreviated",
                        context: "standalone"
                    });
                case "ccccc":
                    return r.day(a, {
                        width: "narrow",
                        context: "standalone"
                    });
                case "cccccc":
                    return r.day(a, {
                        width: "short",
                        context: "standalone"
                    });
                case "cccc":
                default:
                    return r.day(a, {
                        width: "wide",
                        context: "standalone"
                    })
            }
        },
        i: function(e, t, r) {
            const n = e.getDay(),
                a = n === 0 ? 7 : n;
            switch (t) {
                case "i":
                    return String(a);
                case "ii":
                    return $e(a, t.length);
                case "io":
                    return r.ordinalNumber(a, {
                        unit: "day"
                    });
                case "iii":
                    return r.day(n, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "iiiii":
                    return r.day(n, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "iiiiii":
                    return r.day(n, {
                        width: "short",
                        context: "formatting"
                    });
                case "iiii":
                default:
                    return r.day(n, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        a: function(e, t, r) {
            const a = e.getHours() / 12 >= 1 ? "pm" : "am";
            switch (t) {
                case "a":
                case "aa":
                    return r.dayPeriod(a, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "aaa":
                    return r.dayPeriod(a, {
                        width: "abbreviated",
                        context: "formatting"
                    }).toLowerCase();
                case "aaaaa":
                    return r.dayPeriod(a, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "aaaa":
                default:
                    return r.dayPeriod(a, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        b: function(e, t, r) {
            const n = e.getHours();
            let a;
            switch (n === 12 ? a = Nr.noon : n === 0 ? a = Nr.midnight : a = n / 12 >= 1 ? "pm" : "am", t) {
                case "b":
                case "bb":
                    return r.dayPeriod(a, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "bbb":
                    return r.dayPeriod(a, {
                        width: "abbreviated",
                        context: "formatting"
                    }).toLowerCase();
                case "bbbbb":
                    return r.dayPeriod(a, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "bbbb":
                default:
                    return r.dayPeriod(a, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        B: function(e, t, r) {
            const n = e.getHours();
            let a;
            switch (n >= 17 ? a = Nr.evening : n >= 12 ? a = Nr.afternoon : n >= 4 ? a = Nr.morning : a = Nr.night, t) {
                case "B":
                case "BB":
                case "BBB":
                    return r.dayPeriod(a, {
                        width: "abbreviated",
                        context: "formatting"
                    });
                case "BBBBB":
                    return r.dayPeriod(a, {
                        width: "narrow",
                        context: "formatting"
                    });
                case "BBBB":
                default:
                    return r.dayPeriod(a, {
                        width: "wide",
                        context: "formatting"
                    })
            }
        },
        h: function(e, t, r) {
            if (t === "ho") {
                let n = e.getHours() % 12;
                return n === 0 && (n = 12), r.ordinalNumber(n, {
                    unit: "hour"
                })
            }
            return Kt.h(e, t)
        },
        H: function(e, t, r) {
            return t === "Ho" ? r.ordinalNumber(e.getHours(), {
                unit: "hour"
            }) : Kt.H(e, t)
        },
        K: function(e, t, r) {
            const n = e.getHours() % 12;
            return t === "Ko" ? r.ordinalNumber(n, {
                unit: "hour"
            }) : $e(n, t.length)
        },
        k: function(e, t, r) {
            let n = e.getHours();
            return n === 0 && (n = 24), t === "ko" ? r.ordinalNumber(n, {
                unit: "hour"
            }) : $e(n, t.length)
        },
        m: function(e, t, r) {
            return t === "mo" ? r.ordinalNumber(e.getMinutes(), {
                unit: "minute"
            }) : Kt.m(e, t)
        },
        s: function(e, t, r) {
            return t === "so" ? r.ordinalNumber(e.getSeconds(), {
                unit: "second"
            }) : Kt.s(e, t)
        },
        S: function(e, t) {
            return Kt.S(e, t)
        },
        X: function(e, t, r) {
            const n = e.getTimezoneOffset();
            if (n === 0) return "Z";
            switch (t) {
                case "X":
                    return po(n);
                case "XXXX":
                case "XX":
                    return mr(n);
                case "XXXXX":
                case "XXX":
                default:
                    return mr(n, ":")
            }
        },
        x: function(e, t, r) {
            const n = e.getTimezoneOffset();
            switch (t) {
                case "x":
                    return po(n);
                case "xxxx":
                case "xx":
                    return mr(n);
                case "xxxxx":
                case "xxx":
                default:
                    return mr(n, ":")
            }
        },
        O: function(e, t, r) {
            const n = e.getTimezoneOffset();
            switch (t) {
                case "O":
                case "OO":
                case "OOO":
                    return "GMT" + vo(n, ":");
                case "OOOO":
                default:
                    return "GMT" + mr(n, ":")
            }
        },
        z: function(e, t, r) {
            const n = e.getTimezoneOffset();
            switch (t) {
                case "z":
                case "zz":
                case "zzz":
                    return "GMT" + vo(n, ":");
                case "zzzz":
                default:
                    return "GMT" + mr(n, ":")
            }
        },
        t: function(e, t, r) {
            const n = Math.trunc(e.getTime() / 1e3);
            return $e(n, t.length)
        },
        T: function(e, t, r) {
            const n = e.getTime();
            return $e(n, t.length)
        }
    };

function vo(e, t = "") {
    const r = e > 0 ? "-" : "+",
        n = Math.abs(e),
        a = Math.trunc(n / 60),
        i = n % 60;
    return i === 0 ? r + String(a) : r + String(a) + t + $e(i, 2)
}

function po(e, t) {
    return e % 60 === 0 ? (e > 0 ? "-" : "+") + $e(Math.abs(e) / 60, 2) : mr(e, t)
}

function mr(e, t = "") {
    const r = e > 0 ? "-" : "+",
        n = Math.abs(e),
        a = $e(Math.trunc(n / 60), 2),
        i = $e(n % 60, 2);
    return r + a + t + i
}
const go = (e, t) => {
        switch (e) {
            case "P":
                return t.date({
                    width: "short"
                });
            case "PP":
                return t.date({
                    width: "medium"
                });
            case "PPP":
                return t.date({
                    width: "long"
                });
            case "PPPP":
            default:
                return t.date({
                    width: "full"
                })
        }
    },
    fu = (e, t) => {
        switch (e) {
            case "p":
                return t.time({
                    width: "short"
                });
            case "pp":
                return t.time({
                    width: "medium"
                });
            case "ppp":
                return t.time({
                    width: "long"
                });
            case "pppp":
            default:
                return t.time({
                    width: "full"
                })
        }
    },
    Zp = (e, t) => {
        const r = e.match(/(P+)(p+)?/) || [],
            n = r[1],
            a = r[2];
        if (!a) return go(e, t);
        let i;
        switch (n) {
            case "P":
                i = t.dateTime({
                    width: "short"
                });
                break;
            case "PP":
                i = t.dateTime({
                    width: "medium"
                });
                break;
            case "PPP":
                i = t.dateTime({
                    width: "long"
                });
                break;
            case "PPPP":
            default:
                i = t.dateTime({
                    width: "full"
                });
                break
        }
        return i.replace("{{date}}", go(n, t)).replace("{{time}}", fu(a, t))
    },
    Gp = {
        p: fu,
        P: Zp
    },
    Qp = /^D+$/,
    Kp = /^Y+$/,
    Xp = ["D", "DD", "YY", "YYYY"];

function Jp(e) {
    return Qp.test(e)
}

function eg(e) {
    return Kp.test(e)
}

function tg(e, t, r) {
    const n = rg(e, t, r);
    if (console.warn(n), Xp.includes(e)) throw new RangeError(n)
}

function rg(e, t, r) {
    const n = e[0] === "Y" ? "years" : "days of the month";
    return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${n} to the input \`${r}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
const ng = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
    ag = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
    ig = /^'([^]*?)'?$/,
    sg = /''/g,
    og = /[a-zA-Z]/;

function lg(e, t, r) {
    var c, d, h, g, y, k, O, U;
    const n = Ta(),
        a = (r == null ? void 0 : r.locale) ?? n.locale ?? qp,
        i = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((d = (c = r == null ? void 0 : r.locale) == null ? void 0 : c.options) == null ? void 0 : d.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((g = (h = n.locale) == null ? void 0 : h.options) == null ? void 0 : g.firstWeekContainsDate) ?? 1,
        s = (r == null ? void 0 : r.weekStartsOn) ?? ((k = (y = r == null ? void 0 : r.locale) == null ? void 0 : y.options) == null ? void 0 : k.weekStartsOn) ?? n.weekStartsOn ?? ((U = (O = n.locale) == null ? void 0 : O.options) == null ? void 0 : U.weekStartsOn) ?? 0,
        o = Pt(e);
    if (!up(o)) throw new RangeError("Invalid time value");
    let l = t.match(ag).map(N => {
        const L = N[0];
        if (L === "p" || L === "P") {
            const P = Gp[L];
            return P(N, a.formatLong)
        }
        return N
    }).join("").match(ng).map(N => {
        if (N === "''") return {
            isToken: !1,
            value: "'"
        };
        const L = N[0];
        if (L === "'") return {
            isToken: !1,
            value: ug(N)
        };
        if (mo[L]) return {
            isToken: !0,
            value: N
        };
        if (L.match(og)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + L + "`");
        return {
            isToken: !1,
            value: N
        }
    });
    a.localize.preprocessor && (l = a.localize.preprocessor(o, l));
    const u = {
        firstWeekContainsDate: i,
        weekStartsOn: s,
        locale: a
    };
    return l.map(N => {
        if (!N.isToken) return N.value;
        const L = N.value;
        (!(r != null && r.useAdditionalWeekYearTokens) && eg(L) || !(r != null && r.useAdditionalDayOfYearTokens) && Jp(L)) && tg(L, t, String(e));
        const P = mo[L[0]];
        return P(o, L, a.localize, u)
    }).join("")
}

function ug(e) {
    const t = e.match(ig);
    return t ? t[1].replace(sg, "'") : e
}
const cg = {
        class: "mt-40 animate__animated animate__fadeInLeft animate__faster"
    },
    dg = {
        class: "text-white font-bold text-xl opacity-40 m-2 drop-shadow-md uppercase"
    },
    fg = {
        class: "main-color mb-4 w-1/5 p-9 rounded flex flex-col"
    },
    hg = {
        class: "text-white text-xl font-bold font-sans opacity-90 mb-5"
    },
    mg = {
        class: "flex"
    },
    vg = {
        class: "inline-flex items-center px-3 text-sm main-color-2 text-white rounded-l-md"
    },
    pg = {
        class: "relative flex-1"
    },
    gg = {
        class: "mb-4 mt-1"
    },
    yg = {
        class: "flex"
    },
    bg = {
        class: "inline-flex items-center px-3 text-sm main-color-2 text-white rounded-l-md"
    },
    wg = {
        class: "mb-4 mt-1"
    },
    _g = {
        class: "flex"
    },
    xg = {
        class: "inline-flex items-center px-3 text-sm main-color-2 text-white rounded-l-md"
    },
    kg = {
        value: ""
    },
    Og = {
        value: "m"
    },
    Tg = {
        value: "f"
    },
    Cg = {
        class: "mb-4 mt-1"
    },
    Dg = {
        class: "flex"
    },
    Sg = {
        class: "inline-flex items-center px-3 text-sm main-color-2 text-white rounded-l-md"
    },
    Mg = {
        class: "mb-4 mt-1"
    },
    Eg = {
        key: 0,
        class: "text-white text-xs bg-red-500 p-1 rounded mt-2"
    },
    Pg = {
        class: "flex items-center justify-center mt-10"
    },
    $g = {
        type: "submit",
        class: "uppercase bg-gray-600 hover:bg-green-700 text-white font-bold p-3 rounded transition-colors duration-200 flex items-center justify-center"
    },
    Fg = {
        __name: "CharacterRegister",
        props: {
            generateCID: {
                type: Number,
                required: !0
            },
            Lang: {
                type: Object,
                required: !0
            }
        },
        setup(e) {
            const t = re(null),
                r = re(!1),
                n = re(!1),
                a = re({
                    "--vdp-bg-color": "#16191c",
                    "--vdp-text-color": "#dedede",
                    "--vdp-box-shadow": "0 2px 5px 0 rgba(128, 144, 160, 0.1), 0 0 1px 0 rgba(128, 144, 160, 0.81)",
                    "--vdp-border-radius": "6px",
                    "--vdp-heading-size": "2.5em",
                    "--vdp-heading-weight": "bold",
                    "--vdp-heading-hover-color": "#292e32",
                    "--vdp-arrow-color": "currentColor",
                    "--vdp-elem-color": "currentColor",
                    "--vdp-disabled-color": "#d5d9e0",
                    "--vdp-hover-color": "#ffffff",
                    "--vdp-hover-bg-color": "#0baf74",
                    "--vdp-selected-color": "#ffffff",
                    "--vdp-selected-bg-color": "#0baf74",
                    "--vdp-current-date-outline-color": "#16191c",
                    "--vdp-current-date-font-weight": "bold",
                    "--vdp-elem-font-size": "0.8em",
                    "--vdp-elem-border-radius": "3px",
                    "--vdp-divider-color": "#6b6b6b"
                }),
                i = e,
                s = ql({
                    firstName: hi().min(1, "min 3 character").max(30, "max 30 character").required("required field").matches(/^[\p{L} ]+$/u, "You can't use special characters").test("bad-word-check", "The name contains forbidden words", c => !Xs.some(d => c.toLowerCase() === d.toLowerCase())),
                    lastName: hi().min(1, "min 3 character").max(30, "max 30 character").required("required field").matches(/^[\p{L} ]+$/u, "You can't use special characters").test("bad-word-check", "The name contains forbidden words", c => !Xs.some(d => c.toLowerCase() === d.toLowerCase())),
                    sex: Vl("required field").oneOf(["m", "f"], "required field").defined("required field")
                });

            function o(c) {
                return c.charAt(0).toUpperCase() + c.slice(1)
            }
            async function l(c) {
                try {
                    const d = await fetch(`https://${GetParentResourceName()}/register`, {
                        method: "post",
                        headers: {
                            "Content-Type": "application/json; charset=UTF-8"
                        },
                        body: JSON.stringify(c)
                    });
                    if (!d.ok) {
                        const h = d.status;
                        if (h === 404) return console.error(`^1  1- check esx_identity
 ^3 2- and make sure it works
 ^3 3- check your last edit line for identity
 ^3 4- you may have put an extra end in the code
 ^3 or check for quick solution
 ^2 https://docs.uyuyorumstore.com/scripts/um-multicharacter/syntaxerror`);
                        throw new Error("Failed to fetch data from NUI" + h)
                    }
                    return await d.json()
                } catch {
                    return console.error(`^1  1- check esx_identity
 ^3 2- and make sure it works
 ^3 3- check your last edit line for identity
 ^3 4- you may have put an extra end in the code
 ^3 or check for quick solution
 ^2 https://docs.uyuyorumstore.com/scripts/um-multicharacter/syntaxerror`)
                }
            }

            function u(c) {
                if (t.value) r.value = !1;
                else return r.value = !0;
                if (n.value) return;
                const d = lg(t.value, "dd/MM/yyyy");
                l({
                    firstname: o(c.firstName),
                    lastname: o(c.lastName),
                    dateofbirth: d,
                    sex: c.sex,
                    height: 210,
                    cid: i.generateCID.toString()
                })
            }
            return (c, d) => (Y(), te("div", cg, [_("h1", dg, ve(e.Lang.title), 1), _("div", fg, [_("h1", hg, ve(e.Lang.subtitle), 1), ue(q(Jf), {
                onSubmit: u,
                "validation-schema": q(s)
            }, {
                default: Ut(() => [_("div", mg, [_("span", vg, [ue(q(Ls), {
                    class: "h-5 w-5 text-gray-300"
                })]), _("div", pg, [ue(q(Ra), {
                    name: "firstName",
                    type: "text",
                    class: "capitalize rounded-none rounded-r-lg main-color-2 text-white block w-full text-sm p-2.5",
                    placeholder: e.Lang.firstname
                }, null, 8, ["placeholder"])])]), _("div", gg, [ue(q(Ua), {
                    name: "firstName",
                    class: "text-white text-xs bg-red-500 p-1 rounded mt-2"
                })]), _("div", yg, [_("span", bg, [ue(q(Ls), {
                    class: "h-5 w-5 text-gray-300"
                })]), ue(q(Ra), {
                    name: "lastName",
                    type: "text",
                    class: "capitalize rounded-none rounded-r-lg main-color-2 text-white block flex-1 min-w-0 w-full text-sm p-2.5",
                    placeholder: e.Lang.lastname
                }, null, 8, ["placeholder"])]), _("div", wg, [ue(q(Ua), {
                    name: "lastName",
                    class: "text-white text-xs bg-red-500 p-1 rounded mt-2"
                })]), _("div", _g, [_("span", xg, [ue(q(Qd), {
                    class: "h-5 w-5 text-gray-300"
                })]), ue(q(Ra), {
                    name: "sex",
                    as: "select",
                    class: "rounded-none rounded-r-lg main-color-2 text-gray-400 block flex-1 min-w-0 w-full text-sm p-2.5"
                }, {
                    default: Ut(() => [_("option", kg, ve(e.Lang.gender.type), 1), _("option", Og, ve(e.Lang.gender.male), 1), _("option", Tg, ve(e.Lang.gender.female), 1)]),
                    _: 1
                })]), _("div", Cg, [ue(q(Ua), {
                    name: "sex",
                    class: "text-white text-xs bg-red-500 p-1 rounded mt-2"
                })]), _("div", Dg, [_("span", Sg, [ue(q(wl), {
                    class: "h-5 w-5 text-gray-300"
                })]), ue(q(np), {
                    style: zr(a.value),
                    modelValue: t.value,
                    "onUpdate:modelValue": d[0] || (d[0] = h => t.value = h),
                    class: "rounded-none rounded-r-lg main-color-2 text-white block flex-1 min-w-0 w-full text-sm p-2.5",
                    placeholder: e.Lang.dob
                }, null, 8, ["style", "modelValue", "placeholder"])]), _("div", Mg, [r.value ? (Y(), te("span", Eg, "required field")) : et("", !0)]), _("div", Pg, [_("button", $g, [ue(q(Ud), {
                    class: "h-6 w-7 text-gray-300 text-center"
                }), Pr(" " + ve(e.Lang.button), 1)])])]),
                _: 1
            }, 8, ["validation-schema"])])]))
        }
    },
    Lg = Zr(Fg, [
        ["__scopeId", "data-v-0f06d93a"]
    ]),
    Ag = ["default", "ArenaEMP", "ArenaEMP_Blend", "beastLaunch01", "beastLaunch02", "BikerFormFlash", "BikersSPLASH", "BombCamFlash", "casino_mainfloor", "cinema", "CrossLine01", "CrossLine02", "dont_tazeme_bro", "dont_tazeme_bro_b", "drug_flying_base", "FIB_A", "Forest", "hud_def_flash", "InchOrange01", "InchOrange02", "LectroDark"],
    Ng = {
        class: "fixed top-0 left-0 w-full h-full bg-gray-500 bg-opacity-50 animate__animated animate__fadeIn"
    },
    jg = {
        class: "flex py-4 justify-center overflow-x-auto animate__animated animate__fadeIn"
    },
    Ig = ["onClick"],
    Vg = ["src"],
    Rg = {
        class: "flex main-color rounded opacity-80 justify-center items-center p-3 hover:bg-gray-500 hover:text-black transition-colors duration-200"
    },
    Ug = {
        __name: "PhotoMode",
        props: {
            Lang: {
                type: Object,
                required: !0
            }
        },
        setup(e) {
            const t = re(!1),
                r = n => {
                    kr("photoFilter", n), wt("filtersound")
                };
            return (n, a) => (Y(), te("div", Ng, [At(_("div", jg, [(Y(!0), te(Ue, null, Cr(q(Ag), (i, s) => (Y(), te("button", {
                key: s,
                class: "relative mx-2 px-6 py-5 text-white rounded-lg border border-gray-300 focus:outline-none flex flex-col items-center transition transform hover:scale-150 duration-200",
                onClick: o => r(i)
            }, [_("img", {
                src: `./filters/${i}.png`,
                alt: "filter image",
                class: "absolute inset-0 w-20 h-full object-cover rounded-lg"
            }, null, 8, Vg)], 8, Ig))), 128))], 512), [
                [qt, !t.value]
            ]), _("div", {
                class: "flex py-4 justify-center items-center cursor-pointer text-gray-300",
                onClick: a[0] || (a[0] = i => t.value = !t.value)
            }, [_("div", Rg, [ue(q(Rd), {
                class: "h-6 w-7 text-center hover:text-black"
            }), _("small", null, ve(e.Lang.info), 1)])])]))
        }
    },
    Yg = Zr(Ug, [
        ["__scopeId", "data-v-4f9c9f43"]
    ]),
    qg = {
        class: "relative h-screen bg-black text-white bg-opacity-90 flex items-center justify-center overflow-hidden animate__animated animate__fadeIn"
    },
    Wg = {
        class: "animate-credits text-center"
    },
    Hg = {
        class: "text-1xl font-bold"
    },
    Bg = {
        __name: "Credits",
        props: {
            creditsList: {
                type: Array,
                required: !0
            }
        },
        setup(e) {
            return (t, r) => (Y(), te("div", qg, [_("div", Wg, [(Y(!0), te(Ue, null, Cr(e.creditsList, (n, a) => (Y(), te("div", {
                key: a,
                class: "py-2 mt-5"
            }, [_("div", Hg, ve(n.title), 1), (Y(!0), te(Ue, null, Cr(n.users, (i, s) => (Y(), te("div", {
                key: s
            }, ve(i), 1))), 128))]))), 128))])]))
        }
    },
    zg = Zr(Bg, [
        ["__scopeId", "data-v-273f220c"]
    ]),
    Zg = {
        class: "absolute inset-0 w-full h-full bg-black animate__animated animate__fadeIn"
    },
    Gg = ["src"],
    Qg = {
        __name: "Store",
        props: {
            pageURL: {
                type: String,
                required: !0
            }
        },
        emits: ["go-back"],
        setup(e, {
            emit: t
        }) {
            const r = re(!1),
                n = () => {
                    r.value = !0
                },
                a = () => {
                    i("go-back", !1)
                },
                i = t;
            return (s, o) => (Y(), te(Ue, null, [_("div", Zg, [_("iframe", {
                class: "absolute inset-0 w-full h-full",
                src: e.pageURL,
                onLoad: n
            }, null, 40, Gg)]), r.value ? (Y(), te("button", {
                key: 0,
                class: "fixed top-4 left-4 px-4 py-2 main-color text-white rounded shadow hover:bg-gray-600 transition-colors duration-200",
                onClick: a
            }, [ue(q(Vd), {
                class: "w-15 h-9 text-white font-bold"
            })])) : et("", !0)], 64))
        }
    },
    Kg = {
        class: "mt-10 text-center uppercase"
    },
    Xg = {
        class: "text-gray-300 font-bold text-2xl opacity-60 m-2 drop-shadow-md p-3 rounded items-center justify-center uppercase"
    },
    Jg = {
        class: "mt-10 text-center uppercase"
    },
    ey = {
        class: "text-center uppercase"
    },
    ty = {
        __name: "DeleteCharacter",
        props: {
            remeainSlot: {
                type: Number,
                required: !0
            },
            Lang: {
                type: Object,
                required: !0
            },
            citizenid: {
                type: String,
                required: !0
            }
        },
        emits: ["button-menu-status"],
        setup(e, {
            emit: t
        }) {
            const r = () => {
                    n("button-menu-status", !1), wt("selectsound")
                },
                n = t;
            return (a, i) => (Y(), te(Ue, null, [_("div", Kg, [_("span", Xg, ve(e.Lang.title), 1)]), _("div", Jg, [_("button", {
                onMouseover: i[0] || (i[0] = s => q(wt)("hoversound")),
                onClick: i[1] || (i[1] = s => q(kr)("deleteCharacter", e.citizenid)),
                class: "text-white font-bold text-2xl opacity-80 m-2 drop-shadow-md hover:text-gray-500 p-3 rounded transition-colors duration-200 items-center justify-center uppercase"
            }, ve(e.Lang.yes), 33)]), _("div", ey, [_("button", {
                onMouseover: i[2] || (i[2] = s => q(wt)("hoversound")),
                onClick: i[3] || (i[3] = s => r()),
                class: "text-white font-bold text-2xl opacity-80 m-2 drop-shadow-md hover:text-gray-500 p-3 rounded transition-colors duration-200 items-center justify-center uppercase"
            }, ve(e.Lang.no), 33)])], 64))
        }
    },
    ry = {},
    ny = {
        class: "relative w-full h-screen"
    },
    ay = _("div", {
        class: "absolute w-full h-24 bg-black top-0"
    }, null, -1),
    iy = _("div", {
        class: "absolute w-full h-24 bg-black bottom-0"
    }, null, -1),
    sy = [ay, iy];

function oy(e, t) {
    return Y(), te("div", ny, sy)
}
const ly = Zr(ry, [
        ["render", oy]
    ]),
    uy = e => (zo("data-v-05b8bbe1"), e = e(), Zo(), e),
    cy = {
        class: "absolute right-60 top-40 z-[100] uppercase animate__animated animate__fadeIn"
    },
    dy = {
        key: 0,
        class: "max-w-xl"
    },
    fy = {
        class: "flex text-white text-xs text-right font-bold p-5 rounded opacity-80 items-center font-sans m-1 flex-col"
    },
    hy = {
        class: "text-3xl drop-shadow"
    },
    my = {
        class: "text-8xl drop-shadow"
    },
    vy = {
        class: "flex items-center justify-center opacity-80 main-color rounded mw500"
    },
    py = {
        class: "flex p-2 text-white rounded text-xs items-center m-1 flex-col"
    },
    gy = {
        class: "drop-shadow font-bold"
    },
    yy = {
        class: "flex p-2 text-white rounded text-xs items-center m-1 flex-col"
    },
    by = {
        class: "drop-shadow font-bold"
    },
    wy = {
        class: "flex p-2 text-white rounded text-xs items-center m-1 flex-col"
    },
    _y = {
        class: "drop-shadow font-bold"
    },
    xy = {
        class: "flex p-2 text-white rounded text-xs items-center m-1 flex-col"
    },
    ky = {
        class: "drop-shadow font-bold"
    },
    Oy = {
        class: "flex p-2 text-white rounded text-xs items-center m-1 flex-col min-w-10"
    },
    Ty = {
        class: "drop-shadow font-bold"
    },
    Cy = {
        class: "flex p-2 text-white rounded text-xs items-center m-1 flex-col"
    },
    Dy = {
        class: "drop-shadow font-bold"
    },
    Sy = {
        key: 0,
        class: "flex items-center text-white mt-2 justify-end opacity-80"
    },
    My = {
        key: 1,
        class: "flex items-center justify-center mt-1 opacity-80"
    },
    Ey = {
        key: 1,
        class: "mw15"
    },
    Py = uy(() => _("img", {
        src: bl,
        class: "w-full mh305"
    }, null, -1)),
    $y = [Py],
    Fy = {
        __name: "CharacterInfo",
        props: {
            myCharacters: {
                type: Object,
                required: !0
            },
            remeainSlot: {
                type: Number,
                required: !0
            },
            deleteButtonStatus: {
                type: Boolean,
                required: !0
            },
            Lang: {
                type: Object,
                required: !0
            },
            pagesList: {
                type: Object,
                required: !0
            },
            speechList: {
                type: Object,
                required: !0
            },
            cinematicStatus: {
                type: Boolean,
                required: !0
            }
        },
        setup(e) {
            const t = re(0),
                r = e,
                n = re(!1),
                a = re(!1),
                i = re(!1),
                s = re(!1),
                o = re(!1),
                l = re(0),
                u = re(0),
                c = re(!1),
                d = re(0);
            pt(() => {
                var E;
                if (r.myCharacters.length >= 1 && Array.isArray(r.myCharacters)) {
                    for (let w = 0; w < r.myCharacters.length; w++)
                        if (((E = r.myCharacters[w]) == null ? void 0 : E.cid) !== void 0) {
                            kr("characterGenerate", r.myCharacters[w].identifier), l.value = w, u.value = r.myCharacters.filter(G => G != null).length;
                            break
                        } if (r.speechList.Status) {
                        const w = r.speechList.Texts;
                        let G = Math.floor(Math.random() * w.length),
                            he = w[G].replace("[name]", r.myCharacters[l.value].firstname);
                        P(he)
                    }
                }
            });
            const h = async E => {
                let w = l.value;
                do w = (w + E + r.myCharacters.length) % r.myCharacters.length; while (!r.myCharacters[w]);
                await kr("characterGenerate", r.myCharacters[w].identifier), l.value = w, c.value && L(!0, r.myCharacters[w].identifier)
            };

            function g() {
                var w;
                let E = [];
                for (let G in r.myCharacters) r.myCharacters[G] && E.push(Number(r.myCharacters[G].cid !== void 0 ? r.myCharacters[G].cid : (w = r.myCharacters[G].charinfo) == null ? void 0 : w.cid));
                if (E.sort((G, se) => G - se), E[0] !== 1) return 1;
                for (let G = 0; G < E.length - 1; G++)
                    if (E[G + 1] - E[G] > 1) return E[G] + 1;
                return E[E.length - 1] + 1
            }
            const y = E => {
                    r.myCharacters.length >= 1 ? t.value = g() : t.value = 1, o.value = E
                },
                k = E => {
                    E.key === "Escape" && (s.value = !1, n.value = !1, a.value = !1)
                },
                O = (E, w) => {
                    s.value = E, o.value = !1, w === "photo" ? n.value = E : w === "credits" && (a.value = E), E ? document.addEventListener("keydown", k) : document.removeEventListener("keydown", k)
                },
                U = E => {
                    s.value = E, i.value = E, o.value = !1
                },
                N = () => {
                    if (r.myCharacters[l.value] && r.myCharacters[l.value].identifier) kr("playGame", {
                        data: r.myCharacters[l.value]
                    });
                    else {
                        let E = !1;
                        E = !E, y(E)
                    }
                },
                L = (E, w) => {
                    d.value = w, c.value = E
                },
                P = E => {
                    const w = new SpeechSynthesisUtterance(E);
                    w.volume = r.speechList.Volume, w.rate = r.speechList.Rate, w.pitch = r.speechList.Pitch, speechSynthesis.speak(w)
                };
            return (E, w) => (Y(), te(Ue, null, [At(_("div", cy, [e.myCharacters[l.value] ? (Y(), te("div", dy, [_("div", fy, [_("h1", hy, ve(e.myCharacters[l.value].firstname), 1), _("h1", my, ve(e.myCharacters[l.value].lastname), 1)]), _("div", vy, [_("div", py, [ue(q(Bd), {
                class: "w-5 h-8 text-white mr-1"
            }), _("span", gy, ve(e.myCharacters[l.value].cid), 1)]), _("div", yy, [ue(q(Zd), {
                class: "w-5 h-8 text-white mr-1"
            }), _("span", by, ve(e.myCharacters[l.value].job), 1)]), _("div", wy, [ue(q(zd), {
                class: "w-5 h-8 text-white mr-1"
            }), _("span", _y, ve(e.myCharacters[l.value].height), 1)]), _("div", xy, [ue(q(wl), {
                class: "w-5 h-8 text-white mr-1"
            }), _("span", ky, ve(e.myCharacters[l.value].dateofbirth), 1)]), _("div", Oy, [ue(q(Hd), {
                class: "w-5 h-8 text-white mr-1"
            }), _("span", Ty, ve(e.myCharacters[l.value].accounts.money), 1)]), _("div", Cy, [ue(q(Wd), {
                class: "w-5 h-8 text-white mr-1"
            }), _("span", Dy, ve(e.myCharacters[l.value].accounts.bank), 1)])]), e.deleteButtonStatus ? (Y(), te("div", Sy, [_("button", {
                onClick: w[0] || (w[0] = G => L(!0, e.myCharacters[l.value].identifier)),
                class: "flex items-center main-color p-2 rounded mr-3 hover:bg-gray-500 transition-colors duration-200"
            }, [ue(q(Gd), {
                class: "w-6 h-3 text-white font-bold"
            })])])) : et("", !0), u.value > 1 ? (Y(), te("div", My, [_("button", {
                onClick: w[1] || (w[1] = G => h(-1)),
                class: "main-color p-2 rounded mr-3 hover:bg-gray-500 transition-colors duration-200"
            }, [ue(q(Yd), {
                class: "w-5 h-3 text-white font-bold"
            })]), _("button", {
                onClick: w[2] || (w[2] = G => h(1)),
                class: "main-color p-2 rounded hover:bg-gray-500 transition-colors duration-200"
            }, [ue(q(qd), {
                class: "w-5 h-3 text-white font-bold"
            })])])) : et("", !0)])) : (Y(), te("div", Ey, $y)), c.value ? (Y(), it(ty, {
                key: 2,
                citizenid: d.value,
                Lang: e.Lang.DeleteCharacter,
                onButtonMenuStatus: w[3] || (w[3] = G => L(!1))
            }, null, 8, ["citizenid", "Lang"])) : et("", !0), c.value ? et("", !0) : (Y(), it(sf, {
                key: 3,
                remeainSlot: e.remeainSlot,
                Lang: e.Lang.Menu,
                PageStatus: e.pagesList,
                onRegisterUpdated: y,
                onPhotomodeUpdated: O,
                onCreditsUpdated: O,
                onPlayGame: N,
                onStoreUpdated: U
            }, null, 8, ["remeainSlot", "Lang", "PageStatus"]))], 512), [
                [qt, !s.value]
            ]), o.value ? At((Y(), it(Lg, {
                key: 0,
                generateCID: t.value,
                Lang: e.Lang.CharacterInformation
            }, null, 8, ["generateCID", "Lang"])), [
                [qt, !n.value]
            ]) : et("", !0), n.value ? (Y(), it(Yg, {
                key: 1,
                Lang: e.Lang.PhotoMode
            }, null, 8, ["Lang"])) : et("", !0), i.value ? (Y(), it(Qg, {
                key: 2,
                pageURL: e.pagesList.Store.URL,
                onGoBack: U
            }, null, 8, ["pageURL"])) : et("", !0), a.value ? (Y(), it(zg, {
                key: 3,
                creditsList: e.pagesList.Credits.List
            }, null, 8, ["creditsList"])) : et("", !0), e.cinematicStatus ? At((Y(), it(ly, {
                key: 4
            }, null, 512)), [
                [qt, !n.value && !i.value && !a.value && !o.value]
            ]) : et("", !0)], 64))
        }
    },
    Ly = Zr(Fy, [
        ["__scopeId", "data-v-05b8bbe1"]
    ]),
    Ay = {
        __name: "App",
        setup(e) {
            const t = re(!1),
                r = re([]),
                n = re(0),
                a = re(!1),
                i = re([]),
                s = re([]),
                o = re(!1),
                l = re([]),
                u = re(!1);
            let c;
            const d = (g, y, k) => {
                    k === "start" ? (c = new Audio(`./audio/${g}`), c.volume = y, c.play()) : k === "stop" && c && (c.pause(), c.currentTime = 0)
                },
                h = g => {
                    const y = g.data;
                    if (y.ui) {
                        if (o.value = !0, y.myCharacters && Array.isArray(y.myCharacters)) {
                            let k = y.myCharacters.filter(O => O != null).length;
                            r.value = y.myCharacters, n.value = y.totalSlots - k, a.value = y.deleteButtonStatus
                        } else n.value = y.totalSlots;
                        i.value = y.Lang, s.value = y.pagesList, l.value = y.speechList, u.value = y.cinematicMode, setTimeout(() => {
                            o.value = !1, t.value = !0, y.bgMusic.Status && d(y.bgMusic.Name, y.bgMusic.Volume, "start")
                        }, 5e3)
                    } else t.value = !1, r.value = [], n.value = 0, y.bgMusic.Status && d(y.bgMusic.Name, y.bgMusic.Volume, "stop")
                };
            return ma(() => {
                window.addEventListener("message", h), kr("jsReady")
            }), Li(() => {
                window.removeEventListener("message", h)
            }), (g, y) => (Y(), te(Ue, null, [o.value ? (Y(), it(Id, {
                key: 0
            })) : et("", !0), t.value ? (Y(), it(Ly, {
                key: 1,
                myCharacters: r.value,
                remeainSlot: n.value,
                deleteButtonStatus: a.value,
                Lang: i.value,
                pagesList: s.value,
                speechList: l.value,
                cinematicStatus: u.value
            }, null, 8, ["myCharacters", "remeainSlot", "deleteButtonStatus", "Lang", "pagesList", "speechList", "cinematicStatus"])) : et("", !0)], 64))
        }
    },
    Ny = Ed(Ay);
Ny.mount("#app");